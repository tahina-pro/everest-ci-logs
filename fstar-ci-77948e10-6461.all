This is /home/everbld/everest-ci/ci
Working directory: /cygdrive/c/Build/Agent2/_work/1/s
About to run: make -C src utest -j 24 -k
BUILD_SOURCEBRANCHNAME: master
BUILD_DEFINITIONNAME: FStar-CI-Windows
make: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make all
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make[1]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
VS/.nuget/NuGet.exe restore VS/FStar.sln
Installing 'FsLexYacc.Runtime 6.1.0'.
Installing 'FsLexYacc 6.1.0'.
Successfully installed 'FsLexYacc.Runtime 6.1.0'.
Successfully installed 'FsLexYacc 6.1.0'.
make -C VS install-packages
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/VS'
[ -d packages ] || make update-nuget
.nuget/NuGet.exe restore FStar.sln
All packages listed in packages.config are already installed.
find packages -name '*.exe' -exec chmod +x '{}' ';'
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/VS'
"C:/Program Files (x86)/MSBuild/14.0/bin/amd64/"/MSBuild.exe /verbosity:minimal /p:Configuration=Release VS/FStar.sln
Microsoft (R) Build Engine version 14.0.25420.1
Copyright (C) Microsoft Corporation. All rights reserved.

basic -> C:\Build\Agent2\_work\1\s\bin\basic.dll
Restoring NuGet packages...
To prevent NuGet from downloading packages during build, open the Visual Studio Options dialog, click on the Package Manager node and uncheck 'Allow NuGet to download missing packages'.
All packages listed in packages.config are already installed.
prettyprint -> C:\Build\Agent2\_work\1\s\bin\prettyprint.dll
syntax -> C:\Build\Agent2\_work\1\s\bin\syntax.dll
compiling to dfas (can take a while...)
339 states
writing output
building tables
computing first function...time: 00:00:00.2035573
building kernels...time: 00:00:00.1358934
building kernel table...time: 00:00:00.0171926
computing lookahead relations..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................time: 00:00:00.4926480
building lookahead table...time: 00:00:00.2635510
building action table...state 406: shift/reduce error on SEMICOLON
state 412: shift/reduce error on BY
state 434: shift/reduce error on BAR
state 437: shift/reduce error on LBRACE
state 438: shift/reduce error on BAR
state 449: shift/reduce error on BAR
state 525: shift/reduce error on COLON_EQUALS
state 561: shift/reduce error on LBRACE
time: 00:00:00.7744792
building goto table...time: 00:00:00.2262182
returning tables.
8 shift/reduce conflicts
715 states
137 nonterminals
138 terminals
386 productions
#rows in action table: 715
parser -> C:\Build\Agent2\_work\1\s\bin\parser.dll
typechecker -> C:\Build\Agent2\_work\1\s\bin\typechecker.dll
format -> C:\Build\Agent2\_work\1\s\bin\format.dll
extraction -> C:\Build\Agent2\_work\1\s\bin\extraction.dll
fsdoc -> C:\Build\Agent2\_work\1\s\bin\fsdoc.dll
smtencoding -> C:\Build\Agent2\_work\1\s\bin\smtencoding.dll
tactics -> C:\Build\Agent2\_work\1\s\src\tactics\bin\Release\tactics.dll
tosyntax -> C:\Build\Agent2\_work\1\s\bin\tosyntax.dll
fstar -> C:\Build\Agent2\_work\1\s\bin\fstar.exe
C:\Build\Agent2\_work\1\s\src\tests\tactics.fs(53,19): warning FS0040: This and other recursive references to the object(s) being defined will be checked for initialization-soundness at runtime through the use of a delayed reference. This is because you are defining one or more recursive objects, rather than recursive functions. This warning may be suppressed by using '#nowarn "40"' or '--nowarn:40'. [C:\Build\Agent2\_work\1\s\src\tests\tests.fsproj]
tests -> C:\Build\Agent2\_work\1\s\bin\tests.exe
chmod a+x ../bin/tests.exe
chmod a+x ../bin/fstar.exe
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make fsharp-regressions #normalizer failures on linux so only run on windows
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make[1]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
../bin/tests.exe
Initializing ...
Goal is (l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0))))))))
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> intros
intros: x
TAC (ngoals=1, maingoal=(l_imp (eq2 x 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0)))))), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 x 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0)))))), rest=):
TAC>> imp_intro
imp_intro: uu___#170758
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0))))), rest=):
TAC>> rewrite
+++Rewrite uu___#170758 : (eq2 x 0)
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> split
TAC (ngoals=2, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))):
TAC>> debug
TAC (ngoals=2, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))):
TAC>> map
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> intros
intros: y
TAC (ngoals=1, maingoal=(l_imp (eq2 y 0) (eq2 0 y)), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 y 0) (eq2 0 y)), rest=):
TAC>> imp_intro
imp_intro: uu___#170762
TAC (ngoals=1, maingoal=(eq2 0 y), rest=):
TAC>> rewrite
+++Rewrite uu___#170762 : (eq2 y 0)
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying simplify_eq_impl
(eq2 0 0) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying trivial
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting y#170761
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is x |- l_True
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> map
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> intros
intros: z
TAC (ngoals=1, maingoal=(l_imp (eq2 z 0) (eq2 0 z)), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 z 0) (eq2 0 z)), rest=):
TAC>> imp_intro
imp_intro: uu___#170766
TAC (ngoals=1, maingoal=(eq2 0 z), rest=):
TAC>> rewrite
+++Rewrite uu___#170766 : (eq2 z 0)
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying simplify_eq_impl
(eq2 0 0) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying trivial
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting z#170765
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is x |- l_True
TAC (ngoals=2, maingoal=l_True, rest=l_True):
TAC>> merge_sub_goals
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting x#170757
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is  |- l_True
Goal: l_True
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make -C ocaml-output
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
cp "../extraction/ml/FStar_Extraction_ML_PrintML_4.02.3.ml" ../extraction/ml/FStar_Extraction_ML_PrintML.ml
# TODO : call menhir directly when positions are fixed instead of
# letting OCamlbuild go through ocamlyacc
menhir  --only-preprocess-for-ocamlyacc ../parser/parse.mly > parse.mly
Warning: you are using the standard library and/or the %inline keyword. We
recommend switching on --infer in order to avoid obscure type error messages.
warning: CRLF will be replaced by LF in src/parser/parse.fsi.
The file will have its original line endings in your working directory.
# Save a copy of the dumb parse.mly for whoever doesn't have menhir.
echo 'let dummy () = ();;' > FStar_Version.ml
cp parse.mly ../parser/ml/
echo 'FStar_Options._version := "0.9.4.2";;' >> FStar_Version.ml
echo "%{" > ../parser/parse.fsy
echo 'FStar_Options._platform := "Windows_x64";;' >> FStar_Version.ml
# We are opening the same module twice but we need these modules
echo "#light \"off\"" >> ../parser/parse.fsy
echo 'FStar_Options._compiler := "OCaml 4.02.3";;' >> FStar_Version.ml
# open for the definition of tokens
echo "// (c) Microsoft Corporation. All rights reserved" >> ../parser/parse.fsy
echo 'FStar_Options._date := "2017-04-10T06:10:00-07:00";;' >> FStar_Version.ml
echo "open Prims" > FStar_Parser_Parse.ml
echo "open Prims" >> ../parser/parse.fsy
echo 'FStar_Options._commit:= "77948e1 (dirty)";;' >> FStar_Version.ml
echo "open FStar_Errors" >> FStar_Parser_Parse.ml
echo "open FStar.Errors" >> ../parser/parse.fsy
echo "open FStar_List" >> FStar_Parser_Parse.ml
echo "open FStar.List" >> ../parser/parse.fsy
echo "open FStar_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Util" >> ../parser/parse.fsy
echo "open FStar_Range" >> FStar_Parser_Parse.ml
echo "open FStar.Range" >> ../parser/parse.fsy
echo "open FStar_Options" >> FStar_Parser_Parse.ml
echo "open FStar.Options" >> ../parser/parse.fsy
echo "open FStar_Syntax_Syntax" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Syntax" >> ../parser/parse.fsy
echo "open FStar_Syntax_Const" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Const" >> ../parser/parse.fsy
echo "open FStar_Syntax_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Util" >> ../parser/parse.fsy
echo "open FStar_Parser_AST" >> FStar_Parser_Parse.ml
echo "open FStar.Parser.AST" >> ../parser/parse.fsy
echo "open FStar_Parser_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Parser.Util" >> ../parser/parse.fsy
echo "open FStar_Const" >> FStar_Parser_Parse.ml
echo "open FStar.Const" >> ../parser/parse.fsy
echo "open FStar_Ident" >> FStar_Parser_Parse.ml
echo "open FStar.Ident" >> ../parser/parse.fsy
echo "open FStar_String" >> FStar_Parser_Parse.ml
echo "open FStar.String" >> ../parser/parse.fsy
# TODO: create a proper OCamlbuild rule for this production so that
# TODO : fsyacc seems to complain as soon as there is an arrow -> in a %type declaration...
# OCamlbuild knows how to generate parse.mly first (possibly using
cat parse.mly | sed -e '/%{/d' \
-e '/^open /d' \
-e '/%token/s/[a-zA-Z0-9_]*\.//g' \
-e '/%type/s/[a-zA-Z0-9_]*\.//g' \
-e '/%token.*->.*/d' \
-e '/%type.*->.*/d' \
>> ../parser/parse.fsy
# menhir) and removes the production as needed.
ocamlyacc parse.mly
7 shift/reduce conflicts.
cat parse.ml >> FStar_Parser_Parse.ml
rm parse.ml parse.mli
cd ../../ && ocamlbuild -cflag '-g' -I src/ocaml-output -I src/basic/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -j 24 -build-dir src/ocaml-output/_build -I src/prettyprint/ml -I src/ocaml-output/bootlibs -use-ocamlfind main.native
mkdir 'C:\Build\Agent2\_work\1\s\src/ocaml-output/_build'
mkdir src
mkdir src/fstar
mkdir src/fstar/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/fstar/ml/main.ml > src/fstar/ml/main.ml.depends
mkdir src/ocaml-output
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Main.ml > src/ocaml-output/FStar_Main.ml.depends
mkdir src/ocaml-output/bootlibs
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_All.ml > src/ocaml-output/bootlibs/FStar_All.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Common.ml > src/ocaml-output/FStar_Common.ml.depends
mkdir src/basic
mkdir src/basic/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Util.ml > src/basic/ml/FStar_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_List.ml > src/ocaml-output/bootlibs/FStar_List.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/prims.ml > src/ocaml-output/bootlibs/prims.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/MkPrims.ml > src/ocaml-output/bootlibs/MkPrims.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/MkPrims.cmo src/ocaml-output/bootlibs/MkPrims.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_List.cmo src/ocaml-output/bootlibs/FStar_List.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/prims.cmo src/ocaml-output/bootlibs/prims.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Util.cmo src/basic/ml/FStar_Util.ml
File "src/basic/ml/FStar_Util.ml", line 47, characters 57-65:
Warning 40: st_mtime was selected from type BatUnix.stats.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/basic/ml/FStar_Util.ml", line 659, characters 2-13:
Warning 10: this expression should have type unit.
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Dependencies.ml > src/ocaml-output/FStar_Dependencies.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_All.cmo src/ocaml-output/bootlibs/FStar_All.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Options.ml > src/ocaml-output/FStar_Options.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_BaseTypes.ml > src/ocaml-output/bootlibs/FStar_BaseTypes.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Char.ml > src/ocaml-output/bootlibs/FStar_Char.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Float.ml > src/ocaml-output/bootlibs/FStar_Float.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int16.ml > src/ocaml-output/bootlibs/FStar_Int16.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int32.ml > src/ocaml-output/bootlibs/FStar_Int32.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int64.ml > src/ocaml-output/bootlibs/FStar_Int64.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int8.ml > src/ocaml-output/bootlibs/FStar_Int8.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_UInt16.ml > src/ocaml-output/bootlibs/FStar_UInt16.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_UInt8.ml > src/ocaml-output/bootlibs/FStar_UInt8.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Char.cmo src/ocaml-output/bootlibs/FStar_Char.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Float.cmo src/ocaml-output/bootlibs/FStar_Float.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int16.cmo src/ocaml-output/bootlibs/FStar_Int16.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int32.cmo src/ocaml-output/bootlibs/FStar_Int32.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int64.cmo src/ocaml-output/bootlibs/FStar_Int64.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int8.cmo src/ocaml-output/bootlibs/FStar_Int8.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt16.cmo src/ocaml-output/bootlibs/FStar_UInt16.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt8.cmo src/ocaml-output/bootlibs/FStar_UInt8.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Getopt.ml > src/basic/ml/FStar_Getopt.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Platform.ml > src/basic/ml/FStar_Platform.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_ST.ml > src/ocaml-output/bootlibs/FStar_ST.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_String.ml > src/ocaml-output/bootlibs/FStar_String.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_BaseTypes.cmo src/ocaml-output/bootlibs/FStar_BaseTypes.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Getopt.cmo src/basic/ml/FStar_Getopt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Platform.cmo src/basic/ml/FStar_Platform.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_ST.cmo src/ocaml-output/bootlibs/FStar_ST.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_String.cmo src/ocaml-output/bootlibs/FStar_String.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Dep.ml > src/ocaml-output/FStar_Parser_Dep.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmo src/ocaml-output/FStar_Common.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Const.ml > src/ocaml-output/FStar_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Ident.ml > src/ocaml-output/FStar_Ident.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Range.ml > src/basic/ml/FStar_Range.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Range.cmo src/basic/ml/FStar_Range.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmo src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Errors.ml > src/ocaml-output/FStar_Errors.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmo src/ocaml-output/FStar_Options.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_AST.ml > src/ocaml-output/FStar_Parser_AST.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmo src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmo src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Const.ml > src/ocaml-output/FStar_Syntax_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Syntax.ml > src/ocaml-output/FStar_Syntax_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Unionfind.ml > src/basic/ml/FStar_Unionfind.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Unionfind.cmo src/basic/ml/FStar_Unionfind.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmo src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Print.ml > src/ocaml-output/FStar_Syntax_Print.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmo src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Subst.ml > src/ocaml-output/FStar_Syntax_Subst.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Option.ml > src/ocaml-output/bootlibs/FStar_Option.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Option.cmo src/ocaml-output/bootlibs/FStar_Option.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Util.ml > src/ocaml-output/FStar_Syntax_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_InstFV.ml > src/ocaml-output/FStar_Syntax_InstFV.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmo src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmo src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmo src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmo src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Driver.ml > src/ocaml-output/FStar_Parser_Driver.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmo src/ocaml-output/FStar_Parser_AST.ml
mkdir src/parser
mkdir src/parser/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_ParseIt.ml > src/parser/ml/FStar_Parser_ParseIt.ml.depends
''ocamllex.opt -q src/parser/ml/FStar_Parser_LexFStar.mll
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_LexFStar.ml > src/parser/ml/FStar_Parser_LexFStar.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Parse.ml > src/ocaml-output/FStar_Parser_Parse.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_Util.ml > src/parser/ml/FStar_Parser_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_Util.cmo src/parser/ml/FStar_Parser_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmo src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmo src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmo src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmo src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmo src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_Kremlin.ml > src/ocaml-output/FStar_Extraction_Kremlin.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Code.ml > src/ocaml-output/FStar_Extraction_ML_Code.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Bytes.ml > src/basic/ml/FStar_Bytes.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Syntax.ml > src/ocaml-output/FStar_Extraction_ML_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Util.ml > src/ocaml-output/FStar_Extraction_ML_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmo src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_UEnv.ml > src/ocaml-output/FStar_Extraction_ML_UEnv.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Env.ml > src/ocaml-output/FStar_TypeChecker_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Free.ml > src/ocaml-output/FStar_Syntax_Free.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Common.ml > src/ocaml-output/FStar_TypeChecker_Common.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmo src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmo src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmo src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmo src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Format.ml > src/ocaml-output/FStar_Format.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Bytes.cmo src/basic/ml/FStar_Bytes.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmo src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmo src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmo src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Modul.ml > src/ocaml-output/FStar_Extraction_ML_Modul.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Term.ml > src/ocaml-output/FStar_Extraction_ML_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Normalize.ml > src/ocaml-output/FStar_TypeChecker_Normalize.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcTerm.ml > src/ocaml-output/FStar_TypeChecker_TcTerm.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Err.ml > src/ocaml-output/FStar_TypeChecker_Err.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmo src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Rel.ml > src/ocaml-output/FStar_TypeChecker_Rel.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmo src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Util.ml > src/ocaml-output/FStar_TypeChecker_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmo src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmo src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmo src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmo src/ocaml-output/FStar_Extraction_ML_Term.ml
mkdir src/extraction
mkdir src/extraction/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/extraction/ml/FStar_Extraction_ML_PrintML.ml > src/extraction/ml/FStar_Extraction_ML_PrintML.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Fsdoc_Generator.ml > src/ocaml-output/FStar_Fsdoc_Generator.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Indent.ml > src/ocaml-output/FStar_Indent.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_ToDocument.ml > src/ocaml-output/FStar_Parser_ToDocument.ml.depends
mkdir src/prettyprint
mkdir src/prettyprint/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/prettyprint/ml/FStar_Pprint.ml > src/prettyprint/ml/FStar_Pprint.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/prettyprint/ml -I src/ocaml-output -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/prettyprint/ml/FStar_Pprint.cmo src/prettyprint/ml/FStar_Pprint.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmo src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Interactive.ml > src/ocaml-output/FStar_Interactive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmo src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Solver.ml > src/ocaml-output/FStar_SMTEncoding_Solver.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Encode.ml > src/ocaml-output/FStar_SMTEncoding_Encode.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml > src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Term.ml > src/ocaml-output/FStar_SMTEncoding_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Util.ml > src/ocaml-output/FStar_SMTEncoding_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmo src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Z3.ml > src/ocaml-output/FStar_SMTEncoding_Z3.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmo src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmo src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmo src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmo src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_Env.ml > src/ocaml-output/FStar_ToSyntax_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Universal.ml > src/ocaml-output/FStar_Universal.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Interleave.ml > src/ocaml-output/FStar_Parser_Interleave.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmo src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Interpreter.ml > src/ocaml-output/FStar_Tactics_Interpreter.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Basic.ml > src/ocaml-output/FStar_Tactics_Basic.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Embedding.ml > src/ocaml-output/FStar_Tactics_Embedding.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmo src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmo src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmo src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_ToSyntax.ml > src/ocaml-output/FStar_ToSyntax_ToSyntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_MutRecTy.ml > src/ocaml-output/FStar_Syntax_MutRecTy.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmo src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Tc.ml > src/ocaml-output/FStar_TypeChecker_Tc.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_DMFF.ml > src/ocaml-output/FStar_TypeChecker_DMFF.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcInductive.ml > src/ocaml-output/FStar_TypeChecker_TcInductive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmo src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmo src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmo src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmo src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmo src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmo src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmo src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Version.ml > src/ocaml-output/FStar_Version.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmo src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmo src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmo src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmo src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmo src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmo src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmo src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmo src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmo src/fstar/ml/main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/MkPrims.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/FStar_List.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/prims.cmx src/ocaml-output/bootlibs/prims.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Util.ml
File "src/basic/ml/FStar_Util.ml", line 47, characters 57-65:
Warning 40: st_mtime was selected from type BatUnix.stats.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/basic/ml/FStar_Util.ml", line 659, characters 2-13:
Warning 10: this expression should have type unit.
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_All.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Char.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Float.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int16.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int32.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int64.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_Int8.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt16.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_UInt8.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Getopt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Platform.cmx src/basic/ml/FStar_Platform.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_ST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/bootlibs/FStar_String.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Range.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Options.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Unionfind.cmx src/basic/ml/FStar_Unionfind.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/bootlibs/FStar_Option.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmx src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_Util.cmx src/parser/ml/FStar_Parser_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmx src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmx src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Bytes.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmx src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/prettyprint/ml -I src/ocaml-output -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/prettyprint/ml/FStar_Pprint.cmx src/prettyprint/ml/FStar_Pprint.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmx src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmx src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmx src/fstar/ml/main.ml
''ocamlfind ocamlopt -linkpkg -thread -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/prims.cmx src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Platform.cmx src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Unionfind.cmx src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Extraction_ML_Code.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Parser_AST.cmx src/parser/ml/FStar_Parser_Util.cmx src/ocaml-output/FStar_Parser_Parse.cmx src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_ParseIt.cmx src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Fsdoc_Generator.cmx src/prettyprint/ml/FStar_Pprint.cmx src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Main.cmx src/fstar/ml/main.cmx -o src/fstar/ml/main.native
# Parallel statistics: { count(total): 18(200), max: 8, min: 2, average(total): 3.889(1.260) }
cp _build/src/fstar/ml/main.native ../../bin/fstar.exe
cp _build/src/fstar/ml/main.native ../../bin/fstar.ocaml
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
make fstar-ocaml
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make ocaml
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
rm -rf boot_fstis u_boot_fsts u_ocaml-output
mkdir boot_fstis u_boot_fsts u_ocaml-output
make prep
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make[3]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
cp basic/string.fsi boot_fstis/FStar.string.fsti
cp basic/list.fsi boot_fstis/FStar.list.fst
sed -i 's/open Prims/module ALL_TEMP = FStar.All/g' boot_fstis/FStar.list.fst
sed -i 's/<.* when .* : equality>//g' boot_fstis/FStar.list.fst
sed -i 's/val/assume val/g' boot_fstis/FStar.list.fst
cp basic/util.fsi boot_fstis/FStar.util.fsti
sed -i 's/open System.IO/module ALL_TMP = FStar.All/g' boot_fstis/FStar.util.fsti
sed -i 's/type time.*/assume new type time/g'  boot_fstis/FStar.util.fsti
sed -i 's/type smap.*/assume new type smap : Type0 -> Type0/g'  boot_fstis/FStar.util.fsti
sed -i 's/type imap.*/assume new type imap : Type0 -> Type0/g'  boot_fstis/FStar.util.fsti
sed -i 's/type out_channel.*/assume new type out_channel/g'  boot_fstis/FStar.util.fsti
sed -i 's/type file_handle.*/assume new type file_handle/g'  boot_fstis/FStar.util.fsti
sed -i 's/type stream_reader.*/assume new type stream_reader/g'  boot_fstis/FStar.util.fsti
sed -i 's/type string_builder.*/assume new type string_builder/g'  boot_fstis/FStar.util.fsti
sed -i 's/type proc.*/assume new type proc/g' boot_fstis/FStar.util.fsti
sed -i 's/type set.*/assume new type set:Type0 -> Type0/g' boot_fstis/FStar.util.fsti
cp basic/platform.fsi boot_fstis/FStar.platform.fsti
cp basic/bytes.fsti boot_fstis/FStar.bytes.fst
cp basic/range.fsi boot_fstis/FStar.range.fsti
cp basic/version.fsi boot_fstis/FStar.version.fsti
cp basic/getopt.fsi boot_fstis/FStar.getopt.fsti
cp basic/unionfind.fsi boot_fstis/FStar.unionfind.fsti
sed -i 's/type pa_t.*/module ALL_TMP = FStar.All/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/and data.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| PArray.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| PDiff.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type puf_t.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type puf.*/assume new type puf : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type p_uvar.*/assume new type p_uvar : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type cell.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/and contents.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| Data.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| Fwd.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type uvar.*/assume new type uvar : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
cp prettyprint/prettyprint.fsi boot_fstis/FStar.Pprint.fsti
echo "#light \"off\"" > boot_fstis/FStar.Parser.Parse.fsti
head -n -12 parser/parse.fsi >> boot_fstis/FStar.Parser.Parse.fsti
sed -i 's/module FStar.Parser.Parse/module FStar.Parser.Parse\nopen FStar.All\nopen FStar.BaseTypes\ntype bytes = array<byte>\nopen FStar.Syntax.Syntax/' boot_fstis/FStar.Parser.Parse.fsti
make rename_as_fst
make[4]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
./tools/rename_all_boot_fsts
[rename_all_boot_fsts]: copying ./basic/FStar.Common.fs to u_boot_fsts/FStar.Common.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Const.fs to u_boot_fsts/FStar.Const.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Errors.fs to u_boot_fsts/FStar.Errors.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Ident.fs to u_boot_fsts/FStar.Ident.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Options.fs to u_boot_fsts/FStar.Options.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Options.fsi to u_boot_fsts/FStar.Options.fsti
./boot_fstis/FStar.bytes.fst is unrecognized
./boot_fstis/FStar.getopt.fsti is unrecognized
./boot_fstis/FStar.list.fst is unrecognized
./boot_fstis/FStar.Parser.Parse.fsti is unrecognized
./boot_fstis/FStar.platform.fsti is unrecognized
./boot_fstis/FStar.Pprint.fsti is unrecognized
./boot_fstis/FStar.range.fsti is unrecognized
./boot_fstis/FStar.string.fsti is unrecognized
./boot_fstis/FStar.unionfind.fsti is unrecognized
./boot_fstis/FStar.util.fsti is unrecognized
./boot_fstis/FStar.version.fsti is unrecognized
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.Kremlin.fs to u_boot_fsts/FStar.Extraction.Kremlin.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Code.fs to u_boot_fsts/FStar.Extraction.ML.Code.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Code.fsi to u_boot_fsts/FStar.Extraction.ML.Code.fsti
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Modul.fs to u_boot_fsts/FStar.Extraction.ML.Modul.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.PrintML.fs to u_boot_fsts/FStar.Extraction.ML.PrintML.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.PrintML.fsi to u_boot_fsts/FStar.Extraction.ML.PrintML.fsti
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Syntax.fs to u_boot_fsts/FStar.Extraction.ML.Syntax.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Term.fs to u_boot_fsts/FStar.Extraction.ML.Term.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.UEnv.fs to u_boot_fsts/FStar.Extraction.ML.UEnv.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Util.fs to u_boot_fsts/FStar.Extraction.ML.Util.fst
[rename_all_boot_fsts]: copying ./format/FStar.Format.fs to u_boot_fsts/FStar.Format.fst
[rename_all_boot_fsts]: copying ./fsdoc/FStar.Fsdoc.Generator.fs to u_boot_fsts/FStar.Fsdoc.Generator.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Dependencies.fs to u_boot_fsts/FStar.Dependencies.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Indent.fs to u_boot_fsts/FStar.Indent.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Interactive.fs to u_boot_fsts/FStar.Interactive.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Main.fs to u_boot_fsts/FStar.Main.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Top.fs to u_boot_fsts/FStar.Top.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Universal.fs to u_boot_fsts/FStar.Universal.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.AST.fs to u_boot_fsts/FStar.Parser.AST.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Dep.fs to u_boot_fsts/FStar.Parser.Dep.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Dep.fsi to u_boot_fsts/FStar.Parser.Dep.fsti
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Driver.fs to u_boot_fsts/FStar.Parser.Driver.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Interleave.fs to u_boot_fsts/FStar.Parser.Interleave.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Lexhelp.fs to u_boot_fsts/FStar.Parser.Lexhelp.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.ToDocument.fs to u_boot_fsts/FStar.Parser.ToDocument.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.ToDocument.fsi to u_boot_fsts/FStar.Parser.ToDocument.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Encode.fs to u_boot_fsts/FStar.SMTEncoding.Encode.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Encode.fsi to u_boot_fsts/FStar.SMTEncoding.Encode.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.ErrorReporting.fs to u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.ErrorReporting.fsi to u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Solver.fs to u_boot_fsts/FStar.SMTEncoding.Solver.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Solver.fsi to u_boot_fsts/FStar.SMTEncoding.Solver.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.SplitQueryCases.fs to u_boot_fsts/FStar.SMTEncoding.SplitQueryCases.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Term.fs to u_boot_fsts/FStar.SMTEncoding.Term.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Term.fsi to u_boot_fsts/FStar.SMTEncoding.Term.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Util.fs to u_boot_fsts/FStar.SMTEncoding.Util.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Z3.fs to u_boot_fsts/FStar.SMTEncoding.Z3.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Const.fs to u_boot_fsts/FStar.Syntax.Const.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Free.fs to u_boot_fsts/FStar.Syntax.Free.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Free.fsi to u_boot_fsts/FStar.Syntax.Free.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.InstFV.fs to u_boot_fsts/FStar.Syntax.InstFV.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.InstFV.fsi to u_boot_fsts/FStar.Syntax.InstFV.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.MutRecTy.fs to u_boot_fsts/FStar.Syntax.MutRecTy.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.MutRecTy.fsi to u_boot_fsts/FStar.Syntax.MutRecTy.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Print.fs to u_boot_fsts/FStar.Syntax.Print.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Print.fsi to u_boot_fsts/FStar.Syntax.Print.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Subst.fs to u_boot_fsts/FStar.Syntax.Subst.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Subst.fsi to u_boot_fsts/FStar.Syntax.Subst.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Syntax.fs to u_boot_fsts/FStar.Syntax.Syntax.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Syntax.fsi to u_boot_fsts/FStar.Syntax.Syntax.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Util.fs to u_boot_fsts/FStar.Syntax.Util.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Basic.fs to u_boot_fsts/FStar.Tactics.Basic.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Embedding.fs to u_boot_fsts/FStar.Tactics.Embedding.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Interpreter.fs to u_boot_fsts/FStar.Tactics.Interpreter.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.Env.fs to u_boot_fsts/FStar.ToSyntax.Env.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.Env.fsi to u_boot_fsts/FStar.ToSyntax.Env.fsti
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.ToSyntax.fs to u_boot_fsts/FStar.ToSyntax.ToSyntax.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.ToSyntax.fsi to u_boot_fsts/FStar.ToSyntax.ToSyntax.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Common.fs to u_boot_fsts/FStar.TypeChecker.Common.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.DMFF.fs to u_boot_fsts/FStar.TypeChecker.DMFF.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.DMFF.fsi to u_boot_fsts/FStar.TypeChecker.DMFF.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Env.fs to u_boot_fsts/FStar.TypeChecker.Env.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Env.fsi to u_boot_fsts/FStar.TypeChecker.Env.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Err.fs to u_boot_fsts/FStar.TypeChecker.Err.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Normalize.fs to u_boot_fsts/FStar.TypeChecker.Normalize.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Normalize.fsi to u_boot_fsts/FStar.TypeChecker.Normalize.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Rel.fs to u_boot_fsts/FStar.TypeChecker.Rel.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Rel.fsi to u_boot_fsts/FStar.TypeChecker.Rel.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Tc.fs to u_boot_fsts/FStar.TypeChecker.Tc.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Tc.fsi to u_boot_fsts/FStar.TypeChecker.Tc.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcInductive.fs to u_boot_fsts/FStar.TypeChecker.TcInductive.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcInductive.fsi to u_boot_fsts/FStar.TypeChecker.TcInductive.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcTerm.fs to u_boot_fsts/FStar.TypeChecker.TcTerm.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcTerm.fsi to u_boot_fsts/FStar.TypeChecker.TcTerm.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Util.fs to u_boot_fsts/FStar.TypeChecker.Util.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Util.fsi to u_boot_fsts/FStar.TypeChecker.Util.fsti
cp parser/parseit.fsi u_boot_fsts/FStar.Parser.Parseit.fsti
make[4]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
#fix up a use of polymorphic recursion in F#, which has a different syntax than F*
sed -i 's/^and unembed_tactic_0.*//g' u_boot_fsts/FStar.Tactics.Interpreter.fst
sed -i 's/^\/\/F\* version: and unembed_tactic_0/and unembed_tactic_0/g' u_boot_fsts/FStar.Tactics.Interpreter.fst
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make u_extract_all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Common.fst u_boot_fsts/FStar.Options.fst u_boot_fsts/FStar.Ident.fst u_boot_fsts/FStar.Errors.fst u_boot_fsts/FStar.Const.fst u_boot_fsts/FStar.Format.fst --extract_module FStar.Common --extract_module FStar.Options --extract_module FStar.Ident --extract_module FStar.Errors --extract_module FStar.Const --extract_module FStar.Format
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Syntax.Syntax.fst u_boot_fsts/FStar.Syntax.Const.fst u_boot_fsts/FStar.Syntax.Subst.fst u_boot_fsts/FStar.Syntax.Free.fst u_boot_fsts/FStar.Syntax.InstFV.fst u_boot_fsts/FStar.Syntax.Util.fst u_boot_fsts/FStar.Syntax.Print.fst u_boot_fsts/FStar.Syntax.MutRecTy.fst u_boot_fsts/FStar.Fsdoc.Generator.fst --extract_namespace FStar.Syntax --extract_namespace FStar.Fsdoc
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Parser.AST.fst u_boot_fsts/FStar.Parser.Interleave.fst u_boot_fsts/FStar.Parser.Lexhelp.fst u_boot_fsts/FStar.Parser.Parseit.fsti u_boot_fsts/FStar.Parser.Driver.fst u_boot_fsts/FStar.Parser.Dep.fst u_boot_fsts/FStar.Parser.ToDocument.fst --extract_namespace FStar.Parser
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Common.fst u_boot_fsts/FStar.TypeChecker.Env.fst u_boot_fsts/FStar.TypeChecker.Normalize.fst u_boot_fsts/FStar.TypeChecker.Err.fst --extract_namespace FStar.TypeChecker
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Rel.fst --extract_module FStar.TypeChecker.Rel
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Util.fst --extract_module FStar.TypeChecker.Util
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.DMFF.fst --extract_module FStar.TypeChecker.DMFF
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.TcTerm.fst --extract_module FStar.TypeChecker.TcTerm
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.TcInductive.fst --extract_module FStar.TypeChecker.TcInductive
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Tc.fst --extract_module FStar.TypeChecker.Tc
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.ToSyntax.Env.fst u_boot_fsts/FStar.ToSyntax.ToSyntax.fst --extract_namespace FStar.ToSyntax
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Term.fst u_boot_fsts/FStar.SMTEncoding.Util.fst u_boot_fsts/FStar.SMTEncoding.Z3.fst u_boot_fsts/FStar.SMTEncoding.SplitQueryCases.fst u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fst --extract_namespace FStar.SMTEncoding
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Encode.fst --extract_module FStar.SMTEncoding.Encode
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Solver.fst --extract_module FStar.SMTEncoding.Solver
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Extraction.ML.Syntax.fst u_boot_fsts/FStar.Extraction.ML.UEnv.fst u_boot_fsts/FStar.Extraction.ML.Util.fst u_boot_fsts/FStar.Extraction.ML.Code.fst u_boot_fsts/FStar.Extraction.ML.Term.fst u_boot_fsts/FStar.Extraction.ML.Modul.fst u_boot_fsts/FStar.Extraction.Kremlin.fst --extract_namespace FStar.Extraction
# cp tactics/FStar.Tactics.Basic.fs u_boot_fsts/FStar.Tactics.Basic.fst
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Dependencies.fst u_boot_fsts/FStar.Interactive.fst u_boot_fsts/FStar.Universal.fst u_boot_fsts/FStar.Indent.fst u_boot_fsts/FStar.Main.fst --extract_module FStar.Dependencies --extract_module FStar.Interactive --extract_module FStar.Universal --extract_module FStar.Indent --extract_module FStar.Main
# cp tactics/FStar.Tactics.Embedding.fs u_boot_fsts/FStar.Tactics.Embedding.fst
# cp tactics/FStar.Tactics.Interpreter.fs u_boot_fsts/FStar.Tactics.Interpreter.fst
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Tactics.Basic.fst u_boot_fsts/FStar.Tactics.Embedding.fst u_boot_fsts/FStar.Tactics.Interpreter.fst --extract_namespace FStar.Tactics
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
.\u_boot_fsts\FStar.Syntax.Syntax.fst(395,0-395,33): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(445,0-445,48): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(446,0-446,76): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(497,0-499,38): (Warning) Annotation from val declaration overrides inline type annotation
Extracted module Common
Extracted module Ident
Extracted module Const
Extracted module Options
Extracted module Errors
Extracted module Format
All verification conditions discharged successfully
.\u_boot_fsts\FStar.TypeChecker.Env.fst(280,0-284,35): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.TypeChecker.Util.fst(70,0-72,32): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.TypeChecker.Env.fst(718,0-720,39): (Warning) Annotation from val declaration overrides inline type annotation
Extracted module Basic
Extracted module Embedding
Extracted module Interpreter
All verification conditions discharged successfully
Extracted module Syntax
Extracted module Const
Extracted module Subst
Extracted module InstFV
Extracted module Util
Extracted module TcInductive
All verification conditions discharged successfully
Extracted module Print
C:\Build\Agent2\_work\1\s\src\boot_fstis\FStar.Pprint.fsti(33,0-33,13) (Warning): Adding an implicit 'assume new' qualifier on document
Extracted module Generator
Extracted module Free
Extracted module MutRecTy
All verification conditions discharged successfully
Extracted module Term
Extracted module Z3
Extracted module Util
Extracted module ErrorReporting
Extracted module SplitQueryCases
All verification conditions discharged successfully
Extracted module AST
Extracted module Driver
Extracted module Dep
Extracted module Interleave
Extracted module Lexhelp
Extracted module Util
All verification conditions discharged successfully
Extracted module Common
Extracted module ToDocument
All verification conditions discharged successfully
Extracted module Env
Extracted module Normalize
Extracted module Err
All verification conditions discharged successfully
C:\Build\Agent2\_work\1\s\src\boot_fstis\FStar.Pprint.fsti(33,0-33,13) (Warning): Adding an implicit 'assume new' qualifier on document
Extracted module Syntax
Extracted module UEnv
Extracted module Util
Extracted module Solver
All verification conditions discharged successfully
Extracted module Code
Extracted module DMFF
All verification conditions discharged successfully
Extracted module Kremlin
Extracted module Term
Extracted module Modul
All verification conditions discharged successfully
Extracted module Tc
All verification conditions discharged successfully
Extracted module Dependencies
Extracted module Indent
Extracted module Universal
Extracted module Interactive
Extracted module Main
All verification conditions discharged successfully
Extracted module Env
Extracted module ToSyntax
All verification conditions discharged successfully
Extracted module TcTerm
All verification conditions discharged successfully
Extracted module Rel
All verification conditions discharged successfully
Extracted module Encode
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
cp u_ocaml-output/*.ml ocaml-output/
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make boot-ocaml
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make -C ocaml-output all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
cp "../extraction/ml/FStar_Extraction_ML_PrintML_4.02.3.ml" ../extraction/ml/FStar_Extraction_ML_PrintML.ml
warning: CRLF will be replaced by LF in src/parser/ml/parse.mly.
The file will have its original line endings in your working directory.
warning: CRLF will be replaced by LF in src/parser/parse.fsi.
The file will have its original line endings in your working directory.
echo 'let dummy () = ();;' > FStar_Version.ml
echo 'FStar_Options._version := "0.9.4.2";;' >> FStar_Version.ml
echo 'FStar_Options._platform := "Windows_x64";;' >> FStar_Version.ml
echo 'FStar_Options._compiler := "OCaml 4.02.3";;' >> FStar_Version.ml
echo 'FStar_Options._date := "2017-04-10T06:13:24-07:00";;' >> FStar_Version.ml
echo 'FStar_Options._commit:= "77948e1 (dirty)";;' >> FStar_Version.ml
cd ../../ && ocamlbuild -cflag '-g' -I src/ocaml-output -I src/basic/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -j 24 -build-dir src/ocaml-output/_build -I src/prettyprint/ml -I src/ocaml-output/bootlibs -use-ocamlfind main.native
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Main.ml > src/ocaml-output/FStar_Main.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Common.ml > src/ocaml-output/FStar_Common.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Dependencies.ml > src/ocaml-output/FStar_Dependencies.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Options.ml > src/ocaml-output/FStar_Options.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Dep.ml > src/ocaml-output/FStar_Parser_Dep.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmo src/ocaml-output/FStar_Common.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Const.ml > src/ocaml-output/FStar_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Ident.ml > src/ocaml-output/FStar_Ident.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmo src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Errors.ml > src/ocaml-output/FStar_Errors.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmo src/ocaml-output/FStar_Options.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_AST.ml > src/ocaml-output/FStar_Parser_AST.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmo src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmo src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Const.ml > src/ocaml-output/FStar_Syntax_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Syntax.ml > src/ocaml-output/FStar_Syntax_Syntax.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmo src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Print.ml > src/ocaml-output/FStar_Syntax_Print.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmo src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Subst.ml > src/ocaml-output/FStar_Syntax_Subst.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Util.ml > src/ocaml-output/FStar_Syntax_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_InstFV.ml > src/ocaml-output/FStar_Syntax_InstFV.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmo src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmo src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmo src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmo src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Driver.ml > src/ocaml-output/FStar_Parser_Driver.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmo src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmo src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmo src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_Kremlin.ml > src/ocaml-output/FStar_Extraction_Kremlin.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Code.ml > src/ocaml-output/FStar_Extraction_ML_Code.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Syntax.ml > src/ocaml-output/FStar_Extraction_ML_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Util.ml > src/ocaml-output/FStar_Extraction_ML_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmo src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_UEnv.ml > src/ocaml-output/FStar_Extraction_ML_UEnv.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Env.ml > src/ocaml-output/FStar_TypeChecker_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Free.ml > src/ocaml-output/FStar_Syntax_Free.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Common.ml > src/ocaml-output/FStar_TypeChecker_Common.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmo src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmo src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmo src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmo src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Format.ml > src/ocaml-output/FStar_Format.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmo src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmo src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmo src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Modul.ml > src/ocaml-output/FStar_Extraction_ML_Modul.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Term.ml > src/ocaml-output/FStar_Extraction_ML_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Normalize.ml > src/ocaml-output/FStar_TypeChecker_Normalize.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcTerm.ml > src/ocaml-output/FStar_TypeChecker_TcTerm.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Err.ml > src/ocaml-output/FStar_TypeChecker_Err.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmo src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Rel.ml > src/ocaml-output/FStar_TypeChecker_Rel.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmo src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Util.ml > src/ocaml-output/FStar_TypeChecker_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmo src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmo src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmo src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmo src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Fsdoc_Generator.ml > src/ocaml-output/FStar_Fsdoc_Generator.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Indent.ml > src/ocaml-output/FStar_Indent.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_ToDocument.ml > src/ocaml-output/FStar_Parser_ToDocument.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmo src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Interactive.ml > src/ocaml-output/FStar_Interactive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmo src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Solver.ml > src/ocaml-output/FStar_SMTEncoding_Solver.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Encode.ml > src/ocaml-output/FStar_SMTEncoding_Encode.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml > src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Term.ml > src/ocaml-output/FStar_SMTEncoding_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Util.ml > src/ocaml-output/FStar_SMTEncoding_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmo src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Z3.ml > src/ocaml-output/FStar_SMTEncoding_Z3.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmo src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmo src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmo src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmo src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_Env.ml > src/ocaml-output/FStar_ToSyntax_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Universal.ml > src/ocaml-output/FStar_Universal.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Interleave.ml > src/ocaml-output/FStar_Parser_Interleave.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmo src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Interpreter.ml > src/ocaml-output/FStar_Tactics_Interpreter.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Basic.ml > src/ocaml-output/FStar_Tactics_Basic.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Embedding.ml > src/ocaml-output/FStar_Tactics_Embedding.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmo src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmo src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmo src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_ToSyntax.ml > src/ocaml-output/FStar_ToSyntax_ToSyntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_MutRecTy.ml > src/ocaml-output/FStar_Syntax_MutRecTy.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmo src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Tc.ml > src/ocaml-output/FStar_TypeChecker_Tc.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_DMFF.ml > src/ocaml-output/FStar_TypeChecker_DMFF.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcInductive.ml > src/ocaml-output/FStar_TypeChecker_TcInductive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmo src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmo src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmo src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmo src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmo src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmo src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmo src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Version.ml > src/ocaml-output/FStar_Version.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmo src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmo src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmo src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmo src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmo src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmo src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmo src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Options.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmx src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmx src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmx src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmx src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmx src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmx src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmx src/fstar/ml/main.ml
''ocamlfind ocamlopt -linkpkg -thread -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/prims.cmx src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Platform.cmx src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Unionfind.cmx src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Extraction_ML_Code.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Parser_AST.cmx src/parser/ml/FStar_Parser_Util.cmx src/ocaml-output/FStar_Parser_Parse.cmx src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_ParseIt.cmx src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Fsdoc_Generator.cmx src/prettyprint/ml/FStar_Pprint.cmx src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Main.cmx src/fstar/ml/main.cmx -o src/fstar/ml/main.native
# Parallel statistics: { count(total): 12(227), max: 7, min: 2, average(total): 3.083(1.110) }
cp _build/src/fstar/ml/main.native ../../bin/fstar.exe
cp _build/src/fstar/ml/main.native ../../bin/fstar.ocaml
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make uregressions interactive-test
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make -C ../ulib
make -C ../examples all
make -C tests/interactive
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib'
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples'
make -C bug-reports all
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/tests/interactive'
for a in transcript-good*; do echo "Checking $a"; cat $a | ../../../bin/fstar-any.sh --in test.fst | tail -n 1 | grep done-ok || exit 1; done
make -C hello all
make -C data_structures all
Checking transcript-good-1
make -C algorithms all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int.fst
make -C crypto all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bug-reports'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bug-reports'
make -C termination all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/hello'
../../bin/fstar.exe --verify_module hello hello.fst
make -C software_foundations all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/data_structures'
make -C ../doc/tutorial/code/exercises all
make -C ../doc/tutorial/code/solutions all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/algorithms'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/crypto'
make -C rel all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.ST.fst
make -C maths all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/termination'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/software_foundations'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinaryTrees BinaryTrees.fst
make -C paradoxes all
make -C printf all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/exercises'
make -C metatheory all
make -C verifythis all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/solutions'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/rel'
make -C preorders all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearch BinarySearch.fst
make -C dm4free all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/maths'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 AES.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/paradoxes'
make -C incl all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.TwoLevelHeap.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Simple CPS.Simple.fst
make -C struct all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfBasic SfBasic.fst
make -C micro-benchmarks all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/metatheory'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTree BinarySearchTree.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/printf'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/verifythis'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/preorders'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/incl'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex01a.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/struct'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Bijection Bijection.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/dm4free'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex01a.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Gcd Gcd.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints PropositionalExtensionalityInconsistent.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/micro-benchmarks'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ParSubst ParSubst.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints 2015/Problem01.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SimplePrintf SimplePrintf.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ImmutableST ImmutableST.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include open.pos --odir open.pos Test.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include point-with-nesting.pos --odir point-with-nesting.pos Test.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.MonadLaws.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Basic Unit1.Basic.fst
is_smt_pat called with ((ensures (=(t1, t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.ST (115 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall p1:Type.{:pattern } forall p2:Type.{:pattern } <==>((<==>(p1, p2)), ==(p1, p2)))))
is_smt_pat called with ((ensures (<==>(peq #a p1 p2, ==(p1, p2)))))
is_smt_pat called with ((ensures (==(p1 0, p2 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Tcp.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
.\hello.fst(5,0-5,37): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Hello (29 milliseconds)
is_smt_pat called with ((ensures (==(p1, p2))))
All verification conditions discharged successfully
Verified module: Test (23 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/hello'
make -C bytes all
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include private.pos --odir private.pos Test.fst
is_smt_pat called with ((ensures (bijection f)))
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bytes'
#done-ok
Checking transcript-good-2
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Platform.Bytes Platform.Bytes.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Bijection (246 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Equivalence Equivalence.fst
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: PropositionalExtensionalityInconsistent (1145 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --__no_positivity propImpredicativeAndNonStrictlyPositiveinductives.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Ex01a.fst(68,0-68,48): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex01a (696 milliseconds)
All verification conditions discharged successfully
.\Ex01a.fst(58,0-58,48): (Warning) Top-level let-bindings must be total; this term may have effects
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex02a.fst
Verified module: Ex01a (866 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex02a.fst
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
Verified module: FStar.DM4F.MonadLaws (1259 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints Effects.Def.fst
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: ImmutableST (1722 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module AllocST AllocST.fst
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: BinarySearchTree (2299 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTree0 BinarySearchTree0.fst
Verified module: ParSubst (3119 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcCbvDbPntSubstNoLists StlcCbvDbPntSubstNoLists.fst
Verified module: Test (27 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include shadow.pos --odir shadow.pos Test.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
#done-ok
Checking transcript-good-3
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.TwoLevelHeap (2860 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Integers.fst
Verified module: CPS.Simple (150 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Double CPS.Double.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures /\(/\((forall a:Type f:m a.{:pattern } ==(bind a a f (return a), f)), (forall a:Type b:Type x:a f:Unidentified product: [a] (Tot (m b)).{:pattern } ==(bind a b (return a x) f, f x))), (forall a:Type b:Type c:Type f:m a g:(Unidentified product: [a] (Tot (m b))) h:(Unidentified product: [b] (Tot (m c))).{:pattern } ==(bind a c f ((fun x -> bind b c (g x) h)), bind b c (bind a b f g) h)))))
is_smt_pat called with ((ensures /\((forall a:Type x:a.{:pattern } ==(lift a (return_m a x), return_n a x)), (forall a:Type b:Type f:m a g:Unidentified product: [a] (Tot (m b)).{:pattern } ==(lift b (bind_m a b f g), bind_n a b (lift a f) ((fun x -> lift b (g x))))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
Verified module: FStar.Int (5859 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt63.fst
is_smt_pat called with ((ensures (==(x0, x0'))))
is_smt_pat called with ((ensures (==(p, p'))))
is_smt_pat called with ((ensures (~((p0 x0)))))
is_smt_pat called with ((ensures (p0 x0)))
Verified module: SimplePrintf (3771 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/printf'
make -C tactics all
Verified module: Ex02a (240 milliseconds)
All verification conditions discharged successfully
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/tactics'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03a.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MetaCoq MetaCoq.fst
Verified module: Problem01 (1597 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/verifythis'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include jsonparser.pos --odir jsonparser.pos Test.fst
Verified module: Ex02a (231 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03a.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Gcd (680 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/maths'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcStrongDbParSubst StlcStrongDbParSubst.fst
Verified module: SfBasic (7241 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfLists SfLists.fst
Verified module: PropImpredicativeAndNonStrictlyPositiveInductives (1433 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/paradoxes'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfPoly SfPoly.fst
Verified module: Test (28 milliseconds)
All verification conditions discharged successfully
Verified module: Effects.Def (2400 milliseconds)
All verification conditions discharged successfully
Verified module: BinarySearchTree0 (1092 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include trans.pos --odir trans.pos Test.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntST.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Encrypt_SymEnc.fst
Verified module: AllocST (1389 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module NatHeap NatHeap.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==>(_ (bsearch t a), /\(/\((>=(_ (bsearch t a), 0)), (<(_ (bsearch t a), (length t)))), (=(index t (_ (bsearch t a)), a)))))))
is_smt_pat called with ((ensures (forall x.{:pattern } (==>((/\(/\((<=(x, y)), (<(y, a))), (=(x, a)))), False)))))
is_smt_pat called with ((ensures (forall p.{:pattern } (==>((/\(/\(/\((<=(0, p)), (<(p, length t))), (=(index t p, a))), (<=(p, mid)))), False)))))
is_smt_pat called with ((ensures (forall x.{:pattern } (==>((/\(/\((<=(y, x)), (<(a, y))), (=(x, a)))), False)))))
is_smt_pat called with ((ensures (forall p.{:pattern } (==>((/\(/\(/\((<=(0, p)), (<(p, length t))), (=(index t p, a))), (<=(mid, p)))), False)))))
is_smt_pat called with ((ensures (==>((_ (bsearch t a)), (forall p.{:pattern } ==>(<=(0, p), ==>(<(p, length t), <>(index t p, a))))))))
is_smt_pat called with ((ensures (==(reify (if e () then e1 () else e2 ()) h0, reify (e1 ()) h0))))
is_smt_pat called with ((ensures (==(reify (if e () then e1 () else e2 ()) h0, reify (e1 ()) h0))))
is_smt_pat called with ((ensures (==(p1, p2))))
unknown(0,0-0,0): (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
unknown(0,0-0,0): (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
#done-ok
for a in transcript-bad*; do echo "Checking $a"; cat $a | ../../../bin/fstar-any.sh --in test.fst | tail -n 1 | grep done-nok || exit 1; done
Checking transcript-bad-1
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: CPS.Double (145 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.DoubleLambdaLifting2 CPS.DoubleLambdaLifting2.fst
is_smt_pat called with ((ensures (f x)))
Verified module: Equivalence (928 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcComposeReify IfcComposeReify.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
Verified module: Ex03a (268 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03b.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: AES (616 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Encrypt_Sample.fst
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (let  p = splitTwo s i in =(^(fst p, snd p), s))))
is_smt_pat called with ((ensures =(substringT s i2 n2, substringT (substringT s i n) (-(i2, i)) n2)))
is_smt_pat called with ((ensures <==>(=(String.compare a b, 0), =(a, b))))
is_smt_pat called with ((ensures (/\(=(s1, t1), =(s2, t2)))))
is_smt_pat called with ((ensures <==>(bytes_eq a b, =(a, b))))
is_smt_pat called with ((ensures (/\(=(s1, t1), =(s2, t2)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex03a (249 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03b.fst
.\Platform.Bytes.fst(15,32-18,29): (Warning) Pattern misses at least one bound variable: uu___#1090
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: Test (22 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include plain.pos --odir plain.pos Test.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
unknown(0,0-0,0): (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
#done-nok
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/tests/interactive'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03c.fst
Verified module: CPS.DoubleLambdaLifting2 (148 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.DoubleDefun CPS.DoubleDefun.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: BinarySearch (5282 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module IntSort IntSort.fst
Verified module: MetaCoq (3101 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/tactics'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module InsertionSort InsertionSort.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: Ex03b (132 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03c.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex03b (128 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include disjoint.pos --odir disjoint.pos Test.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: StlcCbvDbPntSubstNoLists (8037 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcCbvDbParSubst StlcCbvDbParSubst.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Test (28 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include noshadow.pos --odir noshadow.pos Test.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex03c (143 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04a.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.DM4F.IntST (4708 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Exceptions.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: NatHeap (6290 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ImmutableSTwHeaps ImmutableSTwHeaps.fst
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex03c (321 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04a.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: CPS.DoubleDefun (1491 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Expr CPS.Expr.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
Verified module: Test (28 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include field.pos --odir field.pos Test.fst
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.Tcp (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.Base.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: SfLists (8619 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDeclassify IfcDeclassify.fst
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
WARNING: (6712,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Ex04a (276 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04b.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
WARNING: (67353,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
Verified module: Ex04a (421 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Test (19 milliseconds)
All verification conditions discharged successfully
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include plain.neg --odir plain.neg Test.fst > plain.neg/error.log 2>&1
Verified module: ImmutableSTwHeaps (822 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
.\Encrypt_SymEnc.fst(29,0-29,18): (Warning) Top-level let-bindings must be total; this term may have effects
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ReifyTest ReifyTest.fst
Verified module: CPS.Expr (733 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
WARNING: (6968,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: StlcStrongDbParSubst (11027 milliseconds)
All verification conditions discharged successfully
Verified module: BinaryTrees (23071 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.SimpleDefun CPS.SimpleDefun.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04b.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTreeBasic BinarySearchTreeBasic.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints LambdaOmega.fst --max_fuel 1 --max_ifuel 1 --initial_fuel 1
is_smt_pat called with ((ensures (=(length (append l1 l2), +(length l1, length l2)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex04b (346 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04c.fst
Verified module: Encrypt_SymEnc (2716 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 SHA1.fst
Verified module: InsertionSort (1179 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MergeSort MergeSort.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: IntSort (2220 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04c.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
plain.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include shadow.neg --odir shadow.neg Test.fst > shadow.neg/error.log 2>&1
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r lo hi (_ h)) (p1_r lo hi (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p2_r lo hi (_ h)) (p2_r lo hi (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p3_r lo1 lo2 hi (_ h)) (p3_r lo1 lo2 hi (_ h)))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Encrypt_Sample (74 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(esubst s1 e, esubst s2 e))))
is_smt_pat called with ((ensures (=(esubst s ((ELam t e)), (ELam t (esubst (esub_lam s) e))))))
is_smt_pat called with ((ensures (=(tsubst s1 t, tsubst s2 t))))
is_smt_pat called with (decreases (Prims.LexCons is_tvar t (Prims.LexCons is_trenaming s1 (Prims.LexCons is_trenaming s2 (Prims.LexCons t (Prims.LexTop ))))))
is_smt_pat called with (decreases t1)
is_smt_pat called with (decreases s)
is_smt_pat called with ((ensures (=((tsub_comp (tsub_beta_gen x s1) (tsub_beta_gen y s2)) v, (tsub_comp (tsub_beta_gen y (tsubst_beta_gen x s1 s2)) (tsub_beta_gen (+(x, 1)) (tshift_up_above y s1))) v))))
is_smt_pat called with ((ensures (=(ts x s (ts y t2 t1), ts y (ts x s t2) (ts (+(x, 1)) (tsh y s) t1)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 MAC.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (let  sl = snd (reify (f ()) (_ s)) in let  sr = snd (reify (f ()) (_ s)) in (\/(\/(sl.release, sr.release), low_equiv ((R sl sr)))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
Verified module: SfPoly (12743 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.DM4F.Exceptions (4568 milliseconds)
All verification conditions discharged successfully
WARNING: (6635,66): pattern does not contain any variable.
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/software_foundations'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04e.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.ExnSt.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(length (append l1 l2), +(length l1, length l2)))))
is_smt_pat called with (decreases t)
Verified module: Ex04c (1039 milliseconds)
All verification conditions discharged successfully
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include open.neg --odir open.neg Test.fst > open.neg/error.log 2>&1
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
Verified module: Ex04b (531 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04e.fst
Verified module: IfcComposeReify (3175 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDelimitedRelease IfcDelimitedRelease.fst
Verified module: Ex04c (514 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.SimpleLambdaLifting CPS.SimpleLambdaLifting.fst
.\Platform.Bytes.fst(257,22-260,30): (Warning) Pattern misses at least one bound variable: i#40244
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
shadow.neg failed as expected
.\Platform.Bytes.fst(257,156-260,30): (Warning) Pattern misses at least one bound variable: i#42374
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04f.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: ReifyTest (3885 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module AllocSTwHeaps AllocSTwHeaps.fst
WARNING: (6972,66): pattern does not contain any variable.
Verified module: IfcDeclassify (3661 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDelimitedReleaseReify IfcDelimitedReleaseReify.fst
Verified module: Ex04e (533 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04g.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
open.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include private.neg --odir private.neg Test.fst > private.neg/error.log 2>&1
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: MergeSort (2562 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module QuickSort.List QuickSort.List.fst
Verified module: Ex04e (900 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.List.Tot.Base (7395 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04f.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Reader.fst
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: CPS.SimpleDefun (840 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Eval.DB Eval.DB.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Ex04f (376 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04h.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: StlcCbvDbParSubst (11651 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
WARNING: (67353,66): pattern does not contain any variable.
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StackMachine StackMachine.fst
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
private.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include trans.neg --odir trans.neg Test.fst > trans.neg/error.log 2>&1
Verified module: SHA1 (819 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Sig.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: CPS.SimpleLambdaLifting (187 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module mcCarthy91 mcCarthy91.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\Ex04g.fst(5,4-5,6): Warning: Admitting tl without a definition
.\Ex04g.fst(4,4-4,6): Warning: Admitting hd without a definition
Verified module: Ex04g (28 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05a.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
Verified module: AllocSTwHeaps (1582 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Preorder Preorder.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex04h (26 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05b.fst
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
trans.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include noshadow.neg --odir noshadow.neg Test.fst > noshadow.neg/error.log 2>&1
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
Verified module: FStar.UInt63 (14473 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Bytes.fst
.\Ex05a.fst(28,4-28,13): Warning: Admitting rev_is_ok without a definition
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex04f (1397 milliseconds)
All verification conditions discharged successfully
Verified module: Preorder (30 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04g.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --record_hints --verify_module MRefHeap MRefHeap.fst
Verified module: FStar.Reader (940 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Classical.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: McCarthy91 (448 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module termination termination.fst
Verified module: Ex05a (743 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06a.fst
Verified module: FStar.DM4F.ExnSt (4878 milliseconds)
All verification conditions discharged successfully
Verified module: BinarySearchTreeBasic (11088 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.StExn.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTreeFirst BinarySearchTreeFirst.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
noshadow.neg failed as expected
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/incl'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06b.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Eval.DB (3472 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module QuickSort.Seq QuickSort.Seq.fst
Verified module: Unit1.Basic (22288 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Projectors2 Unit1.Projectors2.fst
Verified module: Ex05b (514 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include array.pos --odir array.pos Test.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
.\Ex06a.fst(5,4-5,13): Warning: Admitting partition without a definition
Verified module: Ex06a (31 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExample IfcExample.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
.\MAC.fst(45,0-45,35): (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Ex04g (241 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04h.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Classical (3226 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Constructive.fst
Verified module: MAC (2125 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Cert.ACLs.fst
is_smt_pat called with (decreases t)
is_smt_pat called with (decreases t)
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
Verified module: MRefHeap (4561 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SnapshotST SnapshotST.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AVar r)) (env r))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
WARNING: (4215,6): pattern does not contain all quantified variables.
Verified module: Ex04h (333 milliseconds)
All verification conditions discharged successfully
Verified module: QuickSort.List (8929 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05a.fst
Verified module: IfcDelimitedRelease (8404 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module GC GC.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify0 IfcExampleReify0.fst
Verified module: Termination (3670 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/termination'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify1 IfcExampleReify1.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: BinarySearchTreeFirst (2940 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module RBTree RBTree.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(Seq.length s_tail, Seq.length s))))
is_smt_pat called with ((ensures (~((Seq.mem double_quote contents)))))
is_smt_pat called with ((ensures (<(Seq.length s', Seq.length s))))
is_smt_pat called with ((ensures (<(Seq.length tail, Seq.length parsee))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(gparse_object j gparse l data0 l' (Seq.append (gprint_object j gprint l data l') tail), (Some ((Prims.Mktuple2 data tail)))))))
is_smt_pat called with ((ensures (==(gparse_object j gparse l data0 l' (Seq.append (gprint_object j gprint l data l') tail), (Some ((Prims.Mktuple2 data tail)))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
Verified module: IfcExample (2315 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Cap.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.DM4F.StExn (5593 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.ST.fst
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with (decreases l2)
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.Constructive (2260 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: Cert.ACLs (688 milliseconds)
All verification conditions discharged successfully
Verified module: SnapshotST (3037 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Formatting.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ReifyTestTSST ReifyTestTSST.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex06b (7112 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06e.fst
Verified module: Ex05a (1360 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05b.fst
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Sig (1685 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 RPC.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
.\Ex06e.fst(18,4-18,8): Warning: Admitting sort without a definition
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.DM4F.ST (2239 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex06e (407 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07a.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: ReifyTestTSST (1328 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MRefST MRefST.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex05b (1948 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06a.fst
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: QuickSort.Seq (3089 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unification Unification.fst
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Test (26892 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include point.pos --odir point.pos Test.fst
Verified module: FStar.Bytes (548 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (/\(_ (typing empty v), ==(typing g (subst x v e), typing (extend g x (_ (typing empty v))) e)))))
is_smt_pat called with ((ensures (/\(_ (step e), ==(typing empty (_ (step e)), typing empty e)))))
.\Ex07a.fst(228,4-228,14): Warning: Admitting typed_step without a definition
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DependentMap.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.Integers (32987 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.FunctionalExtensionality.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.Map (5753 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.MarkovsPrinciple.fst
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: GC (10471 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Huffman Huffman.fst
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex06a (199 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06b.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: IfcDelimitedReleaseReify (14647 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify2 IfcExampleReify2.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==((ifc_c_r (_ h) x), (ifc_c_r (_ h) x)))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r (_ h) x) x, sel (ifc_c_r (_ h) x) x))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r (_ h) x) x, sel (ifc_c_r (_ h) x) x))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r h x) x, 0))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Platform.Bytes.fst(15,40-18,29): (Warning) Pattern misses at least one bound variable: uu___#79854
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
.\Platform.Bytes.fst(257,156-260,30): (Warning) Pattern misses at least one bound variable: i#89301
Verified module: FStar.FunctionalExtensionality (229 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Platform.Bytes (52340 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bytes'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify3 IfcExampleReify3.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Cap (453 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 CntFormat.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Test (19405 milliseconds)
All verification conditions discharged successfully
Verified module: Unit1.Projectors2 (28 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.WPsAndTriples Unit1.WPsAndTriples.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06c.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: IfcExampleReify0 (2074 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(s0, s1))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 CntProtocol.fst
Verified module: FStar.MarkovsPrinciple (25 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Array.fst
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
Verified module: FStar.DM4F.Heap (6412 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.ST.fst
Verified module: FStar.DependentMap (3481 milliseconds)
All verification conditions discharged successfully
Verified module: RBTree (14202 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --explicit_deps ArrayRealized.fst Vector.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.SquashEffect.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: IfcExampleReify1 (5223 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (OrdSet.subset (vars (subst_term s t')) (OrdSet.remove (fst s) (OrdSet.union (vars (snd s)) (vars t'))))))
is_smt_pat called with ((ensures (OrdSet.subset (evars (lsubst_eqns (Prims.Cons (Prims.Mktuple2 x t) (Prims.Nil )) e)) (OrdSet.remove x (evars ((Prims.Cons ((Prims.Mktuple2 (V x) t)) e)))))))
is_smt_pat called with ((ensures (=(lsubst_term (extend_lsubst l l') e, lsubst_term l (lsubst_term l' e)))))
is_smt_pat called with ((ensures (=(subst_term ((Prims.Mktuple2 x z)) y, y))))
is_smt_pat called with ((ensures (=(lsubst_term (Prims.Cons s (Prims.Nil )) (lsubst_term l (subst_term s e)), lsubst_term (Prims.Cons s (Prims.Nil )) (lsubst_term l e)))))
is_smt_pat called with ((ensures (=(lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns l (lsubst_eqns (Prims.Cons s (Prims.Nil )) e)), lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns l e)))))
is_smt_pat called with ((ensures (solved (lsubst_eqns l'' ((Prims.Cons ((Prims.Mktuple2 (V x) y)) tl))))))
is_smt_pat called with ((ensures (=(subst_term s (subst_term s t), subst_term s t))))
is_smt_pat called with ((ensures (=(lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns (Prims.Cons s (Prims.Nil )) e), lsubst_eqns (Prims.Cons s (Prims.Nil )) e))))
is_smt_pat called with ((ensures (not_solveable ((Prims.Mktuple2 (V x) t)))))
is_smt_pat called with ((ensures (=(lsubst_term l (subst_term ((Prims.Mktuple2 x t)) t'), lsubst_term l t'))))
is_smt_pat called with ((ensures (=(lsubst_eqns l (lsubst_eqns (Prims.Cons (Prims.Mktuple2 x t) (Prims.Nil )) e), lsubst_eqns l e))))
is_smt_pat called with ((ensures (not_solveable_eqns ((Prims.Cons ((Prims.Mktuple2 (V x) t)) tl)))))
is_smt_pat called with ((ensures (if _ (unify_eqns e) then not_solveable_eqns e else solved (lsubst_eqns (_ (unify_eqns e)) e))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRecursiveHeapReify IfcRecursiveHeapReify.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\RPC.fst(9,0-9,53): (Warning) Top-level let-bindings must be total; this term may have effects
.\RPC.fst(23,0-23,39): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Formatting (3492 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.Plain.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
Verified module: Unit1.WPsAndTriples (351 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Parser Unit1.Parser.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\RPC.fst(48,0-49,16): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\RPC.fst(116,0-116,17): (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: RPC (1726 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.MAC.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(decode t (@(bs, bs')), (match decode t bs' with (Some ss)  -> (Some ((Prims.Cons s ss))) | None  -> None)))))
is_smt_pat called with ((ensures (==>(>(List.Tot.length sws, 1), (let  t = huffman sws in (match encode t ss with (Some e)  -> (match decode t e with (Some d)  -> =(d, ss) | None  -> False) | None  -> True))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/data_structures'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.RefinementInference Unit1.RefinementInference.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex07a (11383 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.SquashEffect (378 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07b.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.BitVector.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: MRefST (9630 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/preorders'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07c.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex06b (5917 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.WPsAndTriples_ST Unit1.WPsAndTriples_ST.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Unit1.Parser (1399 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Projectors1 Unit1.Projectors1.fst
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Unit1.RefinementInference (117 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.UnificationTests Unit1.UnificationTests.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.List (4583 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.PropositionalExtensionality.fst
is_smt_pat called with ((ensures (let  h' = p1_r x y hi h in /\(/\((=(sel h' y, sel h y)), (=(sel h' x, +(sel h x, sel h y)))), (=(sel h' hi, sel h hi))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r x y hi (_ h)) (p1_r x y hi (_ h)))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Ex06c (9167 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06d.fst
Verified module: Unit1.WPsAndTriples_ST (308 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.RecursiveTypeFunctions Unit1.RecursiveTypeFunctions.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: Unit1.UnificationTests (27 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit2 Unit2.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: IfcExampleReify3 (2719 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRecursiveReify IfcRecursiveReify.fst
Verified module: FStar.PropositionalExtensionality (30 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Set.fst
Verified module: CntFormat (3546 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.CPA.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\CntProtocol.fst(14,0-14,53): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.DM4F.Heap.ST (7039 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.StExnC.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
.\CntProtocol.fst(29,0-29,26): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
.\CntProtocol.fst(32,0-32,54): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x (append l m), (+(count x l, count x m))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(mem x (append l m), (||(mem x l, mem x m))))))
is_smt_pat called with ((ensures ((/\(/\(/\(/\(=(+(length (fst (partition f l)), length (snd (partition f l))), length l), (forall x.{:pattern } ==>(mem x (fst (partition f l)), f x))), (forall x.{:pattern } ==>(mem x (snd (partition f l)), not (f x)))), (forall x.{:pattern } =(mem x l, (||(mem x (fst (partition f l)), mem x (snd (partition f l))))))), (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l)))))))))))
is_smt_pat called with ((ensures (sorted f (append l1 ((Prims.Cons pivot l2))))))
.\CntProtocol.fst(35,0-35,54): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Test (7627 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06e.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(length l_1, length l_2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\CntProtocol.fst(99,0-99,39): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: Test (7062 milliseconds)
All verification conditions discharged successfully
Verified module: Unit2 (1733 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.AE.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.Properties.fst
.\CntProtocol.fst(126,0-126,18): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
Verified module: Huffman (14068 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestSet TestSet.fst
Verified module: FStar.Array (4959 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IFC.fst
is_smt_pat called with ((ensures ni_com env ((Seq c_2 c_3)) Low))
Verified module: EtM.Plain (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.RSA.fst
Verified module: Unit1.RecursiveTypeFunctions (2337 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestHeap TestHeap.fst
.\CntProtocol.fst(158,0-174,5): (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: CntProtocol (5715 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.PlainPKE.fst
Verified module: FStar.Set (3183 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt32.fst
Verified module: Ex06d (5312 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07a.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Ex06e (1104 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07b.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Unification (20076 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/algorithms'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07c.fst
Verified module: TestSet (389 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ShortCircuit ShortCircuit.fst
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
Verified module: Ex07c (13281 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07d.fst
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: EtM.MAC (3085 milliseconds)
All verification conditions discharged successfully
Verified module: IfcRecursiveHeapReify (8177 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.Plain.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcReificationRegressionTest IfcReificationRegressionTest.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(_ (typing empty v), ==(typing g (subst x v e), typing (extend g x (_ (typing empty v))) e)))))
is_smt_pat called with ((ensures (/\(_ (step e), ==(typing empty (_ (step e)), typing empty e)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.DM4F.StExnC (6214 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Continuations.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: IfcExampleReify2 (5461 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRules IfcRules.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
.\Ex07d.fst(225,4-225,8): Warning: Admitting eval without a definition
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: TestHeap (1237 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module FirstProofs FirstProofs.fst
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
Verified module: FStar.BitVector (10877 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex07b (17231 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Squash.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10a.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: ShortCircuit (1630 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestMRef TestMRef.fst
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r lo hi n (_ h)) (p1_r lo hi n (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p2_r lo hi n (_ h)) (p2_r lo hi n (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p3_r lo1 lo2 hi n (_ h)) (p3_r lo1 lo2 hi n (_ h)))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Unit1.Projectors1 (2240 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestTwoLevelHeap TestTwoLevelHeap.fst
Verified module: FStar.DM4F.IFC (7100 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints delimcc.fst
Verified module: IfcRecursiveReify (2896 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRulesReify IfcRulesReify.fst
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AVar r)) (env r))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FirstProofs (1374 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Mac Mac.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified i'face (or impl+i'face): FStar.Squash (39 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Heap.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: IfcReificationRegressionTest (1572 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcTypechecker IfcTypechecker.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
.\TestMRef.fst(8,0-8,20): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
Verified module: TestMRef (1056 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.DM4F.Continuations (4492 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestGhost TestGhost.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStore.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: LambdaOmega (73000 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreFixedReader.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: DelimCC (1388 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreFixed.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
Verified module: EtM.CPA (3090 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.AE.fst
Verified module: TestTwoLevelHeap (504 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Normalization Normalization.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex07a (11589 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07d.fst
.\Ex10a.fst(27,0-27,19): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.Heap (892 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdSet.fst
Verified module: Ex10a (1544 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10b.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: TestGhost (559 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Positivity Positivity.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: IfcRules (7724 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Loops Loops.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: HyE.Plain (27 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.CCA2.fst
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex07c (16219 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10a.fst
Verified module: Ex10b (1639 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12a.Cap.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: EtM.AE (5103 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.HCCA2.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.List.Tot.Properties (19898 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
Verified module: Positivity (1130 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex07d (17614 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints NegativeTests.BST.fst NegativeTests.Heap.fst NegativeTests.ShortCircuiting.fst NegativeTests.Bug260.fst NegativeTests.Neg.fst NegativeTests.Termination.fst NegativeTests.False.fst NegativeTests.Set.fst NegativeTests.ImplicitFalse.fst NegativeTests.Positivity.fst 2>&1 | tee fstar_log
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Crypto.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12d.Pad.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures _ (fst (reify (read r) store))))
is_smt_pat called with ((ensures _ (fst (reify (write r x) store))))
is_smt_pat called with ((ensures (/\(in_ r store, ==(normalize_term (fst (reify (let  () = write_tot r x in read_tot r) store)), (Some x))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Normalization (2399 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12e.Pad.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
Verified module: HyE.RSA (485 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
Verified module: HyE.PlainPKE (266 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.DM4F.IntStoreFixedReader (1668 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_location_info --lax \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
RPC.fst \
--codegen-lib Platform --codegen-lib CoreCrypto --codegen-lib Seq --codegen OCaml
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10b.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreExcFixed.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Test (17721 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/struct'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.TSet.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Mac.fst(70,0-70,35): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: FStar.DM4F.IntStore (4917 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.Random.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.DM4F.IntStoreFixed (3302 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Random.fst
Verified module: MAC (2106 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.UInt32 (13925 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12a.Cap.fst
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (f x)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.IndefiniteDescription.fst
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
.\Ex10a.fst(27,0-27,19): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex07b (26407 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12b.RPC.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: Ex10a (2903 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12d.Pad.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: IfcTypechecker (2278 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Memo Memo.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.TSet (1907 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.ErasedLogic.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: Ex10b (3534 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12e.Pad.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
.\Ex12a.Cap.fst(21,0-21,26): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex12a.Cap (333 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12f.TMAC.fst
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: FStar.IndefiniteDescription (1723 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int64.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: HyE.AE (3605 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_location_info --lax \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
CntProtocol.fst \
--codegen-lib Platform --codegen-lib CoreCrypto --codegen-lib Seq --codegen OCaml
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
Verified module: Loops (8703 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module NetKat NetKat.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
.\NegativeTests.False.fst(13,18-13,35): (Error) Expected type "(l_or l_True l_True)"; but "(Left T)" has type "(c_or (?37015 uu___) l_True)"
.\NegativeTests.False.fst(13,36-13,54): (Error) Expected type "(l_or l_True l_True)"; but "(Right T)" has type "(c_or l_True (?37028 uu___))"
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Extracted module StrongExcludedMiddle
Extracted module Classical
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex07d (18733 milliseconds)
All verification conditions discharged successfully
Extracted module Base
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
Verified module: FStar.ErasedLogic (46 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12f.TMAC.fst
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.SquashProperties.fst
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
Extracted module Properties
Extracted module Tot
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Extracted module Base
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
Extracted module Properties
Extracted module Seq
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
Extracted module Bytes
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Extracted module TSet
Extracted module Heap
Extracted module ST
Extracted module CoreCrypto
Extracted module All
Extracted module Formatting
Extracted module SHA1
Extracted module MAC
is_smt_pat called with ((ensures (==(x1, x2))))
Extracted module RPC
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.Base.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex12d.Pad (956 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12g.TMAC2.fst
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
.\NegativeTests.ImplicitFalse.fst(4,26-4,27): (Error) Failed to resolve implicit argument of type 'l_False' introduced in (?37540 uu___) because user-provided implicit term
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.Crypto (1389 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.HyperHeap.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (match List.assoc x l with (Some y)  -> p ((Prims.Mktuple2 x y)) | _  -> True)))
is_smt_pat called with ((ensures (p ((Prims.Mktuple2 x y)))))
is_smt_pat called with ((ensures (valid_memo ((Prims.Cons ((Prims.Mktuple2 x y)) h)) f)))
is_smt_pat called with ((ensures (/\(valid_memo h0 f, (let  h1 = memo_heap_to_valid_memo (valid_memo_to_memo_heap f h0) in ==(h0, h1))))))
is_smt_pat called with ((ensures (let  (y, h1) = reify (memo_extr f x) h0 in /\(valid_memo h1 f, ==(y, f x)))))
is_smt_pat called with ((ensures (==>(p x, (let  (y, h1) = reify (memo_extr_p p f x) h0 in /\(==(y, g x), valid_memo h1 g))))))
is_smt_pat called with ((ensures (computes (memo_extr_p p f) g)))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(p x, (let  (y, h1) = reify (memo_extr_p p f x) h0 in /\(==(y, g x), valid_memo h1 g))))))
is_smt_pat called with ((ensures (==(y, fixp f x))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==(fixp f x, g x))))
is_smt_pat called with ((ensures (res (cont1 (fixfib x1)))))
is_smt_pat called with ((ensures (res (cont2 (fixfib x2)))))
is_smt_pat called with ((ensures (computes f g1)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
Verified module: FStar.DM4F.Heap.Random (1572 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.fst
is_smt_pat called with ((ensures (==(x1, x2))))
.\Ex12a.Cap.fst(19,0-19,26): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex12a.Cap (422 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12g.TMAC2.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: FStar.OrdSet (20258 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(l1, l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.MRef.fst
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.SquashProperties (2499 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int32.fst
Verified module: Ex12e.Pad (1376 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ulib/hyperheap Ex11a.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
.\Ex12b.RPC.fst(8,0-8,53): (Warning) Top-level let-bindings must be total; this term may have effects
.\Ex12b.RPC.fst(21,0-21,39): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.DM4F.IntStoreExcFixed (3621 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module OneTimePad OneTimePad.fst
is_smt_pat called with ((ensures (==(x1, x2))))
.\Ex12b.RPC.fst(53,0-54,16): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
.\Ex12b.RPC.fst(123,0-123,17): (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Ex12b.RPC (1590 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ulib/hyperheap Ex11a.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Extracted module StrongExcludedMiddle
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
Extracted module Classical
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
Extracted module Base
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
Verified module: HyE.CCA2 (2737 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
Extracted module Properties
Extracted module Tot
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Point Point.fst
Verified module: FStar.DM4F.Random (6251 milliseconds)
All verification conditions discharged successfully
Extracted module Base
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/dm4free'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ProgramEquivalence ProgramEquivalence.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Extracted module Properties
Extracted module Seq
Extracted module Bytes
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Extracted module TSet
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
Extracted module Heap
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
Extracted module ST
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
Extracted module All
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Extracted module CntFormat
is_smt_pat called with ((ensures (bijection f)))
is_smt_pat called with ((ensures (let  ((enc_0, dec_0), _) = reify (one_time_pad ()) ((Prims.Mktuple2 0 tape_0)) in let  ((enc_1, dec_1), _) = reify (one_time_pad ()) ((Prims.Mktuple2 0 tape_1)) in /\(/\(=(dec_0 (enc_0 x_0), x_0), =(dec_1 (enc_1 x_1), x_1)), =(enc_0 x_0, enc_1 x_1)))))
Verified module: NetKat (3284 milliseconds)
All verification conditions discharged successfully
Extracted module CoreCrypto
Extracted module SHA1
Extracted module MAC
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ProgramOptimizations ProgramOptimizations.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Extracted module Set
Extracted module CntProtocol
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
Verified module: FStar.MRef (634 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
mkdir -p out
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module RandomTapes RandomTapes.fst
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.PredicateExtensionality.fst
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.List.Tot (21 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdMap.fst
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: HyE.HCCA2 (2059 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/crypto'
make -C ../../../..//ulib/ml
make[4]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
make -C .. mgen
make[5]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
make[5]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
is_smt_pat called with ((ensures (==(p1, p2))))
mkdir -p ml/extracted
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --lax --codegen OCaml --odir ml/extracted FStar.Set.fst FStar.TSet.fst FStar.Map.fst FStar.HyperHeap.fst FStar.HyperStack.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall b.{:pattern } let  (Cons hd tl) = bs in ==>(mem b tl, disjoint (_ b) (_ hd)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
.\NegativeTests.Positivity.fst(6,5-7,26): (Error) Inductive type NegativeTests.Positivity.t1 does not satisfy the positivity condition
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (bijection f)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
.\NegativeTests.Positivity.fst(20,5-21,26): (Error) Inductive type NegativeTests.Positivity.t5 does not satisfy the positivity condition
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
Verified module: FStar.PredicateExtensionality (126 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Recursive Recursive.fst
.\NegativeTests.Positivity.fst(30,5-31,24): (Error) Inductive type NegativeTests.Positivity.t7 does not satisfy the positivity condition
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
Verified module: Ex12d.Pad (1343 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ReifyLong ReifyLong.fst
.\NegativeTests.Positivity.fst(34,5-35,24): (Error) Inductive type NegativeTests.Positivity.t8 does not satisfy the positivity condition
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
.\NegativeTests.Positivity.fst(41,5-42,23): (Error) Inductive type NegativeTests.Positivity.t10 does not satisfy the positivity condition
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
.\NegativeTests.Positivity.fst(45,5-46,30): (Error) Inductive type NegativeTests.Positivity.t11 does not satisfy the positivity condition
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: RandomTapes (962 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
.\Ex12f.TMAC.fst(26,4-26,10): Warning: Admitting verify without a definition
.\Ex12f.TMAC.fst(25,4-25,7): Warning: Admitting mac without a definition
.\Ex12f.TMAC.fst(24,4-24,10): Warning: Admitting keygen without a definition
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Rel Rel.fst
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex12f.TMAC (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module StRel StRel.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall b.{:pattern } let  (Cons hd tl) = bs in ==>(mem b tl, disjoint (_ b) (_ hd)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: Ex12e.Pad (2592 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Swap Swap.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: Ex12f.TMAC (461 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind.Forest UnionFind.Forest.fst
is_smt_pat called with ((ensures (>=(fac n, fac m))))
is_smt_pat called with ((ensures (>=(fac_sum n m, fac_sum n' m'))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\Ex12g.TMAC2.fst(30,4-30,10): Warning: Admitting verify without a definition
.\Ex12g.TMAC2.fst(29,4-29,7): Warning: Admitting mac without a definition
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: Recursive (680 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind UnionFind.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Extracted module Classical
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Heap
Extracted module Set
Extracted module Base
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Extracted module Properties
Extracted module Tot
Extracted module Map
Extracted module HyperHeap
Verified module: Ex12g.TMAC2 (753 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==>((=(dom #k #v #f m, OrdSet.empty)), (==(m, empty #k #v #f))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int.Cast.fst
Extracted module HyperStack
All verification conditions discharged successfully
make[5]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib'
make prims.o FStar_Mul.o FStar_Float.o FStar_Char.o FStar_Int8.o FStar_UInt8.o FStar_Int16.o FStar_UInt16.o FStar_Int32.o FStar_UInt32.o FStar_Int64.o FStar_UInt64.o FStar_UInt128.o FStar_Int_Cast.o FStar_BaseTypes.o FStar_IO.o FStar_Heap.o FStar_List_Tot_Base.o FStar_List.o FStar_Option.o FStar_String.o FStar_Set.o FStar_Buffer.o FStar_CommonST.o FStar_ST.o FStar_All.o
make[5]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
make[5]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg prims.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Mul.ml
is_smt_pat called with ((ensures (==(x1, x2))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Float.ml
Verified module: StRel (648 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind.Functions UnionFind.Functions.fst
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Char.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int8.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt8.ml
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Rel (1844 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int16.ml
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module While While.fst
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt16.ml
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Ex12g.TMAC2 (1132 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int32.ml
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module WhileReify WhileReify.fst
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt32.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int64.ml
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt64.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt128.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int_Cast.ml
is_smt_pat called with ((ensures (==(p1, p2))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_BaseTypes.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_IO.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Heap.ml
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com11) h_left in let  (_, h_right') = reify (com_denotation com12) h_right in rel_exp_denotation rel12 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com21) h_left in let  (_, h_right') = reify (com_denotation com22) h_right in rel_exp_denotation rel22 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com31) h_left in let  (_, h_right') = reify (com_denotation com32) h_right in rel_exp_denotation rel32 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com41) h_left in let  (_, h_right') = reify (com_denotation com42) h_right in rel_exp_denotation rel4 h_left' h_right')))
is_smt_pat called with ((ensures (rhl ((If CTrue c c')) d phi phi')))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_List_Tot_Base.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_List.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Option.ml
Verified module: IfcRulesReify (32790 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_String.ml
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module OTP OTP.fst
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Set.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Buffer.ml
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_CommonST.ml
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_ST.ml
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_All.ml
Verified module: Point (3702 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ElGamal ElGamal.fst
make[5]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
ocamlopt -a prims.cmx FStar_Mul.cmx FStar_Float.cmx FStar_Char.cmx FStar_Int8.cmx FStar_UInt8.cmx FStar_Int16.cmx FStar_UInt16.cmx FStar_Int32.cmx FStar_UInt32.cmx FStar_Int64.cmx FStar_UInt64.cmx FStar_UInt128.cmx FStar_Int_Cast.cmx FStar_BaseTypes.cmx FStar_IO.cmx FStar_Heap.cmx FStar_List_Tot_Base.cmx FStar_List.cmx FStar_Option.cmx FStar_String.cmx FStar_Set.cmx FStar_Buffer.cmx FStar_CommonST.cmx FStar_ST.cmx FStar_All.cmx -o fstarlib.cmxa
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
make[4]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_extract FStar.All --no_extract FStar.BaseTypes --no_extract FStar.Char --no_extract FStar.Float --no_extract FStar.Heap --no_extract FStar.Int8 --no_extract FStar.Int16 --no_extract FStar.Int32 --no_extract FStar.Int64 --no_extract FStar.UInt8 --no_extract FStar.UInt16 --no_extract FStar.UInt32 --no_extract FStar.UInt64 --no_extract FStar.Int_Cast --no_extract FStar.IO --no_extract FStar.List --no_extract FStar.List.Tot.Base --no_extract FStar.Option --no_extract FStar.Set --no_extract FStar.ST --no_extract FStar.String --no_extract FStar.HyperHeap --no_extract FStar.HyperStack --no_extract FStar.HST --no_extract FStar.Buffer --no_extract FStar.Mul --odir out --codegen OCaml Ex01a.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (equiv (>>(f1, f2)) (>>(f2, f1)))))
is_smt_pat called with ((ensures (equiv (>>(f, f)) f)))
is_smt_pat called with ((ensures (/\(equiv (cond c c1 c2) c1, equiv (cond c c1 c2) c2))))
is_smt_pat called with ((ensures (equiv (>>(c1, c2)) c2)))
is_smt_pat called with ((ensures (let  ((), h_1) = reify (f1 ()) h_0 in let  ((), h'_1) = reify (f2 ()) h_1 in let  ((), h_2) = reify (f2 ()) h_0 in let  ((), h'_2) = reify (f1 ()) h_2 in heap_eq h_0 h'_1 h'_2)))
is_smt_pat called with ((ensures (let  (_, h1) = reify (f ()) h0 in let  (_, h2) = reify (f ()) h1 in heap_eq h0 h1 h2)))
Verified module: FStar.Int64 (13002 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.All.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: ProgramEquivalence (6043 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt128.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Seq.Base (18844 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Math.Lib.fst
Verified module: Ex11a (14145 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/exercises'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt16.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\Ex01a.fst(58,0-58,48): (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: While (4815 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.WellFounded.fst
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Ex01a
Verified module: Ex01a (876 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -package batteries,stdint,zarith -linkpkg -g ../../../..//ulib/ml/fstarlib.cmxa -I ../../../..//ulib/ml out/Ex01a.ml -o Ex01a.exe 2>&1
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
File "out/Ex01a.ml", line 23, characters 8-10:
Warning 26: unused variable v1.
File "out/Ex01a.ml", line 23, characters 29-31:
Warning 26: unused variable v2.
File "out/Ex01a.ml", line 39, characters 8-10:
Warning 26: unused variable v1.
File "out/Ex01a.ml", line 40, characters 8-10:
Warning 26: unused variable v2.
File "out/Ex01a.ml", line 41, characters 8-10:
Warning 26: unused variable v3.
Verified module: OneTimePad (18497 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int8.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.All (81 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.Properties.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
Verified module: Memo (26629 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
./Ex01a.exe 2>&1
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Relational.Relational.fst
Dummy read of file demo/tempfile
Dummy read of file demo/README
Dummy write of string hello! to file demo/tempfile
Dummy read of file demo/tempfile
Dummy read of file demo/README
Fatal error: exception Ex01a.InvalidRead
Raised at file "prims.ml", line 103, characters 20-21
Called from file "out/Ex01a.ml", line 41, characters 13-31
Called from file "out/Ex01a.ml", line 43, characters 42-60
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
make[3]: [Makefile:66: Ex01a-ocaml] Error 2 (ignored)
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdMapProps.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
Verified module: Ex11a (14470 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/solutions'
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt8.fst
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.WellFounded (567 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Fin.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Swap (6690 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Axiomatic.Array.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.Int32 (12306 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Universe.fst
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\NegativeTests.BST.fst(21,38-21,42): (Error) Subtyping check failed; expected type (right#61:(option (tree 2)){(l_and (l_and (l_and (b2t (op_LessThanOrEqual 0 1)) (b2t (op_LessThanOrEqual 1 2))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality 1 2)))) (l_iff (b2t (uu___is_None (None ))) (b2t (op_Equality 1 0))))}); got type (option (tree 2)) (see .\NegativeTests.BST.fst(13,36-13,57))
.\NegativeTests.BST.fst(22,61-22,65): (Error) Subtyping check failed; expected type (right#61:(option (tree (op_Addition l 1))){(l_and (l_and (l_and (b2t (op_LessThanOrEqual l l)) (b2t (op_LessThanOrEqual l (op_Addition l 1)))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality l (op_Addition l 1))))) (l_iff (b2t (uu___is_None (Some t))) (b2t (op_Equality l l))))}); got type (option (tree (op_Addition l 1))) (see .\NegativeTests.BST.fst(13,36-13,57))
.\NegativeTests.BST.fst(23,78-23,87): (Error) Subtyping check failed; expected type (right#61:(option (tree (op_Addition l 1))){(l_and (l_and (l_and (b2t (op_LessThanOrEqual l (op_Addition l 1))) (b2t (op_LessThanOrEqual (op_Addition l 1) (op_Addition l 1)))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality (op_Addition l 1) (op_Addition l 1))))) (l_iff (b2t (uu___is_None (Some t1))) (b2t (op_Equality (op_Addition l 1) l))))}); got type (option (tree (op_Addition l 1))) (see .\NegativeTests.BST.fst(12,36-12,58))
.\NegativeTests.Bug260.fst(9,12-9,19): (Error) Subtyping check failed; expected type (validity (S (S t))); got type (validity (S t)) (see .\NegativeTests.Bug260.fst(8,37-9,9))
.\NegativeTests.False.fst(3,31-3,42): (Error) assertion failed
.\NegativeTests.Heap.fst(10,0-10,54): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Heap.fst(11,0-15,14): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.ImplicitFalse.fst(4,0-4,33): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(175,22-175,33))
.\NegativeTests.Neg.fst(6,8-6,10): (Error) Subtyping check failed; expected type nat; got type int (see C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Neg.fst(8,8-8,10): (Error) Subtyping check failed; expected type nat; got type int (see C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Neg.fst(10,0-10,35): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Neg.fst(12,28-13,15): (Error) Patterns are incomplete
.\NegativeTests.Neg.fst(19,32-19,42): (Error) assertion failed (see .\NegativeTests.Neg.fst(15,44-15,57))
.\NegativeTests.Neg.fst(21,83-21,88): (Error) could not prove post-condition
.\NegativeTests.Neg.fst(25,30-25,31): (Error) Subtyping check failed; expected type (uu___#8234:(option 'a){(b2t (uu___is_Some uu___@0))}); got type (option 'a) (see C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(252,4-252,8))
.\NegativeTests.Neg.fst(28,41-28,43): (Error) Subtyping check failed; expected type (uu___#9393:(result int){(b2t (uu___is_V uu___@0))}); got type (result int) (see C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(259,4-259,5))
.\NegativeTests.Neg.fst(32,25-32,26): (Error) Subtyping check failed; expected type nat; got type int (see C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Set.fst(11,0-12,30): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Set.fst(15,0-16,67): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Set.fst(19,0-20,52): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.ShortCircuiting.fst(5,16-5,33): (Error) Subtyping check failed; expected type (b#22:bool{(bad_p b@0)}); got type bool (see .\NegativeTests.ShortCircuiting.fst(4,31-4,38))
.\NegativeTests.ShortCircuiting.fst(8,0-8,36): (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(175,22-175,33))
.\NegativeTests.Termination.fst(7,27-7,28): (Error) Subtyping check failed; expected type (z#130:int{(precedes (LexCons m (LexCons z@0 LexTop)) m)}); got type int (see .\NegativeTests.Termination.fst(5,0-7,29))
.\NegativeTests.Termination.fst(13,26-13,35): (Error) Subtyping check failed; expected type (uu___#616:int{(precedes (LexCons n (LexCons uu___@0 LexTop)) (LexCons n (LexCons count LexTop)))}); got type int (see .\NegativeTests.Termination.fst(10,0-13,35))
.\NegativeTests.Termination.fst(20,29-20,54): (Error) Subtyping check failed; expected type (n#1073:int{(precedes (LexCons (op_Subtraction m 1) (LexCons n@0 LexTop)) (LexCons m (LexCons n LexTop)))}); got type int (see .\NegativeTests.Termination.fst(17,0-20,54))
.\NegativeTests.Termination.fst(25,28-25,29): (Error) Subtyping check failed; expected type (uu___#1993:(list 'a){(precedes uu___@0 l)}); got type (list 'a) (see .\NegativeTests.Termination.fst(23,0-25,29))
.\NegativeTests.Termination.fst(37,15-37,29): (Error) Subtyping check failed; expected type (x:(x#2581:nat{(b2t (op_LessThanOrEqual x@0 v))}) -> Tot nat); got type (uu___:(uu___#3405:nat{(precedes uu___@0 v)}) -> Tot nat) (see .\NegativeTests.Termination.fst(34,0-37,29))
.\NegativeTests.Termination.fst(48,19-48,29): (Error) Subtyping check failed; expected type (uu___#4199:snat{(precedes uu___@0 n)}); got type snat (see .\NegativeTests.Termination.fst(44,0-48,29))
.\NegativeTests.Termination.fst(55,34-55,35): (Error) Subtyping check failed; expected type (uu___#4752:snat{(precedes (LexCons (S (S n')) (LexCons uu___@0 LexTop)) (LexCons n (LexCons m LexTop)))}); got type snat (see .\NegativeTests.Termination.fst(51,0-55,35))
.\NegativeTests.Termination.fst(59,2-61,14): (Error) Patterns are incomplete
.\NegativeTests.Termination.fst(67,29-67,31): (Error) Subtyping check failed; expected type (uu___#5798:NegativeTests.Termination.snat{(Prims.precedes<?43218, ?43219> (Prims.LexCons<?43223, (max ?43231, ?43239)> (NegativeTests.Termination.S n'#6308) (Prims.LexCons<?43231, ?43239> uu___@0 Prims.LexTop<?43239>)) (Prims.LexCons<?43245, (max ?43253, ?43261)> n#5785 (Prims.LexCons<?43253, ?43261> m#5786 Prims.LexTop<?43261>)))}); got type (?43509 n#5785 m#5786) (see .\NegativeTests.Termination.fst(64,0-67,31))
.\NegativeTests.Termination.fst(73,20-73,26): (Error) Subtyping check failed; expected type (uu___#6885:NegativeTests.Termination.snat{(Prims.precedes<?43617, ?43618> uu___@0 n#6881)}); got type NegativeTests.Termination.snat (see .\NegativeTests.Termination.fst(70,0-73,26))
Verified module: NegativeTests.BST (5813 milliseconds)
Verified module: NegativeTests.Bug260 (1892 milliseconds)
Verified module: NegativeTests.False (2052 milliseconds)
Verified module: NegativeTests.Heap (3119 milliseconds)
Verified module: NegativeTests.ImplicitFalse (1181 milliseconds)
Verified module: NegativeTests.Neg (9265 milliseconds)
Verified module: NegativeTests.Positivity (1927 milliseconds)
Verified module: NegativeTests.Set (3405 milliseconds)
Verified module: NegativeTests.ShortCircuiting (2820 milliseconds)
Verified module: NegativeTests.Termination (13577 milliseconds)
41 errors were reported (see above)
Verified module: FStar.HyperHeap (22472 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int128.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Success: 41 failures were expected
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/micro-benchmarks'
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Math.Lemmas.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.OrdMap (15479 milliseconds)
All verification conditions discharged successfully
Verified module: ElGamal (2134 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int63.fst
is_smt_pat called with ((ensures (let  (r_1, _) = reify (find uf i_1 h) h in let  (r_2, _) = reify (find uf i_2 h) h in let  (_, d_1, s_1) = sel h (index uf r_1) in let  (_, d_2, s_2) = sel h (index uf r_2) in let  (_, h1) = reify (merge uf i_1 i_2) h in ==>(<>(r_1, r_2), (/\(/\(==(sel h1 (index uf r_1), ((Prims.Mktuple3 r_2 d_1 s_1))), (==(sel h1 (index uf r_2), ((Prims.Mktuple3 r_2 d_2 elift2 union s_1 s_2))))), (forall j:id n.{:pattern } ==>((/\(<>(j, r_1), <>(j, r_2))), ==(sel h (index uf j), sel h1 (index uf j))))))))))
is_smt_pat called with ((ensures (let  (r_1, _) = reify (find uf i_1 h) h in let  (r_2, _) = reify (find uf i_2 h) h in let  (_, d_1, s_1) = sel h (index uf r_1) in let  (_, d_2, s_2) = sel h (index uf r_2) in let  (_, h1) = reify (merge_opt uf i_1 i_2) h in ==>((/\(<>(r_1, r_2), >=(d_1, d_2))), (/\(/\(==(sel h1 (index uf r_2), ((Prims.Mktuple3 r_1 d_2 s_2))), (let  d_1 = if =(d_1, d_2) then +(d_1, 1) else d_1 in ==(sel h1 (index uf r_1), ((Prims.Mktuple3 r_1 d_1 elift2 union s_1 s_2))))), (forall j:id n.{:pattern } ==>((/\(<>(j, r_1), <>(j, r_2))), ==(sel h (index uf j), sel h1 (index uf j))))))))))
is_smt_pat called with ((ensures (let  (_, h'_1) = reify (merge uf i_1 i_2) h_1 in let  (_, h'_2) = reify (merge uf i_1 i_2) h_2 in (forall j:id n.{:pattern } /\(/\(/\(=(parent uf j h'_1, parent uf j h'_2), ==(subtree uf j h'_1, subtree uf j h'_2)), =(height uf j h'_1, height uf j h_1)), =(height uf j h'_2, height uf j h_2))))))
is_smt_pat called with ((ensures (let  (_, h1) = reify (merge uf i_1 i_2) h in let  (_, h2) = reify (merge_opt uf i_1 i_2) h in <==>((=(fst (reify (find uf j_1 h1) h1), fst (reify (find uf j_2 h1) h1))), (=(fst (reify (find uf j_1 h2) h2), fst (reify (find uf j_2 h2) h2)))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Relational.Comp.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: ProgramOptimizations (13687 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.fst
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: UnionFind.Forest (2318 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Mul.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Axiomatic.Array (510 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt64.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: FStar.Math.Lib (5814 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified i'face (or impl+i'face): FStar.Universe (21 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Ghost.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.Relational.Relational (2593 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.HyperStack.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==>((=(dom #k #v #f m, OrdSet.empty)), (==(m, empty #k #v #f))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: OTP (2289 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int16.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Mul (27 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdSetProps.fst
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
Verified module: FStar.OrdMapProps (400 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Util.fst
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Relational.Comp (391 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.StrongExcludedMiddle.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Ghost (1047 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.IO.fsti
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: WhileReify (6000 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.String.fsti
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
Verified module: FStar.StrongExcludedMiddle (110 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Squash.fsti
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified i'face (or impl+i'face): FStar.IO (124 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Option.fsti
Verified i'face (or impl+i'face): FStar.String (314 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Matrix2.fsti
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: FStar.Seq (19 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Universe.fsti
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.Fin (5528 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(union s1 s2, union' s1 s2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Float.fsti
Verified module: FStar.Util (46 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.BaseTypes.fsti
Verified i'face (or impl+i'face): FStar.Squash (28 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Char.fsti
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.OrdSetProps (1075 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperHeap.fst hyperheap/FStar.ST.fst FStar.Util.fst
Verified i'face (or impl+i'face): FStar.Option (21 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperStack.fst hyperstack/FStar.ST.fst hyperstack/FStar.All.fst FStar.Monotonic.RRef.fst FStar.Monotonic.Seq.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified i'face (or impl+i'face): FStar.Universe (19 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperStack.fst hyperstack/FStar.ST.fst FStar.Buffer.fst FStar.Buffer.Quantifiers.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified i'face (or impl+i'face): FStar.Float (25 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints hyperstack/FStar.ST.fst hyperstack/FStar.All.fst FStar.Struct.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
Verified i'face (or impl+i'face): FStar.Char (304 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.UInt128 (12779 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Int8 (10909 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.UInt16 (12247 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
Verified i'face (or impl+i'face): FStar.Matrix2 (2704 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.UInt8 (11855 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.Int63 (10064 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.HyperStack (15508 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.Int128 (10515 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.UInt64 (11710 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.Int16 (9836 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified i'face (or impl+i'face): FStar.BaseTypes (19 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Int.Cast (25573 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Math.Lemmas (32209 milliseconds)
All verification conditions discharged successfully
Verified module: UnionFind (35776 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.Seq.Properties (34692 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
Verified module: FStar.Map (5030 milliseconds)
Verified module: FStar.HyperHeap (15874 milliseconds)
Verified module: FStar.ST (1013 milliseconds)
Verified module: FStar.Util (28 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: ReifyLong (57692 milliseconds)
All verification conditions discharged successfully
unknown(0,0-0,0): (Warning) FStar.Struct: Unexpected output from Z3: (error "line 138346 column 43: unknown constant @x26")

is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
Verified module: UnionFind.Functions (61214 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/rel'
Verified module: FStar.Map (4678 milliseconds)
Verified module: FStar.HyperStack (13009 milliseconds)
Verified module: FStar.ST (9982 milliseconds)
Verified module: FStar.All (47 milliseconds)
Verified module: FStar.Monotonic.RRef (1239 milliseconds)
Verified module: FStar.Monotonic.Seq (14282 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.UInt (78585 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.ST (11443 milliseconds)
Verified module: FStar.All (45 milliseconds)
Verified module: FStar.Struct (51939 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(/\(/\(/\(live h0 b, live h0 b'), live h1 b'), (forall i:nat.{:pattern (get h1 b' (+(v bi', i)))} ==>(<(i, v len), ==(get h1 b' (+(v bi', i)), get h0 b (+(v bi, i)))))), (forall i:nat.{:pattern (get h1 b' i)} ==>((\/((/\(>=(i, +(v bi', v len)), <(i, length b'))), <(i, v bi'))), ==(get h1 b' i, get h0 b' i)))))))
Verified module: FStar.Map (4681 milliseconds)
Verified module: FStar.HyperStack (15244 milliseconds)
Verified module: FStar.ST (11568 milliseconds)
Verified module: FStar.Buffer (162082 milliseconds)
Verified module: FStar.Buffer.Quantifiers (5902 milliseconds)
All verification conditions discharged successfully
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib'
Verified module: StackMachine (389997 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/metatheory'
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples'
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
