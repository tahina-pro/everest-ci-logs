This is /home/everbld/everest-ci/ci
Working directory: /cygdrive/c/Build/Agent/_work/1/s
About to run: make -C src utest -j 24 -k
BUILD_SOURCEBRANCHNAME: cpitclaudel_refactored_errors
BUILD_DEFINITIONNAME: FStar-CI-Windows
make: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make all
make[1]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make[1]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
VS/.nuget/NuGet.exe restore VS/FStar.sln
Installing 'FsLexYacc 6.1.0'.
Installing 'FsLexYacc.Runtime 6.1.0'.
Successfully installed 'FsLexYacc.Runtime 6.1.0'.
Successfully installed 'FsLexYacc 6.1.0'.
make -C VS install-packages
make[2]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src/VS'
[ -d packages ] || make update-nuget
.nuget/NuGet.exe restore FStar.sln
All packages listed in packages.config are already installed.
find packages -name '*.exe' -exec chmod +x '{}' ';'
make[2]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src/VS'
"C:/Program Files (x86)/MSBuild/14.0/bin/amd64/"/MSBuild.exe /verbosity:minimal /p:Configuration=Release VS/FStar.sln
Microsoft (R) Build Engine version 14.0.25420.1
Copyright (C) Microsoft Corporation. All rights reserved.

basic -> C:\Build\Agent\_work\1\s\bin\basic.dll
Restoring NuGet packages...
To prevent NuGet from downloading packages during build, open the Visual Studio Options dialog, click on the Package Manager node and uncheck 'Allow NuGet to download missing packages'.
All packages listed in packages.config are already installed.
prettyprint -> C:\Build\Agent\_work\1\s\bin\prettyprint.dll
syntax -> C:\Build\Agent\_work\1\s\bin\syntax.dll
compiling to dfas (can take a while...)
339 states
writing output
building tables
computing first function...time: 00:00:00.2002818
building kernels...time: 00:00:00.1380337
building kernel table...time: 00:00:00.0179267
computing lookahead relations..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................time: 00:00:00.4739814
building lookahead table...time: 00:00:00.2559754
building action table...state 406: shift/reduce error on SEMICOLON
state 412: shift/reduce error on BY
state 434: shift/reduce error on BAR
state 437: shift/reduce error on LBRACE
state 438: shift/reduce error on BAR
state 449: shift/reduce error on BAR
state 525: shift/reduce error on COLON_EQUALS
state 561: shift/reduce error on LBRACE
time: 00:00:00.7707985
building goto table...time: 00:00:00.2331565
returning tables.
8 shift/reduce conflicts
715 states
137 nonterminals
138 terminals
386 productions
#rows in action table: 715
parser -> C:\Build\Agent\_work\1\s\bin\parser.dll
typechecker -> C:\Build\Agent\_work\1\s\bin\typechecker.dll
format -> C:\Build\Agent\_work\1\s\bin\format.dll
extraction -> C:\Build\Agent\_work\1\s\bin\extraction.dll
fsdoc -> C:\Build\Agent\_work\1\s\bin\fsdoc.dll
smtencoding -> C:\Build\Agent\_work\1\s\bin\smtencoding.dll
tactics -> C:\Build\Agent\_work\1\s\src\tactics\bin\Release\tactics.dll
tosyntax -> C:\Build\Agent\_work\1\s\bin\tosyntax.dll
fstar -> C:\Build\Agent\_work\1\s\bin\fstar.exe
C:\Build\Agent\_work\1\s\src\tests\tactics.fs(53,19): warning FS0040: This and other recursive references to the object(s) being defined will be checked for initialization-soundness at runtime through the use of a delayed reference. This is because you are defining one or more recursive objects, rather than recursive functions. This warning may be suppressed by using '#nowarn "40"' or '--nowarn:40'. [C:\Build\Agent\_work\1\s\src\tests\tests.fsproj]
tests -> C:\Build\Agent\_work\1\s\bin\tests.exe
chmod a+x ../bin/tests.exe
chmod a+x ../bin/fstar.exe
make[1]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make fsharp-regressions #normalizer failures on linux so only run on windows
make[1]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
make[1]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
../bin/tests.exe
Initializing ...
Goal is (l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0))))))))
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> intros
intros: x
TAC (ngoals=1, maingoal=(l_imp (eq2 x 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0)))))), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 x 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0)))))), rest=):
TAC>> imp_intro
imp_intro: uu___#170758
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0))))), rest=):
TAC>> rewrite
+++Rewrite uu___#170758 : (eq2 x 0)
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> split
TAC (ngoals=2, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))):
TAC>> debug
TAC (ngoals=2, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))):
TAC>> map
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> intros
intros: y
TAC (ngoals=1, maingoal=(l_imp (eq2 y 0) (eq2 0 y)), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 y 0) (eq2 0 y)), rest=):
TAC>> imp_intro
imp_intro: uu___#170762
TAC (ngoals=1, maingoal=(eq2 0 y), rest=):
TAC>> rewrite
+++Rewrite uu___#170762 : (eq2 y 0)
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying simplify_eq_impl
(eq2 0 0) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying trivial
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting y#170761
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is x |- l_True
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> map
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> intros
intros: z
TAC (ngoals=1, maingoal=(l_imp (eq2 z 0) (eq2 0 z)), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 z 0) (eq2 0 z)), rest=):
TAC>> imp_intro
imp_intro: uu___#170766
TAC (ngoals=1, maingoal=(eq2 0 z), rest=):
TAC>> rewrite
+++Rewrite uu___#170766 : (eq2 z 0)
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying simplify_eq_impl
(eq2 0 0) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying trivial
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting z#170765
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is x |- l_True
TAC (ngoals=2, maingoal=l_True, rest=l_True):
TAC>> merge_sub_goals
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting x#170757
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is  |- l_True
Goal: l_True
make[1]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make -C ocaml-output
make[1]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src/ocaml-output'
cp "../extraction/ml/FStar_Extraction_ML_PrintML_4.02.3.ml" ../extraction/ml/FStar_Extraction_ML_PrintML.ml
# TODO : call menhir directly when positions are fixed instead of
# letting OCamlbuild go through ocamlyacc
menhir  --only-preprocess-for-ocamlyacc ../parser/parse.mly > parse.mly
Warning: you are using the standard library and/or the %inline keyword. We
recommend switching on --infer in order to avoid obscure type error messages.
warning: CRLF will be replaced by LF in src/parser/parse.fsi.
The file will have its original line endings in your working directory.
# Save a copy of the dumb parse.mly for whoever doesn't have menhir.
echo 'let dummy () = ();;' > FStar_Version.ml
cp parse.mly ../parser/ml/
echo 'FStar_Options._version := "0.9.4.2";;' >> FStar_Version.ml
echo "%{" > ../parser/parse.fsy
# We are opening the same module twice but we need these modules
echo 'FStar_Options._platform := "Windows_x64";;' >> FStar_Version.ml
echo "#light \"off\"" >> ../parser/parse.fsy
# open for the definition of tokens
echo 'FStar_Options._compiler := "OCaml 4.02.3";;' >> FStar_Version.ml
echo "// (c) Microsoft Corporation. All rights reserved" >> ../parser/parse.fsy
echo "open Prims" > FStar_Parser_Parse.ml
echo 'FStar_Options._date := "2017-04-10T07:14:02-07:00";;' >> FStar_Version.ml
echo "open Prims" >> ../parser/parse.fsy
echo "open FStar_Errors" >> FStar_Parser_Parse.ml
echo 'FStar_Options._commit:= "6737d0a (dirty)";;' >> FStar_Version.ml
echo "open FStar.Errors" >> ../parser/parse.fsy
echo "open FStar_List" >> FStar_Parser_Parse.ml
echo "open FStar.List" >> ../parser/parse.fsy
echo "open FStar_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Util" >> ../parser/parse.fsy
echo "open FStar_Range" >> FStar_Parser_Parse.ml
echo "open FStar.Range" >> ../parser/parse.fsy
echo "open FStar_Options" >> FStar_Parser_Parse.ml
echo "open FStar.Options" >> ../parser/parse.fsy
echo "open FStar_Syntax_Syntax" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Syntax" >> ../parser/parse.fsy
echo "open FStar_Syntax_Const" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Const" >> ../parser/parse.fsy
echo "open FStar_Syntax_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Util" >> ../parser/parse.fsy
echo "open FStar_Parser_AST" >> FStar_Parser_Parse.ml
echo "open FStar.Parser.AST" >> ../parser/parse.fsy
echo "open FStar_Parser_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Parser.Util" >> ../parser/parse.fsy
echo "open FStar_Const" >> FStar_Parser_Parse.ml
echo "open FStar.Const" >> ../parser/parse.fsy
echo "open FStar_Ident" >> FStar_Parser_Parse.ml
echo "open FStar.Ident" >> ../parser/parse.fsy
echo "open FStar_String" >> FStar_Parser_Parse.ml
echo "open FStar.String" >> ../parser/parse.fsy
# TODO: create a proper OCamlbuild rule for this production so that
# TODO : fsyacc seems to complain as soon as there is an arrow -> in a %type declaration...
# OCamlbuild knows how to generate parse.mly first (possibly using
cat parse.mly | sed -e '/%{/d' \
-e '/^open /d' \
-e '/%token/s/[a-zA-Z0-9_]*\.//g' \
-e '/%type/s/[a-zA-Z0-9_]*\.//g' \
-e '/%token.*->.*/d' \
-e '/%type.*->.*/d' \
>> ../parser/parse.fsy
# menhir) and removes the production as needed.
ocamlyacc parse.mly
7 shift/reduce conflicts.
cat parse.ml >> FStar_Parser_Parse.ml
rm parse.ml parse.mli
cd ../../ && ocamlbuild -cflag '-g' -I src/ocaml-output -I src/basic/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -j 24 -build-dir src/ocaml-output/_build -I src/prettyprint/ml -I src/ocaml-output/bootlibs -use-ocamlfind main.native
mkdir 'C:\Build\Agent\_work\1\s\src/ocaml-output/_build'
mkdir src
mkdir src/fstar
mkdir src/fstar/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/fstar/ml/main.ml > src/fstar/ml/main.ml.depends
mkdir src/ocaml-output
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Main.ml > src/ocaml-output/FStar_Main.ml.depends
mkdir src/ocaml-output/bootlibs
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_All.ml > src/ocaml-output/bootlibs/FStar_All.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Common.ml > src/ocaml-output/FStar_Common.ml.depends
mkdir src/basic
mkdir src/basic/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Util.ml > src/basic/ml/FStar_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_List.ml > src/ocaml-output/bootlibs/FStar_List.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/prims.ml > src/ocaml-output/bootlibs/prims.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/MkPrims.ml > src/ocaml-output/bootlibs/MkPrims.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/MkPrims.cmo src/ocaml-output/bootlibs/MkPrims.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_List.cmo src/ocaml-output/bootlibs/FStar_List.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/prims.cmo src/ocaml-output/bootlibs/prims.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Util.cmo src/basic/ml/FStar_Util.ml
File "src/basic/ml/FStar_Util.ml", line 47, characters 57-65:
Warning 40: st_mtime was selected from type BatUnix.stats.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/basic/ml/FStar_Util.ml", line 659, characters 2-13:
Warning 10: this expression should have type unit.
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Dependencies.ml > src/ocaml-output/FStar_Dependencies.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_All.cmo src/ocaml-output/bootlibs/FStar_All.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Options.ml > src/ocaml-output/FStar_Options.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_BaseTypes.ml > src/ocaml-output/bootlibs/FStar_BaseTypes.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Char.ml > src/ocaml-output/bootlibs/FStar_Char.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Float.ml > src/ocaml-output/bootlibs/FStar_Float.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int16.ml > src/ocaml-output/bootlibs/FStar_Int16.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int32.ml > src/ocaml-output/bootlibs/FStar_Int32.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int64.ml > src/ocaml-output/bootlibs/FStar_Int64.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int8.ml > src/ocaml-output/bootlibs/FStar_Int8.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_UInt16.ml > src/ocaml-output/bootlibs/FStar_UInt16.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_UInt8.ml > src/ocaml-output/bootlibs/FStar_UInt8.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Char.cmo src/ocaml-output/bootlibs/FStar_Char.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Float.cmo src/ocaml-output/bootlibs/FStar_Float.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int16.cmo src/ocaml-output/bootlibs/FStar_Int16.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int32.cmo src/ocaml-output/bootlibs/FStar_Int32.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int64.cmo src/ocaml-output/bootlibs/FStar_Int64.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int8.cmo src/ocaml-output/bootlibs/FStar_Int8.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt16.cmo src/ocaml-output/bootlibs/FStar_UInt16.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt8.cmo src/ocaml-output/bootlibs/FStar_UInt8.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Getopt.ml > src/basic/ml/FStar_Getopt.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Platform.ml > src/basic/ml/FStar_Platform.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_ST.ml > src/ocaml-output/bootlibs/FStar_ST.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_String.ml > src/ocaml-output/bootlibs/FStar_String.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_BaseTypes.cmo src/ocaml-output/bootlibs/FStar_BaseTypes.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Getopt.cmo src/basic/ml/FStar_Getopt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Platform.cmo src/basic/ml/FStar_Platform.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_ST.cmo src/ocaml-output/bootlibs/FStar_ST.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_String.cmo src/ocaml-output/bootlibs/FStar_String.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Dep.ml > src/ocaml-output/FStar_Parser_Dep.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmo src/ocaml-output/FStar_Common.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Const.ml > src/ocaml-output/FStar_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Ident.ml > src/ocaml-output/FStar_Ident.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Range.ml > src/basic/ml/FStar_Range.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Range.cmo src/basic/ml/FStar_Range.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmo src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Errors.ml > src/ocaml-output/FStar_Errors.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmo src/ocaml-output/FStar_Options.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_AST.ml > src/ocaml-output/FStar_Parser_AST.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmo src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmo src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Const.ml > src/ocaml-output/FStar_Syntax_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Syntax.ml > src/ocaml-output/FStar_Syntax_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Unionfind.ml > src/basic/ml/FStar_Unionfind.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Unionfind.cmo src/basic/ml/FStar_Unionfind.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmo src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Print.ml > src/ocaml-output/FStar_Syntax_Print.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmo src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Subst.ml > src/ocaml-output/FStar_Syntax_Subst.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Option.ml > src/ocaml-output/bootlibs/FStar_Option.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Option.cmo src/ocaml-output/bootlibs/FStar_Option.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Util.ml > src/ocaml-output/FStar_Syntax_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_InstFV.ml > src/ocaml-output/FStar_Syntax_InstFV.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmo src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmo src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmo src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmo src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Driver.ml > src/ocaml-output/FStar_Parser_Driver.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmo src/ocaml-output/FStar_Parser_AST.ml
mkdir src/parser
mkdir src/parser/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_ParseIt.ml > src/parser/ml/FStar_Parser_ParseIt.ml.depends
''ocamllex.opt -q src/parser/ml/FStar_Parser_LexFStar.mll
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_LexFStar.ml > src/parser/ml/FStar_Parser_LexFStar.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Parse.ml > src/ocaml-output/FStar_Parser_Parse.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_Util.ml > src/parser/ml/FStar_Parser_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_Util.cmo src/parser/ml/FStar_Parser_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmo src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmo src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmo src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmo src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmo src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_Kremlin.ml > src/ocaml-output/FStar_Extraction_Kremlin.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Code.ml > src/ocaml-output/FStar_Extraction_ML_Code.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Bytes.ml > src/basic/ml/FStar_Bytes.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Syntax.ml > src/ocaml-output/FStar_Extraction_ML_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Util.ml > src/ocaml-output/FStar_Extraction_ML_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmo src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_UEnv.ml > src/ocaml-output/FStar_Extraction_ML_UEnv.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Env.ml > src/ocaml-output/FStar_TypeChecker_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Free.ml > src/ocaml-output/FStar_Syntax_Free.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Common.ml > src/ocaml-output/FStar_TypeChecker_Common.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmo src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmo src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmo src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmo src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Format.ml > src/ocaml-output/FStar_Format.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Bytes.cmo src/basic/ml/FStar_Bytes.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmo src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmo src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmo src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Modul.ml > src/ocaml-output/FStar_Extraction_ML_Modul.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Term.ml > src/ocaml-output/FStar_Extraction_ML_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Normalize.ml > src/ocaml-output/FStar_TypeChecker_Normalize.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcTerm.ml > src/ocaml-output/FStar_TypeChecker_TcTerm.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Err.ml > src/ocaml-output/FStar_TypeChecker_Err.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmo src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Rel.ml > src/ocaml-output/FStar_TypeChecker_Rel.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmo src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Util.ml > src/ocaml-output/FStar_TypeChecker_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmo src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmo src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmo src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmo src/ocaml-output/FStar_Extraction_ML_Term.ml
mkdir src/extraction
mkdir src/extraction/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/extraction/ml/FStar_Extraction_ML_PrintML.ml > src/extraction/ml/FStar_Extraction_ML_PrintML.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Fsdoc_Generator.ml > src/ocaml-output/FStar_Fsdoc_Generator.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Indent.ml > src/ocaml-output/FStar_Indent.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_ToDocument.ml > src/ocaml-output/FStar_Parser_ToDocument.ml.depends
mkdir src/prettyprint
mkdir src/prettyprint/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/prettyprint/ml/FStar_Pprint.ml > src/prettyprint/ml/FStar_Pprint.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/prettyprint/ml -I src/ocaml-output -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/prettyprint/ml/FStar_Pprint.cmo src/prettyprint/ml/FStar_Pprint.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmo src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Interactive.ml > src/ocaml-output/FStar_Interactive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmo src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Solver.ml > src/ocaml-output/FStar_SMTEncoding_Solver.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Encode.ml > src/ocaml-output/FStar_SMTEncoding_Encode.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml > src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Term.ml > src/ocaml-output/FStar_SMTEncoding_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Util.ml > src/ocaml-output/FStar_SMTEncoding_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmo src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Z3.ml > src/ocaml-output/FStar_SMTEncoding_Z3.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmo src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmo src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmo src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmo src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_Env.ml > src/ocaml-output/FStar_ToSyntax_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Universal.ml > src/ocaml-output/FStar_Universal.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Interleave.ml > src/ocaml-output/FStar_Parser_Interleave.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmo src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Interpreter.ml > src/ocaml-output/FStar_Tactics_Interpreter.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Basic.ml > src/ocaml-output/FStar_Tactics_Basic.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Embedding.ml > src/ocaml-output/FStar_Tactics_Embedding.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmo src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmo src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmo src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_ToSyntax.ml > src/ocaml-output/FStar_ToSyntax_ToSyntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_MutRecTy.ml > src/ocaml-output/FStar_Syntax_MutRecTy.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmo src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Tc.ml > src/ocaml-output/FStar_TypeChecker_Tc.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_DMFF.ml > src/ocaml-output/FStar_TypeChecker_DMFF.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcInductive.ml > src/ocaml-output/FStar_TypeChecker_TcInductive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmo src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmo src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmo src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmo src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmo src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmo src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmo src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Version.ml > src/ocaml-output/FStar_Version.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmo src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmo src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmo src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmo src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmo src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmo src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmo src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmo src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmo src/fstar/ml/main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/MkPrims.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/FStar_List.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/prims.cmx src/ocaml-output/bootlibs/prims.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Util.ml
File "src/basic/ml/FStar_Util.ml", line 47, characters 57-65:
Warning 40: st_mtime was selected from type BatUnix.stats.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/basic/ml/FStar_Util.ml", line 659, characters 2-13:
Warning 10: this expression should have type unit.
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_All.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Char.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Float.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int16.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int32.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int64.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_Int8.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt16.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_UInt8.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Getopt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Platform.cmx src/basic/ml/FStar_Platform.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_ST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/bootlibs/FStar_String.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Range.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Options.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Unionfind.cmx src/basic/ml/FStar_Unionfind.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/bootlibs/FStar_Option.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmx src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_Util.cmx src/parser/ml/FStar_Parser_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmx src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmx src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Bytes.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmx src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/prettyprint/ml -I src/ocaml-output -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/prettyprint/ml/FStar_Pprint.cmx src/prettyprint/ml/FStar_Pprint.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmx src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmx src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmx src/fstar/ml/main.ml
''ocamlfind ocamlopt -linkpkg -thread -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/prims.cmx src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Platform.cmx src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Unionfind.cmx src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Extraction_ML_Code.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Parser_AST.cmx src/parser/ml/FStar_Parser_Util.cmx src/ocaml-output/FStar_Parser_Parse.cmx src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_ParseIt.cmx src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Fsdoc_Generator.cmx src/prettyprint/ml/FStar_Pprint.cmx src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Main.cmx src/fstar/ml/main.cmx -o src/fstar/ml/main.native
# Parallel statistics: { count(total): 18(200), max: 8, min: 2, average(total): 3.889(1.260) }
cp _build/src/fstar/ml/main.native ../../bin/fstar.exe
cp _build/src/fstar/ml/main.native ../../bin/fstar.ocaml
make[1]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src/ocaml-output'
make fstar-ocaml
make[1]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make ocaml
make[2]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
rm -rf boot_fstis u_boot_fsts u_ocaml-output
mkdir boot_fstis u_boot_fsts u_ocaml-output
make prep
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make[3]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
cp basic/string.fsi boot_fstis/FStar.string.fsti
cp basic/list.fsi boot_fstis/FStar.list.fst
sed -i 's/open Prims/module ALL_TEMP = FStar.All/g' boot_fstis/FStar.list.fst
sed -i 's/<.* when .* : equality>//g' boot_fstis/FStar.list.fst
sed -i 's/val/assume val/g' boot_fstis/FStar.list.fst
cp basic/util.fsi boot_fstis/FStar.util.fsti
sed -i 's/open System.IO/module ALL_TMP = FStar.All/g' boot_fstis/FStar.util.fsti
sed -i 's/type time.*/assume new type time/g'  boot_fstis/FStar.util.fsti
sed -i 's/type smap.*/assume new type smap : Type0 -> Type0/g'  boot_fstis/FStar.util.fsti
sed -i 's/type imap.*/assume new type imap : Type0 -> Type0/g'  boot_fstis/FStar.util.fsti
sed -i 's/type out_channel.*/assume new type out_channel/g'  boot_fstis/FStar.util.fsti
sed -i 's/type file_handle.*/assume new type file_handle/g'  boot_fstis/FStar.util.fsti
sed -i 's/type stream_reader.*/assume new type stream_reader/g'  boot_fstis/FStar.util.fsti
sed -i 's/type string_builder.*/assume new type string_builder/g'  boot_fstis/FStar.util.fsti
sed -i 's/type proc.*/assume new type proc/g' boot_fstis/FStar.util.fsti
sed -i 's/type set.*/assume new type set:Type0 -> Type0/g' boot_fstis/FStar.util.fsti
cp basic/platform.fsi boot_fstis/FStar.platform.fsti
cp basic/bytes.fsti boot_fstis/FStar.bytes.fst
cp basic/range.fsi boot_fstis/FStar.range.fsti
cp basic/version.fsi boot_fstis/FStar.version.fsti
cp basic/getopt.fsi boot_fstis/FStar.getopt.fsti
cp basic/unionfind.fsi boot_fstis/FStar.unionfind.fsti
sed -i 's/type pa_t.*/module ALL_TMP = FStar.All/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/and data.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| PArray.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| PDiff.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type puf_t.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type puf.*/assume new type puf : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type p_uvar.*/assume new type p_uvar : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type cell.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/and contents.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| Data.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| Fwd.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type uvar.*/assume new type uvar : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
cp prettyprint/prettyprint.fsi boot_fstis/FStar.Pprint.fsti
echo "#light \"off\"" > boot_fstis/FStar.Parser.Parse.fsti
head -n -12 parser/parse.fsi >> boot_fstis/FStar.Parser.Parse.fsti
sed -i 's/module FStar.Parser.Parse/module FStar.Parser.Parse\nopen FStar.All\nopen FStar.BaseTypes\ntype bytes = array<byte>\nopen FStar.Syntax.Syntax/' boot_fstis/FStar.Parser.Parse.fsti
make rename_as_fst
make[4]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
./tools/rename_all_boot_fsts
[rename_all_boot_fsts]: copying ./basic/FStar.Common.fs to u_boot_fsts/FStar.Common.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Const.fs to u_boot_fsts/FStar.Const.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Errors.fs to u_boot_fsts/FStar.Errors.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Ident.fs to u_boot_fsts/FStar.Ident.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Options.fs to u_boot_fsts/FStar.Options.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Options.fsi to u_boot_fsts/FStar.Options.fsti
./boot_fstis/FStar.bytes.fst is unrecognized
./boot_fstis/FStar.getopt.fsti is unrecognized
./boot_fstis/FStar.list.fst is unrecognized
./boot_fstis/FStar.Parser.Parse.fsti is unrecognized
./boot_fstis/FStar.platform.fsti is unrecognized
./boot_fstis/FStar.Pprint.fsti is unrecognized
./boot_fstis/FStar.range.fsti is unrecognized
./boot_fstis/FStar.string.fsti is unrecognized
./boot_fstis/FStar.unionfind.fsti is unrecognized
./boot_fstis/FStar.util.fsti is unrecognized
./boot_fstis/FStar.version.fsti is unrecognized
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.Kremlin.fs to u_boot_fsts/FStar.Extraction.Kremlin.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Code.fs to u_boot_fsts/FStar.Extraction.ML.Code.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Code.fsi to u_boot_fsts/FStar.Extraction.ML.Code.fsti
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Modul.fs to u_boot_fsts/FStar.Extraction.ML.Modul.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.PrintML.fs to u_boot_fsts/FStar.Extraction.ML.PrintML.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.PrintML.fsi to u_boot_fsts/FStar.Extraction.ML.PrintML.fsti
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Syntax.fs to u_boot_fsts/FStar.Extraction.ML.Syntax.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Term.fs to u_boot_fsts/FStar.Extraction.ML.Term.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.UEnv.fs to u_boot_fsts/FStar.Extraction.ML.UEnv.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Util.fs to u_boot_fsts/FStar.Extraction.ML.Util.fst
[rename_all_boot_fsts]: copying ./format/FStar.Format.fs to u_boot_fsts/FStar.Format.fst
[rename_all_boot_fsts]: copying ./fsdoc/FStar.Fsdoc.Generator.fs to u_boot_fsts/FStar.Fsdoc.Generator.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Dependencies.fs to u_boot_fsts/FStar.Dependencies.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Indent.fs to u_boot_fsts/FStar.Indent.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Interactive.fs to u_boot_fsts/FStar.Interactive.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Main.fs to u_boot_fsts/FStar.Main.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Top.fs to u_boot_fsts/FStar.Top.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Universal.fs to u_boot_fsts/FStar.Universal.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.AST.fs to u_boot_fsts/FStar.Parser.AST.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Dep.fs to u_boot_fsts/FStar.Parser.Dep.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Dep.fsi to u_boot_fsts/FStar.Parser.Dep.fsti
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Driver.fs to u_boot_fsts/FStar.Parser.Driver.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Interleave.fs to u_boot_fsts/FStar.Parser.Interleave.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Lexhelp.fs to u_boot_fsts/FStar.Parser.Lexhelp.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.ToDocument.fs to u_boot_fsts/FStar.Parser.ToDocument.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.ToDocument.fsi to u_boot_fsts/FStar.Parser.ToDocument.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Encode.fs to u_boot_fsts/FStar.SMTEncoding.Encode.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Encode.fsi to u_boot_fsts/FStar.SMTEncoding.Encode.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.ErrorReporting.fs to u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.ErrorReporting.fsi to u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Solver.fs to u_boot_fsts/FStar.SMTEncoding.Solver.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Solver.fsi to u_boot_fsts/FStar.SMTEncoding.Solver.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.SplitQueryCases.fs to u_boot_fsts/FStar.SMTEncoding.SplitQueryCases.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Term.fs to u_boot_fsts/FStar.SMTEncoding.Term.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Term.fsi to u_boot_fsts/FStar.SMTEncoding.Term.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Util.fs to u_boot_fsts/FStar.SMTEncoding.Util.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Z3.fs to u_boot_fsts/FStar.SMTEncoding.Z3.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Const.fs to u_boot_fsts/FStar.Syntax.Const.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Free.fs to u_boot_fsts/FStar.Syntax.Free.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Free.fsi to u_boot_fsts/FStar.Syntax.Free.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.InstFV.fs to u_boot_fsts/FStar.Syntax.InstFV.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.InstFV.fsi to u_boot_fsts/FStar.Syntax.InstFV.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.MutRecTy.fs to u_boot_fsts/FStar.Syntax.MutRecTy.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.MutRecTy.fsi to u_boot_fsts/FStar.Syntax.MutRecTy.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Print.fs to u_boot_fsts/FStar.Syntax.Print.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Print.fsi to u_boot_fsts/FStar.Syntax.Print.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Subst.fs to u_boot_fsts/FStar.Syntax.Subst.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Subst.fsi to u_boot_fsts/FStar.Syntax.Subst.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Syntax.fs to u_boot_fsts/FStar.Syntax.Syntax.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Syntax.fsi to u_boot_fsts/FStar.Syntax.Syntax.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Util.fs to u_boot_fsts/FStar.Syntax.Util.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Basic.fs to u_boot_fsts/FStar.Tactics.Basic.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Embedding.fs to u_boot_fsts/FStar.Tactics.Embedding.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Interpreter.fs to u_boot_fsts/FStar.Tactics.Interpreter.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.Env.fs to u_boot_fsts/FStar.ToSyntax.Env.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.Env.fsi to u_boot_fsts/FStar.ToSyntax.Env.fsti
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.ToSyntax.fs to u_boot_fsts/FStar.ToSyntax.ToSyntax.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.ToSyntax.fsi to u_boot_fsts/FStar.ToSyntax.ToSyntax.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Common.fs to u_boot_fsts/FStar.TypeChecker.Common.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.DMFF.fs to u_boot_fsts/FStar.TypeChecker.DMFF.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.DMFF.fsi to u_boot_fsts/FStar.TypeChecker.DMFF.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Env.fs to u_boot_fsts/FStar.TypeChecker.Env.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Env.fsi to u_boot_fsts/FStar.TypeChecker.Env.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Err.fs to u_boot_fsts/FStar.TypeChecker.Err.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Normalize.fs to u_boot_fsts/FStar.TypeChecker.Normalize.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Normalize.fsi to u_boot_fsts/FStar.TypeChecker.Normalize.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Rel.fs to u_boot_fsts/FStar.TypeChecker.Rel.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Rel.fsi to u_boot_fsts/FStar.TypeChecker.Rel.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Tc.fs to u_boot_fsts/FStar.TypeChecker.Tc.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Tc.fsi to u_boot_fsts/FStar.TypeChecker.Tc.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcInductive.fs to u_boot_fsts/FStar.TypeChecker.TcInductive.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcInductive.fsi to u_boot_fsts/FStar.TypeChecker.TcInductive.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcTerm.fs to u_boot_fsts/FStar.TypeChecker.TcTerm.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcTerm.fsi to u_boot_fsts/FStar.TypeChecker.TcTerm.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Util.fs to u_boot_fsts/FStar.TypeChecker.Util.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Util.fsi to u_boot_fsts/FStar.TypeChecker.Util.fsti
cp parser/parseit.fsi u_boot_fsts/FStar.Parser.Parseit.fsti
make[4]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
#fix up a use of polymorphic recursion in F#, which has a different syntax than F*
sed -i 's/^and unembed_tactic_0.*//g' u_boot_fsts/FStar.Tactics.Interpreter.fst
sed -i 's/^\/\/F\* version: and unembed_tactic_0/and unembed_tactic_0/g' u_boot_fsts/FStar.Tactics.Interpreter.fst
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make u_extract_all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Common.fst u_boot_fsts/FStar.Options.fst u_boot_fsts/FStar.Ident.fst u_boot_fsts/FStar.Errors.fst u_boot_fsts/FStar.Const.fst u_boot_fsts/FStar.Format.fst --extract_module FStar.Common --extract_module FStar.Options --extract_module FStar.Ident --extract_module FStar.Errors --extract_module FStar.Const --extract_module FStar.Format
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Syntax.Syntax.fst u_boot_fsts/FStar.Syntax.Const.fst u_boot_fsts/FStar.Syntax.Subst.fst u_boot_fsts/FStar.Syntax.Free.fst u_boot_fsts/FStar.Syntax.InstFV.fst u_boot_fsts/FStar.Syntax.Util.fst u_boot_fsts/FStar.Syntax.Print.fst u_boot_fsts/FStar.Syntax.MutRecTy.fst u_boot_fsts/FStar.Fsdoc.Generator.fst --extract_namespace FStar.Syntax --extract_namespace FStar.Fsdoc
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Parser.AST.fst u_boot_fsts/FStar.Parser.Interleave.fst u_boot_fsts/FStar.Parser.Lexhelp.fst u_boot_fsts/FStar.Parser.Parseit.fsti u_boot_fsts/FStar.Parser.Driver.fst u_boot_fsts/FStar.Parser.Dep.fst u_boot_fsts/FStar.Parser.ToDocument.fst --extract_namespace FStar.Parser
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Common.fst u_boot_fsts/FStar.TypeChecker.Env.fst u_boot_fsts/FStar.TypeChecker.Normalize.fst u_boot_fsts/FStar.TypeChecker.Err.fst --extract_namespace FStar.TypeChecker
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Rel.fst --extract_module FStar.TypeChecker.Rel
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Util.fst --extract_module FStar.TypeChecker.Util
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.DMFF.fst --extract_module FStar.TypeChecker.DMFF
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.TcTerm.fst --extract_module FStar.TypeChecker.TcTerm
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.TcInductive.fst --extract_module FStar.TypeChecker.TcInductive
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Tc.fst --extract_module FStar.TypeChecker.Tc
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.ToSyntax.Env.fst u_boot_fsts/FStar.ToSyntax.ToSyntax.fst --extract_namespace FStar.ToSyntax
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Term.fst u_boot_fsts/FStar.SMTEncoding.Util.fst u_boot_fsts/FStar.SMTEncoding.Z3.fst u_boot_fsts/FStar.SMTEncoding.SplitQueryCases.fst u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fst --extract_namespace FStar.SMTEncoding
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Encode.fst --extract_module FStar.SMTEncoding.Encode
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Solver.fst --extract_module FStar.SMTEncoding.Solver
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Extraction.ML.Syntax.fst u_boot_fsts/FStar.Extraction.ML.UEnv.fst u_boot_fsts/FStar.Extraction.ML.Util.fst u_boot_fsts/FStar.Extraction.ML.Code.fst u_boot_fsts/FStar.Extraction.ML.Term.fst u_boot_fsts/FStar.Extraction.ML.Modul.fst u_boot_fsts/FStar.Extraction.Kremlin.fst --extract_namespace FStar.Extraction
# cp tactics/FStar.Tactics.Basic.fs u_boot_fsts/FStar.Tactics.Basic.fst
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Dependencies.fst u_boot_fsts/FStar.Interactive.fst u_boot_fsts/FStar.Universal.fst u_boot_fsts/FStar.Indent.fst u_boot_fsts/FStar.Main.fst --extract_module FStar.Dependencies --extract_module FStar.Interactive --extract_module FStar.Universal --extract_module FStar.Indent --extract_module FStar.Main
# cp tactics/FStar.Tactics.Embedding.fs u_boot_fsts/FStar.Tactics.Embedding.fst
# cp tactics/FStar.Tactics.Interpreter.fs u_boot_fsts/FStar.Tactics.Interpreter.fst
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Tactics.Basic.fst u_boot_fsts/FStar.Tactics.Embedding.fst u_boot_fsts/FStar.Tactics.Interpreter.fst --extract_namespace FStar.Tactics
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
.\u_boot_fsts\FStar.Syntax.Syntax.fst(395,0-395,33): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(445,0-445,48): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(446,0-446,76): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(497,0-499,38): (Warning) Annotation from val declaration overrides inline type annotation
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Extracted module Common
Extracted module Ident
Extracted module Const
Extracted module Options
Extracted module Errors
Extracted module Format
All verification conditions discharged successfully
.\u_boot_fsts\FStar.TypeChecker.Util.fst(70,0-72,32): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.TypeChecker.Env.fst(280,0-284,35): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.TypeChecker.Env.fst(718,0-720,39): (Warning) Annotation from val declaration overrides inline type annotation
Extracted module Syntax
Extracted module Const
Extracted module Subst
Extracted module InstFV
Extracted module Basic
Extracted module Util
Extracted module Embedding
Extracted module Interpreter
All verification conditions discharged successfully
Extracted module Print
Extracted module Generator
Extracted module Free
Extracted module MutRecTy
All verification conditions discharged successfully
C:\Build\Agent\_work\1\s\src\boot_fstis\FStar.Pprint.fsti(33,0-33,13) (Warning): Adding an implicit 'assume new' qualifier on document
Extracted module TcInductive
All verification conditions discharged successfully
Extracted module Term
Extracted module Z3
Extracted module Util
Extracted module ErrorReporting
Extracted module SplitQueryCases
All verification conditions discharged successfully
Extracted module AST
Extracted module Util
All verification conditions discharged successfully
Extracted module Driver
Extracted module Dep
Extracted module Interleave
Extracted module Lexhelp
Extracted module Common
Extracted module ToDocument
Extracted module Env
All verification conditions discharged successfully
Extracted module Normalize
Extracted module Err
All verification conditions discharged successfully
C:\Build\Agent\_work\1\s\src\boot_fstis\FStar.Pprint.fsti(33,0-33,13) (Warning): Adding an implicit 'assume new' qualifier on document
Extracted module Syntax
Extracted module UEnv
Extracted module Util
Extracted module Solver
All verification conditions discharged successfully
Extracted module Code
Extracted module Kremlin
Extracted module Term
Extracted module DMFF
All verification conditions discharged successfully
Extracted module Modul
All verification conditions discharged successfully
Extracted module Tc
All verification conditions discharged successfully
Extracted module Dependencies
Extracted module Indent
Extracted module Universal
Extracted module Interactive
Extracted module Main
All verification conditions discharged successfully
Extracted module Env
Extracted module ToSyntax
All verification conditions discharged successfully
Extracted module TcTerm
All verification conditions discharged successfully
Extracted module Rel
All verification conditions discharged successfully
Extracted module Encode
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
cp u_ocaml-output/*.ml ocaml-output/
make[2]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make boot-ocaml
make[2]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make -C ocaml-output all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src/ocaml-output'
cp "../extraction/ml/FStar_Extraction_ML_PrintML_4.02.3.ml" ../extraction/ml/FStar_Extraction_ML_PrintML.ml
warning: CRLF will be replaced by LF in src/parser/ml/parse.mly.
The file will have its original line endings in your working directory.
warning: CRLF will be replaced by LF in src/parser/parse.fsi.
The file will have its original line endings in your working directory.
echo 'let dummy () = ();;' > FStar_Version.ml
echo 'FStar_Options._version := "0.9.4.2";;' >> FStar_Version.ml
echo 'FStar_Options._platform := "Windows_x64";;' >> FStar_Version.ml
echo 'FStar_Options._compiler := "OCaml 4.02.3";;' >> FStar_Version.ml
echo 'FStar_Options._date := "2017-04-10T07:17:28-07:00";;' >> FStar_Version.ml
echo 'FStar_Options._commit:= "6737d0a (dirty)";;' >> FStar_Version.ml
cd ../../ && ocamlbuild -cflag '-g' -I src/ocaml-output -I src/basic/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -j 24 -build-dir src/ocaml-output/_build -I src/prettyprint/ml -I src/ocaml-output/bootlibs -use-ocamlfind main.native
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Main.ml > src/ocaml-output/FStar_Main.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Common.ml > src/ocaml-output/FStar_Common.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Dependencies.ml > src/ocaml-output/FStar_Dependencies.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Options.ml > src/ocaml-output/FStar_Options.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Dep.ml > src/ocaml-output/FStar_Parser_Dep.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmo src/ocaml-output/FStar_Common.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Const.ml > src/ocaml-output/FStar_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Ident.ml > src/ocaml-output/FStar_Ident.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmo src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Errors.ml > src/ocaml-output/FStar_Errors.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmo src/ocaml-output/FStar_Options.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_AST.ml > src/ocaml-output/FStar_Parser_AST.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmo src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmo src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Const.ml > src/ocaml-output/FStar_Syntax_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Syntax.ml > src/ocaml-output/FStar_Syntax_Syntax.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmo src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Print.ml > src/ocaml-output/FStar_Syntax_Print.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmo src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Subst.ml > src/ocaml-output/FStar_Syntax_Subst.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Util.ml > src/ocaml-output/FStar_Syntax_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_InstFV.ml > src/ocaml-output/FStar_Syntax_InstFV.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmo src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmo src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmo src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmo src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Driver.ml > src/ocaml-output/FStar_Parser_Driver.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmo src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmo src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmo src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmo src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmo src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmo src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_Kremlin.ml > src/ocaml-output/FStar_Extraction_Kremlin.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Code.ml > src/ocaml-output/FStar_Extraction_ML_Code.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Syntax.ml > src/ocaml-output/FStar_Extraction_ML_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Util.ml > src/ocaml-output/FStar_Extraction_ML_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmo src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_UEnv.ml > src/ocaml-output/FStar_Extraction_ML_UEnv.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Env.ml > src/ocaml-output/FStar_TypeChecker_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Free.ml > src/ocaml-output/FStar_Syntax_Free.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Common.ml > src/ocaml-output/FStar_TypeChecker_Common.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmo src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmo src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmo src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmo src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Format.ml > src/ocaml-output/FStar_Format.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmo src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmo src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmo src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Modul.ml > src/ocaml-output/FStar_Extraction_ML_Modul.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Term.ml > src/ocaml-output/FStar_Extraction_ML_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Normalize.ml > src/ocaml-output/FStar_TypeChecker_Normalize.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcTerm.ml > src/ocaml-output/FStar_TypeChecker_TcTerm.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Err.ml > src/ocaml-output/FStar_TypeChecker_Err.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmo src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Rel.ml > src/ocaml-output/FStar_TypeChecker_Rel.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmo src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Util.ml > src/ocaml-output/FStar_TypeChecker_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmo src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmo src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmo src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmo src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Fsdoc_Generator.ml > src/ocaml-output/FStar_Fsdoc_Generator.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Indent.ml > src/ocaml-output/FStar_Indent.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_ToDocument.ml > src/ocaml-output/FStar_Parser_ToDocument.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmo src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Interactive.ml > src/ocaml-output/FStar_Interactive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmo src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Solver.ml > src/ocaml-output/FStar_SMTEncoding_Solver.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Encode.ml > src/ocaml-output/FStar_SMTEncoding_Encode.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml > src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Term.ml > src/ocaml-output/FStar_SMTEncoding_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Util.ml > src/ocaml-output/FStar_SMTEncoding_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmo src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Z3.ml > src/ocaml-output/FStar_SMTEncoding_Z3.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmo src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmo src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmo src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmo src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_Env.ml > src/ocaml-output/FStar_ToSyntax_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Universal.ml > src/ocaml-output/FStar_Universal.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Interleave.ml > src/ocaml-output/FStar_Parser_Interleave.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmo src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Interpreter.ml > src/ocaml-output/FStar_Tactics_Interpreter.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Basic.ml > src/ocaml-output/FStar_Tactics_Basic.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Embedding.ml > src/ocaml-output/FStar_Tactics_Embedding.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmo src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmo src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmo src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_ToSyntax.ml > src/ocaml-output/FStar_ToSyntax_ToSyntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_MutRecTy.ml > src/ocaml-output/FStar_Syntax_MutRecTy.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmo src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Tc.ml > src/ocaml-output/FStar_TypeChecker_Tc.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_DMFF.ml > src/ocaml-output/FStar_TypeChecker_DMFF.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcInductive.ml > src/ocaml-output/FStar_TypeChecker_TcInductive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmo src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmo src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmo src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmo src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmo src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmo src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmo src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Version.ml > src/ocaml-output/FStar_Version.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmo src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmo src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmo src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmo src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmo src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmo src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmo src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmo src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmo src/fstar/ml/main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Options.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmx src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmx src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmx src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmx src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmx src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmx src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmx src/fstar/ml/main.ml
''ocamlfind ocamlopt -linkpkg -thread -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/prims.cmx src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Platform.cmx src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Unionfind.cmx src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Extraction_ML_Code.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Parser_AST.cmx src/parser/ml/FStar_Parser_Util.cmx src/ocaml-output/FStar_Parser_Parse.cmx src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_ParseIt.cmx src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Fsdoc_Generator.cmx src/prettyprint/ml/FStar_Pprint.cmx src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Main.cmx src/fstar/ml/main.cmx -o src/fstar/ml/main.native
# Parallel statistics: { count(total): 12(226), max: 7, min: 2, average(total): 3.167(1.115) }
cp _build/src/fstar/ml/main.native ../../bin/fstar.exe
cp _build/src/fstar/ml/main.native ../../bin/fstar.ocaml
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src/ocaml-output'
make[2]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make[1]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make uregressions interactive-test
make[1]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make -C ../ulib
make -C ../examples all
make -C tests/interactive
make[2]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/src/tests/interactive'
for a in transcript-good*; do echo "Checking $a"; cat $a | ../../../bin/fstar-any.sh --in test.fst | tail -n 1 | grep done-ok || exit 1; done
make[2]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/ulib'
Checking transcript-good-1
make[2]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples'
make -C bug-reports all
make -C hello all
make -C data_structures all
make -C algorithms all
make -C crypto all
make -C termination all
make -C software_foundations all
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int.fst
make -C ../doc/tutorial/code/exercises all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/bug-reports'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/bug-reports'
make -C ../doc/tutorial/code/solutions all
make -C rel all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/data_structures'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/hello'
../../bin/fstar.exe --verify_module hello hello.fst
make -C maths all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/crypto'
make -C paradoxes all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/termination'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/algorithms'
make -C printf all
make -C metatheory all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/software_foundations'
make -C verifythis all
make -C preorders all
make -C dm4free all
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.ST.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/doc/tutorial/code/exercises'
make -C incl all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/rel'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/doc/tutorial/code/solutions'
make -C struct all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/maths'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/paradoxes'
make -C micro-benchmarks all
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinaryTrees BinaryTrees.fst
make -C bytes all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/metatheory'
make -C tactics all
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/verifythis'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 AES.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/printf'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearch BinarySearch.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Simple CPS.Simple.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/preorders'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/incl'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfBasic SfBasic.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/struct'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/dm4free'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/micro-benchmarks'
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/bytes'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Bijection Bijection.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Gcd Gcd.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/examples/tactics'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints PropositionalExtensionalityInconsistent.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex01a.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex01a.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ParSubst ParSubst.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints 2015/Problem01.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SimplePrintf SimplePrintf.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ImmutableST ImmutableST.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include open.pos --odir open.pos Test.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include point-with-nesting.pos --odir point-with-nesting.pos Test.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.MonadLaws.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Basic Unit1.Basic.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Platform.Bytes Platform.Bytes.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MetaCoq MetaCoq.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall p1:Type.{:pattern } forall p2:Type.{:pattern } <==>((<==>(p1, p2)), ==(p1, p2)))))
is_smt_pat called with ((ensures (<==>(peq #a p1 p2, ==(p1, p2)))))
is_smt_pat called with ((ensures (==(p1 0, p2 0))))
is_smt_pat called with ((ensures (bijection f)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Bijection (273 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Equivalence Equivalence.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: PropositionalExtensionalityInconsistent (1266 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --__no_positivity propImpredicativeAndNonStrictlyPositiveinductives.fst
is_smt_pat called with ((ensures (=(t1, t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures False))
Verified module: FStar.DM4F.MonadLaws (1448 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints Effects.Def.fst
is_smt_pat called with ((ensures (==(p1, p2))))
#done-ok
Checking transcript-good-2
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Test (32 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include private.pos --odir private.pos Test.fst
.\Ex01a.fst(58,0-58,48) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Ex01a (988 milliseconds)
All verification conditions discharged successfully
.\hello.fst(5,0-5,37) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex02a.fst
Verified module: Hello (36 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.ST (131 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/hello'
is_smt_pat called with ((ensures (q x)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcCbvDbPntSubstNoLists StlcCbvDbPntSubstNoLists.fst
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcComposeReify IfcComposeReify.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
Verified module: CPS.Simple (179 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
.\Ex01a.fst(68,0-68,48) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex01a (728 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Double CPS.Double.fst
Verified module: ImmutableST (1966 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex02a.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module AllocST AllocST.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Test (26 milliseconds)
All verification conditions discharged successfully
Verified module: ParSubst (3474 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include shadow.pos --odir shadow.pos Test.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcStrongDbParSubst StlcStrongDbParSubst.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
#done-ok
Checking transcript-good-3
Verified module: Gcd (807 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/maths'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include trans.pos --odir trans.pos Test.fst
is_smt_pat called with ((ensures (==(reify (if e () then e1 () else e2 ()) h0, reify (e1 ()) h0))))
is_smt_pat called with ((ensures (==(reify (if e () then e1 () else e2 ()) h0, reify (e1 ()) h0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: MetaCoq (4396 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/tactics'
Verified module: Ex02a (334 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcCbvDbParSubst StlcCbvDbParSubst.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03a.fst
Verified module: SimplePrintf (4379 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/printf'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Encrypt_SymEnc.fst
is_smt_pat called with ((ensures /\(/\((forall a:Type f:m a.{:pattern } ==(bind a a f (return a), f)), (forall a:Type b:Type x:a f:Unidentified product: [a] (Tot (m b)).{:pattern } ==(bind a b (return a x) f, f x))), (forall a:Type b:Type c:Type f:m a g:(Unidentified product: [a] (Tot (m b))) h:(Unidentified product: [b] (Tot (m c))).{:pattern } ==(bind a c f ((fun x -> bind b c (g x) h)), bind b c (bind a b f g) h)))))
is_smt_pat called with ((ensures /\((forall a:Type x:a.{:pattern } ==(lift a (return_m a x), return_n a x)), (forall a:Type b:Type f:m a g:Unidentified product: [a] (Tot (m b)).{:pattern } ==(lift b (bind_m a b f g), bind_n a b (lift a f) ((fun x -> lift b (g x))))))))
is_smt_pat called with ((ensures (==(x0, x0'))))
is_smt_pat called with ((ensures (==(p, p'))))
is_smt_pat called with ((ensures (~((p0 x0)))))
is_smt_pat called with ((ensures (p0 x0)))
Verified module: Equivalence (854 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntST.fst
Verified module: FStar.Int (6548 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.TwoLevelHeap.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
Verified module: Ex02a (245 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03a.fst
unknown(0,0-0,0) :  : (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
unknown(0,0-0,0) :  : (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
#done-ok
for a in transcript-bad*; do echo "Checking $a"; cat $a | ../../../bin/fstar-any.sh --in test.fst | tail -n 1 | grep done-nok || exit 1; done
Checking transcript-bad-1
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
Verified module: PropImpredicativeAndNonStrictlyPositiveInductives (1543 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with (decreases (Seq.length s))
Verified module: Problem01 (1823 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: SfBasic (8244 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/paradoxes'
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTree BinarySearchTree.fst
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/verifythis'
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03b.fst
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfLists SfLists.fst
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (let  p = splitTwo s i in =(^(fst p, snd p), s))))
is_smt_pat called with ((ensures =(substringT s i2 n2, substringT (substringT s i n) (-(i2, i)) n2)))
is_smt_pat called with ((ensures <==>(=(String.compare a b, 0), =(a, b))))
is_smt_pat called with ((ensures (/\(=(s1, t1), =(s2, t2)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures <==>(bytes_eq a b, =(a, b))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (/\(=(s1, t1), =(s2, t2)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
Verified module: CPS.Double (127 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.DoubleLambdaLifting2 CPS.DoubleLambdaLifting2.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Platform.Bytes.fst(15,32-18,29) :  : (Warning) Pattern misses at least one bound variable: uu___#1090
Verified module: Effects.Def (3085 milliseconds)
All verification conditions discharged successfully
Verified module: Ex03a (269 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03b.fst
Verified module: Test (27 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Exceptions.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints LambdaOmega.fst --max_fuel 1 --max_ifuel 1 --initial_fuel 1
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Test (36 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include plain.pos --odir plain.pos Test.fst
unknown(0,0-0,0) :  : (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
is_smt_pat called with ((ensures (==(x1, x2))))
#done-nok
make[2]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src/tests/interactive'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.ExnSt.fst
Verified module: AllocST (2168 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module NatHeap NatHeap.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex03b (127 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03c.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex03a (286 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03c.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==>(_ (bsearch t a), /\(/\((>=(_ (bsearch t a), 0)), (<(_ (bsearch t a), (length t)))), (=(index t (_ (bsearch t a)), a)))))))
is_smt_pat called with ((ensures (forall x.{:pattern } (==>((/\(/\((<=(x, y)), (<(y, a))), (=(x, a)))), False)))))
is_smt_pat called with ((ensures (forall p.{:pattern } (==>((/\(/\(/\((<=(0, p)), (<(p, length t))), (=(index t p, a))), (<=(p, mid)))), False)))))
is_smt_pat called with ((ensures (forall x.{:pattern } (==>((/\(/\((<=(y, x)), (<(a, y))), (=(x, a)))), False)))))
is_smt_pat called with ((ensures (forall p.{:pattern } (==>((/\(/\(/\((<=(0, p)), (<(p, length t))), (=(index t p, a))), (<=(mid, p)))), False)))))
is_smt_pat called with ((ensures (==>((_ (bsearch t a)), (forall p.{:pattern } ==>(<=(0, p), ==>(<(p, length t), <>(index t p, a))))))))
Verified module: Test (21 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include noshadow.pos --odir noshadow.pos Test.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: Ex03b (120 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04a.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: CPS.DoubleLambdaLifting2 (161 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.DoubleDefun CPS.DoubleDefun.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: StlcCbvDbPntSubstNoLists (9266 milliseconds)
All verification conditions discharged successfully
Verified module: AES (641 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StackMachine StackMachine.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04b.fst
Verified module: BinarySearchTree (2588 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTree0 BinarySearchTree0.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(esubst s1 e, esubst s2 e))))
is_smt_pat called with ((ensures (=(esubst s ((ELam t e)), (ELam t (esubst (esub_lam s) e))))))
is_smt_pat called with ((ensures (=(tsubst s1 t, tsubst s2 t))))
is_smt_pat called with (decreases (Prims.LexCons is_tvar t (Prims.LexCons is_trenaming s1 (Prims.LexCons is_trenaming s2 (Prims.LexCons t (Prims.LexTop ))))))
is_smt_pat called with (decreases t1)
is_smt_pat called with (decreases s)
is_smt_pat called with ((ensures (=((tsub_comp (tsub_beta_gen x s1) (tsub_beta_gen y s2)) v, (tsub_comp (tsub_beta_gen y (tsubst_beta_gen x s1 s2)) (tsub_beta_gen (+(x, 1)) (tshift_up_above y s1))) v))))
is_smt_pat called with ((ensures (=(ts x s (ts y t2 t1), ts y (ts x s t2) (ts (+(x, 1)) (tsh y s) t1)))))
Verified module: Ex03c (356 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04c.fst
Verified module: Test (29 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include field.pos --odir field.pos Test.fst
Verified module: FStar.DM4F.Exceptions (3974 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.StExn.fst
Verified module: FStar.TwoLevelHeap (3174 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Tcp.fst
Verified module: Ex03c (138 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04a.fst
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
WARNING: (6712,66): pattern does not contain any variable.
Verified module: CPS.DoubleDefun (1413 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Expr CPS.Expr.fst
is_smt_pat called with ((ensures (=(length (append l1 l2), +(length l1, length l2)))))
Verified module: Ex04a (497 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04e.fst
Verified module: StlcStrongDbParSubst (12309 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Integers.fst
Verified module: Ex04b (438 milliseconds)
All verification conditions discharged successfully
Verified module: BinarySearch (6419 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04f.fst
Verified module: NatHeap (6111 milliseconds)
All verification conditions discharged successfully
Verified module: Test (38 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module IntSort IntSort.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ImmutableSTwHeaps ImmutableSTwHeaps.fst
! /cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include plain.neg --odir plain.neg Test.fst > plain.neg/error.log 2>&1
Verified module: FStar.DM4F.IntST (5921 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.ST.fst
Verified module: BinarySearchTree0 (1161 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTreeBasic BinarySearchTreeBasic.fst
WARNING: (67353,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
WARNING: (6968,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex04a (304 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04b.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r lo hi (_ h)) (p1_r lo hi (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p2_r lo hi (_ h)) (p2_r lo hi (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p3_r lo1 lo2 hi (_ h)) (p3_r lo1 lo2 hi (_ h)))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex04c (1084 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04g.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: SfLists (9690 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfPoly SfPoly.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: CPS.Expr (721 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.SimpleDefun CPS.SimpleDefun.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Ex04e (925 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with (decreases t)
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04h.fst
Verified module: FStar.DM4F.ExnSt (4851 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.fst
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
plain.neg failed as expected
! /cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include shadow.neg --odir shadow.neg Test.fst > shadow.neg/error.log 2>&1
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: ImmutableSTwHeaps (936 milliseconds)
All verification conditions discharged successfully
WARNING: (6635,66): pattern does not contain any variable.
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ReifyTest ReifyTest.fst
Verified module: IfcComposeReify (3251 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(length (append l1 l2), +(length l1, length l2)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDeclassify IfcDeclassify.fst
Verified module: FStar.DM4F.StExn (5398 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.ST.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
Verified module: Ex04f (1404 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
Verified module: Ex04b (391 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05a.fst
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04c.fst
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Encrypt_SymEnc.fst(29,0-29,18) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: StlcCbvDbParSubst (12971 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.DM4F.ST (2638 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDelimitedRelease IfcDelimitedRelease.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.StExnC.fst
.\Platform.Bytes.fst(257,22-260,30) :  : (Warning) Pattern misses at least one bound variable: i#40244
Verified module: Ex04g (266 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05b.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Platform.Bytes.fst(261,8-261,24) :  : (Warning) Pattern misses at least one bound variable: i#42374 (see also .\Platform.Bytes.fst(257,156-260,30))
Verified module: Encrypt_SymEnc (3102 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Encrypt_Sample.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
WARNING: (6972,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with (decreases l2)
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex04h (435 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06a.fst
is_smt_pat called with ((ensures (==(p1, p2))))
shadow.neg failed as expected
! /cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include open.neg --odir open.neg Test.fst > open.neg/error.log 2>&1
is_smt_pat called with ((ensures (let  sl = snd (reify (f ()) (_ s)) in let  sr = snd (reify (f ()) (_ s)) in (\/(\/(sl.release, sr.release), low_equiv ((R sl sr)))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex05a (1357 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06b.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: IntSort (2289 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module InsertionSort InsertionSort.fst
Verified module: Ex04c (554 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04e.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: IfcDeclassify (3064 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDelimitedReleaseReify IfcDelimitedReleaseReify.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: ReifyTest (4481 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module AllocSTwHeaps AllocSTwHeaps.fst
Verified module: BinaryTrees (33111 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTreeFirst BinarySearchTreeFirst.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
Verified module: CPS.SimpleDefun (963 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.SimpleLambdaLifting CPS.SimpleLambdaLifting.fst
Verified module: Ex05b (2094 milliseconds)
All verification conditions discharged successfully
Verified module: Ex06a (236 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06c.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Projectors2 Unit1.Projectors2.fst
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
open.neg failed as expected
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
! /cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include private.neg --odir private.neg Test.fst > private.neg/error.log 2>&1
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex04e (614 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04f.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Unit1.Basic (23341 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.WPsAndTriples Unit1.WPsAndTriples.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.DM4F.Heap (7008 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IFC.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
Verified module: BinarySearchTreeBasic (13806 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module RBTree RBTree.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex06b (5284 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06d.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: AllocSTwHeaps (1737 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Preorder Preorder.fst
Verified module: Encrypt_Sample (62 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 SHA1.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
private.neg failed as expected
! /cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include trans.neg --odir trans.neg Test.fst > trans.neg/error.log 2>&1
Verified module: FStar.DM4F.StExnC (8157 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Continuations.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex04f (476 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04g.fst
Verified module: FStar.Tcp (31 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt63.fst
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
Verified module: FStar.DM4F.Heap.ST (7912 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints delimcc.fst
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x (append l m), (+(count x l, count x m))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(mem x (append l m), (||(mem x l, mem x m))))))
is_smt_pat called with ((ensures ((/\(/\(/\(/\(=(+(length (fst (partition f l)), length (snd (partition f l))), length l), (forall x.{:pattern } ==>(mem x (fst (partition f l)), f x))), (forall x.{:pattern } ==>(mem x (snd (partition f l)), not (f x)))), (forall x.{:pattern } =(mem x l, (||(mem x (fst (partition f l)), mem x (snd (partition f l))))))), (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l)))))))))))
is_smt_pat called with ((ensures (sorted f (append l1 ((Prims.Cons pivot l2))))))
Verified module: SfPoly (12709 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/software_foundations'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --explicit_deps ArrayRealized.fst Vector.fst
Verified module: Unit1.WPsAndTriples (392 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Parser Unit1.Parser.fst
Verified module: InsertionSort (1459 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MergeSort MergeSort.fst
trans.neg failed as expected
! /cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include noshadow.neg --odir noshadow.neg Test.fst > noshadow.neg/error.log 2>&1
is_smt_pat called with (decreases t)
is_smt_pat called with (decreases t)
Verified module: Preorder (52 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --record_hints --verify_module MRefHeap MRefHeap.fst
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: CPS.SimpleLambdaLifting (156 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Eval.DB Eval.DB.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStore.fst
.\Ex04g.fst(5,4-5,6): Warning: Admitting tl without a definition
.\Ex04g.fst(4,4-4,6): Warning: Admitting hd without a definition
Verified module: Ex04g (29 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04h.fst
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
Verified module: DelimCC (1379 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
Verified module: FStar.DM4F.IFC (6364 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
Verified module: Ex06c (8586 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.RefinementInference Unit1.RefinementInference.fst
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06e.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreFixedReader.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
noshadow.neg failed as expected
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/incl'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreFixed.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: BinarySearchTreeFirst (3608 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module QuickSort.List QuickSort.List.fst
Verified module: IfcDelimitedRelease (9428 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExample IfcExample.fst
Verified module: Ex06d (5765 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07a.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Unit1.Parser (1476 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.WPsAndTriples_ST Unit1.WPsAndTriples_ST.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Unit1.RefinementInference (139 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Projectors1 Unit1.Projectors1.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.DM4F.Continuations (4897 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreExcFixed.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex04h (29 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05a.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (/\(_ (typing empty v), ==(typing g (subst x v e), typing (extend g x (_ (typing empty v))) e)))))
is_smt_pat called with ((ensures (/\(_ (step e), ==(typing empty (_ (step e)), typing empty e)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
Verified module: Ex06e (1069 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07b.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Unit1.Projectors2 (39 milliseconds)
All verification conditions discharged successfully
Verified module: Eval.DB (3369 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.UnificationTests Unit1.UnificationTests.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module mcCarthy91 mcCarthy91.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AVar r)) (env r))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
Verified module: Unit1.WPsAndTriples_ST (298 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.RecursiveTypeFunctions Unit1.RecursiveTypeFunctions.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
WARNING: (67353,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: MRefHeap (5363 milliseconds)
All verification conditions discharged successfully
WARNING: (70852,6): pattern does not contain all quantified variables.
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SnapshotST SnapshotST.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: MergeSort (2822 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module QuickSort.Seq QuickSort.Seq.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Ex05a.fst(28,4-28,13): Warning: Admitting rev_is_ok without a definition
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: SHA1 (799 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 MAC.fst
Verified module: Ex05a (792 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05b.fst
Verified module: IfcExample (2358 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify0 IfcExampleReify0.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Unit1.UnificationTests (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit2 Unit2.fst
is_smt_pat called with ((ensures _ (fst (reify (read r) store))))
is_smt_pat called with ((ensures _ (fst (reify (write r x) store))))
is_smt_pat called with ((ensures (/\(in_ r store, ==(normalize_term (fst (reify (let  () = write_tot r x in read_tot r) store)), (Some x))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: McCarthy91 (515 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module termination termination.fst
Verified module: RBTree (16061 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/data_structures'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ReifyTestTSST ReifyTestTSST.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: SnapshotST (3278 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MRefST MRefST.fst
Verified module: FStar.DM4F.IntStoreFixedReader (1905 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.Random.fst
Verified module: Ex05b (494 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06a.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(length l_1, length l_2))))
Verified module: Unit2 (1680 milliseconds)
All verification conditions discharged successfully
Verified module: Ex07a (11176 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestSet TestSet.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07c.fst
Verified module: FStar.DM4F.IntStore (5207 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Random.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.DM4F.IntStoreFixed (3666 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07d.fst
Verified module: ReifyTestTSST (1375 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Sig.fst
Verified module: Unit1.RecursiveTypeFunctions (2341 milliseconds)
All verification conditions discharged successfully
.\Ex06a.fst(5,4-5,13): Warning: Admitting partition without a definition
Verified module: Ex06a (27 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestHeap TestHeap.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06b.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
WARNING: (4215,6): pattern does not contain all quantified variables.
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Termination (3668 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/termination'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Cert.ACLs.fst
Verified module: QuickSort.List (10199 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.Base.fst
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
Verified module: IfcDelimitedReleaseReify (14335 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Platform.Bytes.fst(15,40-18,29) :  : (Warning) Pattern misses at least one bound variable: uu___#79854
.\Platform.Bytes.fst(261,8-261,24) :  : (Warning) Pattern misses at least one bound variable: i#89301 (see also .\Platform.Bytes.fst(257,156-260,30))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
Verified module: Platform.Bytes (58386 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/bytes'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify1 IfcExampleReify1.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ShortCircuit ShortCircuit.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
Verified module: FStar.DM4F.IntStoreExcFixed (4610 milliseconds)
All verification conditions discharged successfully
Verified module: TestSet (517 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module FirstProofs FirstProofs.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Reader.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==((ifc_c_r (_ h) x), (ifc_c_r (_ h) x)))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r (_ h) x) x, sel (ifc_c_r (_ h) x) x))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r (_ h) x) x, sel (ifc_c_r (_ h) x) x))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r h x) x, 0))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: TestHeap (1236 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestMRef TestMRef.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: IfcExampleReify0 (2140 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify2 IfcExampleReify2.fst
Verified module: FirstProofs (1266 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestTwoLevelHeap TestTwoLevelHeap.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
.\MAC.fst(45,0-45,35) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Cert.ACLs (707 milliseconds)
All verification conditions discharged successfully
Verified module: QuickSort.Seq (3515 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Cap.fst
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module GC GC.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.DM4F.Heap.Random (1875 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unification Unification.fst
Verified module: FStar.Reader (905 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Bytes.fst
Verified module: ShortCircuit (1763 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Mac Mac.fst
Verified module: MAC (2245 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Formatting.fst
Verified module: FStar.UInt63 (14614 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Classical.fst
Verified module: MRefST (9733 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/preorders'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Constructive.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.Integers (34934 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst
.\TestMRef.fst(8,0-8,20) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Test (27829 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include jsonparser.pos --odir jsonparser.pos Test.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Unit1.Projectors1 (2415 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestGhost TestGhost.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: TestMRef (1146 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Normalization Normalization.fst
Verified module: Ex06b (7085 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06e.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.List.Tot.Base (7476 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DependentMap.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: TestTwoLevelHeap (565 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Positivity Positivity.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: TestGhost (604 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints NegativeTests.BST.fst NegativeTests.Heap.fst NegativeTests.ShortCircuiting.fst NegativeTests.Bug260.fst NegativeTests.Neg.fst NegativeTests.Termination.fst NegativeTests.False.fst NegativeTests.Set.fst NegativeTests.ImplicitFalse.fst NegativeTests.Positivity.fst 2>&1 | tee fstar_log
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
.\Ex06e.fst(18,4-18,8): Warning: Admitting sort without a definition
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex06e (429 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07a.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Constructive (2493 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.FunctionalExtensionality.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
Verified module: FStar.Classical (3600 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.MarkovsPrinciple.fst
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
Verified module: Sig (1963 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 RPC.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (OrdSet.subset (vars (subst_term s t')) (OrdSet.remove (fst s) (OrdSet.union (vars (snd s)) (vars t'))))))
is_smt_pat called with ((ensures (OrdSet.subset (evars (lsubst_eqns (Prims.Cons (Prims.Mktuple2 x t) (Prims.Nil )) e)) (OrdSet.remove x (evars ((Prims.Cons ((Prims.Mktuple2 (V x) t)) e)))))))
is_smt_pat called with ((ensures (=(lsubst_term (extend_lsubst l l') e, lsubst_term l (lsubst_term l' e)))))
is_smt_pat called with ((ensures (=(subst_term ((Prims.Mktuple2 x z)) y, y))))
is_smt_pat called with ((ensures (=(lsubst_term (Prims.Cons s (Prims.Nil )) (lsubst_term l (subst_term s e)), lsubst_term (Prims.Cons s (Prims.Nil )) (lsubst_term l e)))))
is_smt_pat called with ((ensures (=(lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns l (lsubst_eqns (Prims.Cons s (Prims.Nil )) e)), lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns l e)))))
is_smt_pat called with ((ensures (solved (lsubst_eqns l'' ((Prims.Cons ((Prims.Mktuple2 (V x) y)) tl))))))
is_smt_pat called with ((ensures (=(subst_term s (subst_term s t), subst_term s t))))
is_smt_pat called with ((ensures (=(lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns (Prims.Cons s (Prims.Nil )) e), lsubst_eqns (Prims.Cons s (Prims.Nil )) e))))
is_smt_pat called with ((ensures (not_solveable ((Prims.Mktuple2 (V x) t)))))
is_smt_pat called with ((ensures (=(lsubst_term l (subst_term ((Prims.Mktuple2 x t)) t'), lsubst_term l t'))))
is_smt_pat called with ((ensures (=(lsubst_eqns l (lsubst_eqns (Prims.Cons (Prims.Mktuple2 x t) (Prims.Nil )) e), lsubst_eqns l e))))
is_smt_pat called with ((ensures (not_solveable_eqns ((Prims.Cons ((Prims.Mktuple2 (V x) t)) tl)))))
is_smt_pat called with ((ensures (if _ (unify_eqns e) then not_solveable_eqns e else solved (lsubst_eqns (_ (unify_eqns e)) e))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex07c (17741 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10a.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Positivity (1380 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.DM4F.Random (7605 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10b.fst
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/dm4free'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (/\(_ (typing empty v), ==(typing g (subst x v e), typing (extend g x (_ (typing empty v))) e)))))
is_smt_pat called with ((ensures (/\(_ (step e), ==(typing empty (_ (step e)), typing empty e)))))
.\Ex07a.fst(228,4-228,14): Warning: Admitting typed_step without a definition
Verified module: Ex07b (29882 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.FunctionalExtensionality (264 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07b.fst
Verified module: FStar.DependentMap (3785 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Array.fst
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include disjoint.pos --odir disjoint.pos Test.fst
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
Verified module: FStar.MarkovsPrinciple (28 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.SquashEffect.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: FStar.Map (6224 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.BitVector.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Normalization (2656 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 CntFormat.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex07d (20394 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify3 IfcExampleReify3.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: GC (11829 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Huffman Huffman.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: Cap (539 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 CntProtocol.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.SquashEffect (391 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.PropositionalExtensionality.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: Formatting (3723 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.Plain.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex10b (3359 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12a.Cap.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: IfcExampleReify1 (5938 milliseconds)
All verification conditions discharged successfully
Verified module: LambdaOmega (76902 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRecursiveHeapReify IfcRecursiveHeapReify.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include array.pos --odir array.pos Test.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Ex10a.fst(27,0-27,19) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures ni_com env ((Seq c_2 c_3)) Low))
Verified module: FStar.Bytes (532 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07c.fst
.\Mac.fst(70,0-70,35) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: FStar.PropositionalExtensionality (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Set.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: MAC (2121 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12b.RPC.fst
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Ex10a (3230 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12d.Pad.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(decode t (@(bs, bs')), (match decode t bs' with (Some ss)  -> (Some ((Prims.Cons s ss))) | None  -> None)))))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (==>(>(List.Tot.length sws, 1), (let  t = huffman sws in (match encode t ss with (Some e)  -> (match decode t e with (Some d)  -> =(d, ss) | None  -> False) | None  -> True))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
Verified module: Ex07a (11552 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07d.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\RPC.fst(9,0-9,53) :  : (Warning) Top-level let-bindings must be total; this term may have effects
.\RPC.fst(23,0-23,39) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (f x)))
.\RPC.fst(48,0-49,16) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.List (5164 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.Properties.fst
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
.\RPC.fst(116,0-116,17) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: RPC (1582 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.MAC.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: IfcExampleReify2 (6484 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRecursiveReify IfcRecursiveReify.fst
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
.\Ex07d.fst(225,4-225,8): Warning: Admitting eval without a definition
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
.\CntProtocol.fst(14,0-14,53) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\CntProtocol.fst(29,0-29,26) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
.\CntProtocol.fst(32,0-32,54) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
Verified module: FStar.Set (3228 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt32.fst
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
.\CntProtocol.fst(35,0-35,54) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (let  h' = p1_r x y hi h in /\(/\((=(sel h' y, sel h y)), (=(sel h' x, +(sel h x, sel h y)))), (=(sel h' hi, sel h hi))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r x y hi (_ h)) (p1_r x y hi (_ h)))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Unification (21559 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcReificationRegressionTest IfcReificationRegressionTest.fst
Verified module: FStar.Array (5245 milliseconds)
All verification conditions discharged successfully
.\Ex12a.Cap.fst(19,0-19,26) :  : (Warning) Top-level let-bindings must be total; this term may have effects
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Squash.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
.\CntProtocol.fst(99,0-99,39) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
Verified module: Ex12a.Cap (475 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12e.Pad.fst
Verified module: CntFormat (3550 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.CPA.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
.\CntProtocol.fst(126,0-126,18) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: IfcExampleReify3 (2924 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRules IfcRules.fst
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
.\CntProtocol.fst(158,0-174,5) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
Verified module: CntProtocol (5837 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.AE.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex07b (18575 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10a.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.BitVector (11095 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Heap.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: EtM.Plain (26 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.RSA.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
Verified i'face (or impl+i'face): FStar.Squash (44 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdSet.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AVar r)) (env r))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Huffman (15203 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/algorithms'
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include point.pos --odir point.pos Test.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\Ex12b.RPC.fst(8,0-8,53) :  : (Warning) Top-level let-bindings must be total; this term may have effects
.\Ex12b.RPC.fst(21,0-21,39) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\Ex12b.RPC.fst(53,0-54,16) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: IfcReificationRegressionTest (1450 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10b.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r lo hi n (_ h)) (p1_r lo hi n (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p2_r lo hi n (_ h)) (p2_r lo hi n (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p3_r lo1 lo2 hi n (_ h)) (p3_r lo1 lo2 hi n (_ h)))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
Verified module: Ex07c (15416 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12a.Cap.fst
.\Ex12b.RPC.fst(123,0-123,17) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Ex12b.RPC (1845 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12f.TMAC.fst
Verified module: FStar.Heap (899 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Crypto.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: IfcRecursiveReify (2668 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRulesReify IfcRulesReify.fst
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (==(x1, x2))))
.\Ex10a.fst(27,0-27,19) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex10a (1632 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12d.Pad.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(Seq.length s_tail, Seq.length s))))
is_smt_pat called with ((ensures (~((Seq.mem double_quote contents)))))
is_smt_pat called with ((ensures (<(Seq.length s', Seq.length s))))
is_smt_pat called with ((ensures (<(Seq.length tail, Seq.length parsee))))
is_smt_pat called with ((ensures (==(gparse_object j gparse l data0 l' (Seq.append (gprint_object j gprint l data l') tail), (Some ((Prims.Mktuple2 data tail)))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(gparse_object j gparse l data0 l' (Seq.append (gprint_object j gprint l data l') tail), (Some ((Prims.Mktuple2 data tail)))))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex12d.Pad (1373 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12g.TMAC2.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: IfcRecursiveHeapReify (9443 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcTypechecker IfcTypechecker.fst
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: EtM.MAC (3276 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.PlainPKE.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex10b (1627 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12e.Pad.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: IfcRules (8352 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Loops Loops.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
Verified module: Ex07d (19513 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12f.TMAC.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.List.Tot.Properties (19887 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.TSet.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: EtM.CPA (3257 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.Plain.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex12e.Pad (2931 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ulib/hyperheap Ex11a.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\Ex12a.Cap.fst(21,0-21,26) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: FStar.TSet (1864 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.IndefiniteDescription.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: Ex12a.Cap (360 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12g.TMAC2.fst
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex12f.TMAC (565 milliseconds)
All verification conditions discharged successfully
mkdir -p out
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.ErasedLogic.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: EtM.AE (5157 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ulib/hyperheap Ex11a.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
Verified module: FStar.UInt32 (14238 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int64.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.IndefiniteDescription (1743 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.SquashProperties.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
.\NegativeTests.BST.fst(21,38-21,42) :  : (Error) Subtyping check failed; expected type (right#61:(option (tree 2)){(l_and (l_and (l_and (b2t (op_LessThanOrEqual 0 1)) (b2t (op_LessThanOrEqual 1 2))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality 1 2)))) (l_iff (b2t (uu___is_None (None ))) (b2t (op_Equality 1 0))))}); got type (option (tree 2)) (see also .\NegativeTests.BST.fst(13,36-13,57))
.\NegativeTests.BST.fst(22,61-22,65) :  : (Error) Subtyping check failed; expected type (right#61:(option (tree (op_Addition l 1))){(l_and (l_and (l_and (b2t (op_LessThanOrEqual l l)) (b2t (op_LessThanOrEqual l (op_Addition l 1)))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality l (op_Addition l 1))))) (l_iff (b2t (uu___is_None (Some t))) (b2t (op_Equality l l))))}); got type (option (tree (op_Addition l 1))) (see also .\NegativeTests.BST.fst(13,36-13,57))
.\NegativeTests.BST.fst(23,78-23,87) :  : (Error) Subtyping check failed; expected type (right#61:(option (tree (op_Addition l 1))){(l_and (l_and (l_and (b2t (op_LessThanOrEqual l (op_Addition l 1))) (b2t (op_LessThanOrEqual (op_Addition l 1) (op_Addition l 1)))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality (op_Addition l 1) (op_Addition l 1))))) (l_iff (b2t (uu___is_None (Some t1))) (b2t (op_Equality (op_Addition l 1) l))))}); got type (option (tree (op_Addition l 1))) (see also .\NegativeTests.BST.fst(12,36-12,58))
.\NegativeTests.Bug260.fst(9,12-9,19) :  : (Error) Subtyping check failed; expected type (validity (S (S t))); got type (validity (S t)) (see also .\NegativeTests.Bug260.fst(8,37-9,9))
.\NegativeTests.False.fst(3,31-3,42) :  : (Error) assertion failed
.\NegativeTests.False.fst(13,18-13,35) :  : (Error) Expected type "(l_or l_True l_True)"; but "(Left T)" has type "(c_or (?37015 uu___) l_True)"
.\NegativeTests.False.fst(13,36-13,54) :  : (Error) Expected type "(l_or l_True l_True)"; but "(Right T)" has type "(c_or l_True (?37028 uu___))"
.\NegativeTests.Heap.fst(10,0-10,54) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Heap.fst(11,0-15,14) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.ImplicitFalse.fst(4,0-4,33) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(175,22-175,33))
.\NegativeTests.ImplicitFalse.fst(4,26-4,27) :  : (Error) Failed to resolve implicit argument of type 'l_False' introduced in (?37540 uu___) because user-provided implicit term
.\NegativeTests.Neg.fst(6,8-6,10) :  : (Error) Subtyping check failed; expected type nat; got type int (see also C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Neg.fst(8,8-8,10) :  : (Error) Subtyping check failed; expected type nat; got type int (see also C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Neg.fst(10,0-10,35) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Neg.fst(12,28-13,15) :  : (Error) Patterns are incomplete
.\NegativeTests.Neg.fst(19,32-19,42) :  : (Error) assertion failed (see also .\NegativeTests.Neg.fst(15,44-15,57))
.\NegativeTests.Neg.fst(21,83-21,88) :  : (Error) could not prove post-condition
.\NegativeTests.Neg.fst(25,30-25,31) :  : (Error) Subtyping check failed; expected type (uu___#8234:(option 'a){(b2t (uu___is_Some uu___@0))}); got type (option 'a) (see also C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(252,4-252,8))
.\NegativeTests.Neg.fst(28,41-28,43) :  : (Error) Subtyping check failed; expected type (uu___#9393:(result int){(b2t (uu___is_V uu___@0))}); got type (result int) (see also C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(259,4-259,5))
.\NegativeTests.Neg.fst(32,25-32,26) :  : (Error) Subtyping check failed; expected type nat; got type int (see also C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Positivity.fst(6,5-7,26) :  : (Error) Inductive type NegativeTests.Positivity.t1 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(20,5-21,26) :  : (Error) Inductive type NegativeTests.Positivity.t5 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(30,5-31,24) :  : (Error) Inductive type NegativeTests.Positivity.t7 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(34,5-35,24) :  : (Error) Inductive type NegativeTests.Positivity.t8 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(41,5-42,23) :  : (Error) Inductive type NegativeTests.Positivity.t10 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(45,5-46,30) :  : (Error) Inductive type NegativeTests.Positivity.t11 does not satisfy the positivity condition
.\NegativeTests.Set.fst(11,0-12,30) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Set.fst(15,0-16,67) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Set.fst(19,0-20,52) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.ShortCircuiting.fst(5,16-5,33) :  : (Error) Subtyping check failed; expected type (b#22:bool{(bad_p b@0)}); got type bool (see also .\NegativeTests.ShortCircuiting.fst(4,31-4,38))
.\NegativeTests.ShortCircuiting.fst(8,0-8,36) :  : (Error) assertion failed(Also see: C:\Build\Agent\_work\1\s\bin\..\ulib\prims.fst(175,22-175,33))
.\NegativeTests.Termination.fst(7,27-7,28) :  : (Error) Subtyping check failed; expected type (z#130:int{(precedes (LexCons m (LexCons z@0 LexTop)) m)}); got type int (see also .\NegativeTests.Termination.fst(5,0-7,29))
.\NegativeTests.Termination.fst(13,26-13,35) :  : (Error) Subtyping check failed; expected type (uu___#616:int{(precedes (LexCons n (LexCons uu___@0 LexTop)) (LexCons n (LexCons count LexTop)))}); got type int (see also .\NegativeTests.Termination.fst(10,0-13,35))
.\NegativeTests.Termination.fst(20,29-20,54) :  : (Error) Subtyping check failed; expected type (n#1073:int{(precedes (LexCons (op_Subtraction m 1) (LexCons n@0 LexTop)) (LexCons m (LexCons n LexTop)))}); got type int (see also .\NegativeTests.Termination.fst(17,0-20,54))
.\NegativeTests.Termination.fst(25,28-25,29) :  : (Error) Subtyping check failed; expected type (uu___#1993:(list 'a){(precedes uu___@0 l)}); got type (list 'a) (see also .\NegativeTests.Termination.fst(23,0-25,29))
.\NegativeTests.Termination.fst(37,15-37,29) :  : (Error) Subtyping check failed; expected type (x:(x#2581:nat{(b2t (op_LessThanOrEqual x@0 v))}) -> Tot nat); got type (uu___:(uu___#3405:nat{(precedes uu___@0 v)}) -> Tot nat) (see also .\NegativeTests.Termination.fst(34,0-37,29))
.\NegativeTests.Termination.fst(48,19-48,29) :  : (Error) Subtyping check failed; expected type (uu___#4199:snat{(precedes uu___@0 n)}); got type snat (see also .\NegativeTests.Termination.fst(44,0-48,29))
.\NegativeTests.Termination.fst(55,34-55,35) :  : (Error) Subtyping check failed; expected type (uu___#4752:snat{(precedes (LexCons (S (S n')) (LexCons uu___@0 LexTop)) (LexCons n (LexCons m LexTop)))}); got type snat (see also .\NegativeTests.Termination.fst(51,0-55,35))
.\NegativeTests.Termination.fst(59,2-61,14) :  : (Error) Patterns are incomplete
.\NegativeTests.Termination.fst(67,29-67,31) :  : (Error) Subtyping check failed; expected type (uu___#5798:NegativeTests.Termination.snat{(Prims.precedes<?43218, ?43219> (Prims.LexCons<?43223, (max ?43231, ?43239)> (NegativeTests.Termination.S n'#6308) (Prims.LexCons<?43231, ?43239> uu___@0 Prims.LexTop<?43239>)) (Prims.LexCons<?43245, (max ?43253, ?43261)> n#5785 (Prims.LexCons<?43253, ?43261> m#5786 Prims.LexTop<?43261>)))}); got type (?43509 n#5785 m#5786) (see also .\NegativeTests.Termination.fst(64,0-67,31))
.\NegativeTests.Termination.fst(73,20-73,26) :  : (Error) Subtyping check failed; expected type (uu___#6885:NegativeTests.Termination.snat{(Prims.precedes<?43617, ?43618> uu___@0 n#6881)}); got type NegativeTests.Termination.snat (see also .\NegativeTests.Termination.fst(70,0-73,26))
Verified module: NegativeTests.BST (6300 milliseconds)
Verified module: NegativeTests.Bug260 (2401 milliseconds)
Verified module: NegativeTests.False (2300 milliseconds)
Verified module: NegativeTests.Heap (2884 milliseconds)
Verified module: NegativeTests.ImplicitFalse (1340 milliseconds)
Verified module: NegativeTests.Neg (10127 milliseconds)
Verified module: NegativeTests.Positivity (1925 milliseconds)
Verified module: NegativeTests.Set (3649 milliseconds)
Verified module: NegativeTests.ShortCircuiting (3423 milliseconds)
Verified module: NegativeTests.Termination (15807 milliseconds)
41 errors were reported (see above)
is_smt_pat called with ((ensures (==(x1, x2))))
Success: 41 failures were expected
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/micro-benchmarks'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Memo Memo.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Crypto (1549 milliseconds)
All verification conditions discharged successfully
Verified module: HyE.RSA (445 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.Base.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.AE.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: FStar.ErasedLogic (43 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.HyperHeap.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall b.{:pattern } let  (Cons hd tl) = bs in ==>(mem b tl, disjoint (_ b) (_ hd)))))
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex12d.Pad (1116 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.OrdSet (21005 milliseconds)
All verification conditions discharged successfully
make -C ../../../..//ulib/ml
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
make[4]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/ulib/ml'
make -C .. mgen
make[5]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/ulib/ml'
make[5]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
mkdir -p ml/extracted
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --lax --codegen OCaml --odir ml/extracted FStar.Set.fst FStar.TSet.fst FStar.Map.fst FStar.HyperHeap.fst FStar.HyperStack.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
Verified module: Ex12g.TMAC2 (1309 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.MRef.fst
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall b.{:pattern } let  (Cons hd tl) = bs in ==>(mem b tl, disjoint (_ b) (_ hd)))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
.\Ex12f.TMAC.fst(26,4-26,10): Warning: Admitting verify without a definition
.\Ex12f.TMAC.fst(25,4-25,7): Warning: Admitting mac without a definition
.\Ex12f.TMAC.fst(24,4-24,10): Warning: Admitting keygen without a definition
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex12f.TMAC (38 milliseconds)
All verification conditions discharged successfully
Verified module: Ex12e.Pad (1448 milliseconds)
All verification conditions discharged successfully
Verified module: Loops (8795 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int32.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.CCA2.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Test (7803 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module NetKat NetKat.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.PredicateExtensionality.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: FStar.SquashProperties (3087 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdMap.fst
is_smt_pat called with ((ensures (f x)))
Verified module: IfcTypechecker (2372 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module OneTimePad OneTimePad.fst
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: HyE.Plain (26 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.HCCA2.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (match List.assoc x l with (Some y)  -> p ((Prims.Mktuple2 x y)) | _  -> True)))
is_smt_pat called with ((ensures (p ((Prims.Mktuple2 x y)))))
is_smt_pat called with ((ensures (valid_memo ((Prims.Cons ((Prims.Mktuple2 x y)) h)) f)))
is_smt_pat called with ((ensures (/\(valid_memo h0 f, (let  h1 = memo_heap_to_valid_memo (valid_memo_to_memo_heap f h0) in ==(h0, h1))))))
is_smt_pat called with ((ensures (let  (y, h1) = reify (memo_extr f x) h0 in /\(valid_memo h1 f, ==(y, f x)))))
is_smt_pat called with ((ensures (==>(p x, (let  (y, h1) = reify (memo_extr_p p f x) h0 in /\(==(y, g x), valid_memo h1 g))))))
is_smt_pat called with ((ensures (computes (memo_extr_p p f) g)))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(p x, (let  (y, h1) = reify (memo_extr_p p f x) h0 in /\(==(y, g x), valid_memo h1 g))))))
is_smt_pat called with ((ensures (==(y, fixp f x))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==(fixp f x, g x))))
is_smt_pat called with ((ensures (res (cont1 (fixfib x1)))))
is_smt_pat called with ((ensures (res (cont2 (fixfib x2)))))
is_smt_pat called with ((ensures (computes f g1)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
.\Ex12g.TMAC2.fst(30,4-30,10): Warning: Admitting verify without a definition
.\Ex12g.TMAC2.fst(29,4-29,7): Warning: Admitting mac without a definition
Verified module: FStar.MRef (708 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int.Cast.fst
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.List.Tot (29 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.All.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex12g.TMAC2 (850 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.PredicateExtensionality (149 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt128.fst
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Math.Lib.fst
is_smt_pat called with ((ensures (bijection f)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (let  ((enc_0, dec_0), _) = reify (one_time_pad ()) ((Prims.Mktuple2 0 tape_0)) in let  ((enc_1, dec_1), _) = reify (one_time_pad ()) ((Prims.Mktuple2 0 tape_1)) in /\(/\(=(dec_0 (enc_0 x_0), x_0), =(dec_1 (enc_1 x_1), x_1)), =(enc_0 x_0, enc_1 x_1)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases n)
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Extracted module Classical
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Heap
is_smt_pat called with ((ensures (==(p1, p2))))
Extracted module Set
Extracted module Base
is_smt_pat called with ((ensures (==(p1, p2))))
Extracted module Properties
Extracted module Tot
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Extracted module Map
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Extracted module HyperHeap
Verified module: FStar.All (53 milliseconds)
All verification conditions discharged successfully
Extracted module HyperStack
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt16.fst
All verification conditions discharged successfully
make[5]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/ulib'
make prims.o FStar_Mul.o FStar_Float.o FStar_Char.o FStar_Int8.o FStar_UInt8.o FStar_Int16.o FStar_UInt16.o FStar_Int32.o FStar_UInt32.o FStar_Int64.o FStar_UInt64.o FStar_UInt128.o FStar_Int_Cast.o FStar_BaseTypes.o FStar_IO.o FStar_Heap.o FStar_List_Tot_Base.o FStar_List.o FStar_Option.o FStar_String.o FStar_Set.o FStar_Buffer.o FStar_CommonST.o FStar_ST.o FStar_All.o
make[5]: Entering directory '/cygdrive/c/Build/Agent/_work/1/s/ulib/ml'
make[5]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg prims.ml
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Mul.ml
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Float.ml
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Char.ml
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int8.ml
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt8.ml
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int16.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt16.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int32.ml
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt32.ml
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int64.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt64.ml
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt128.ml
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int_Cast.ml
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_BaseTypes.ml
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_IO.ml
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Heap.ml
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_List_Tot_Base.ml
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_List.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Option.ml
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_String.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Set.ml
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Buffer.ml
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Test (26029 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_CommonST.ml
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_location_info --lax \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
RPC.fst \
--codegen-lib Platform --codegen-lib CoreCrypto --codegen-lib Seq --codegen OCaml
Verified module: HyE.PlainPKE (347 milliseconds)
All verification conditions discharged successfully
Verified module: Test (9186 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_ST.ml
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_location_info --lax \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
CntProtocol.fst \
--codegen-lib Platform --codegen-lib CoreCrypto --codegen-lib Seq --codegen OCaml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_All.ml
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.WellFounded.fst
make[5]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/ulib/ml'
ocamlopt -a prims.cmx FStar_Mul.cmx FStar_Float.cmx FStar_Char.cmx FStar_Int8.cmx FStar_UInt8.cmx FStar_Int16.cmx FStar_UInt16.cmx FStar_Int32.cmx FStar_UInt32.cmx FStar_Int64.cmx FStar_UInt64.cmx FStar_UInt128.cmx FStar_Int_Cast.cmx FStar_BaseTypes.cmx FStar_IO.cmx FStar_Heap.cmx FStar_List_Tot_Base.cmx FStar_List.cmx FStar_Option.cmx FStar_String.cmx FStar_Set.cmx FStar_Buffer.cmx FStar_CommonST.cmx FStar_ST.cmx FStar_All.cmx -o fstarlib.cmxa
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==>((=(dom #k #v #f m, OrdSet.empty)), (==(m, empty #k #v #f))))))
make[4]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/ulib/ml'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_extract FStar.All --no_extract FStar.BaseTypes --no_extract FStar.Char --no_extract FStar.Float --no_extract FStar.Heap --no_extract FStar.Int8 --no_extract FStar.Int16 --no_extract FStar.Int32 --no_extract FStar.Int64 --no_extract FStar.UInt8 --no_extract FStar.UInt16 --no_extract FStar.UInt32 --no_extract FStar.UInt64 --no_extract FStar.Int_Cast --no_extract FStar.IO --no_extract FStar.List --no_extract FStar.List.Tot.Base --no_extract FStar.Option --no_extract FStar.Set --no_extract FStar.ST --no_extract FStar.String --no_extract FStar.HyperHeap --no_extract FStar.HyperStack --no_extract FStar.HST --no_extract FStar.Buffer --no_extract FStar.Mul --odir out --codegen OCaml Ex01a.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: NetKat (4197 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Point Point.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
Verified module: HyE.AE (3176 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ProgramEquivalence ProgramEquivalence.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
Verified module: Ex11a (15808 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/doc/tutorial/code/exercises'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ProgramOptimizations ProgramOptimizations.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: Ex11a (18726 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module RandomTapes RandomTapes.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
.\Ex01a.fst(58,0-58,48) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Ex01a
Verified module: Ex01a (897 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -package batteries,stdint,zarith -linkpkg -g ../../../..//ulib/ml/fstarlib.cmxa -I ../../../..//ulib/ml out/Ex01a.ml -o Ex01a.exe 2>&1
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
File "out/Ex01a.ml", line 23, characters 8-10:
Warning 26: unused variable v1.
File "out/Ex01a.ml", line 23, characters 29-31:
Warning 26: unused variable v2.
File "out/Ex01a.ml", line 39, characters 8-10:
Warning 26: unused variable v1.
File "out/Ex01a.ml", line 40, characters 8-10:
Warning 26: unused variable v2.
File "out/Ex01a.ml", line 41, characters 8-10:
Warning 26: unused variable v3.
Verified module: FStar.Math.Lib (7586 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int8.fst
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (bijection f)))
Verified module: FStar.WellFounded (762 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.Properties.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Extracted module StrongExcludedMiddle
Extracted module Classical
Extracted module Base
Extracted module Properties
Extracted module Tot
Extracted module Base
Extracted module Properties
Extracted module Seq
Extracted module Bytes
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Heap
Extracted module ST
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Extracted module CoreCrypto
Extracted module All
Extracted module Formatting
Extracted module SHA1
Extracted module MAC
Extracted module RPC
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Relational.Relational.fst
Verified module: RandomTapes (962 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Recursive Recursive.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Extracted module StrongExcludedMiddle
Extracted module Classical
Extracted module Base
./Ex01a.exe 2>&1
Extracted module Properties
Extracted module Tot
Dummy read of file demo/tempfile
Dummy read of file demo/README
Dummy write of string hello! to file demo/tempfile
Dummy read of file demo/tempfile
Dummy read of file demo/README
Fatal error: exception Ex01a.InvalidRead
Raised at file "prims.ml", line 103, characters 20-21
Called from file "out/Ex01a.ml", line 41, characters 13-31
Called from file "out/Ex01a.ml", line 43, characters 42-60
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/doc/tutorial/code/solutions'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ReifyLong ReifyLong.fst
make[3]: [Makefile:66: Ex01a-ocaml] Error 2 (ignored)
Extracted module Base
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Extracted module Properties
Extracted module Seq
Extracted module Bytes
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
Extracted module Heap
Extracted module ST
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
Extracted module All
is_smt_pat called with ((ensures (<>(j, root))))
Extracted module CntFormat
Extracted module CoreCrypto
Extracted module SHA1
Extracted module MAC
Extracted module Set
is_smt_pat called with ((ensures (==(p1, p2))))
Extracted module CntProtocol
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdMapProps.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (>=(fac n, fac m))))
is_smt_pat called with ((ensures (>=(fac_sum n m, fac_sum n' m'))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Seq.Base (20980 milliseconds)
All verification conditions discharged successfully
Verified module: Recursive (704 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt8.fst
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Rel Rel.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (==>((=(dom #k #v #f m, OrdSet.empty)), (==(m, empty #k #v #f))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Int32 (14231 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Fin.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.OrdMapProps (506 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Axiomatic.Array.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
Verified module: FStar.Int64 (15662 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Universe.fst
Verified module: FStar.Relational.Relational (3724 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int128.fst
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.HyperHeap (26200 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Math.Lemmas.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: IfcRulesReify (38322 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module StRel StRel.fst
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Rel (2176 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Swap Swap.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified i'face (or impl+i'face): FStar.Universe (27 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int63.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
Verified module: OneTimePad (28455 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind.Forest UnionFind.Forest.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.OrdMap (21958 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Relational.Comp.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.Axiomatic.Array (679 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Point (4305 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind UnionFind.fst
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com11) h_left in let  (_, h_right') = reify (com_denotation com12) h_right in rel_exp_denotation rel12 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com21) h_left in let  (_, h_right') = reify (com_denotation com22) h_right in rel_exp_denotation rel22 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com31) h_left in let  (_, h_right') = reify (com_denotation com32) h_right in rel_exp_denotation rel32 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com41) h_left in let  (_, h_right') = reify (com_denotation com42) h_right in rel_exp_denotation rel4 h_left' h_right')))
is_smt_pat called with ((ensures (rhl ((If CTrue c c')) d phi phi')))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
Verified module: StRel (685 milliseconds)
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind.Functions UnionFind.Functions.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Test (21527 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/struct'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Mul.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: ProgramEquivalence (7667 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module While While.fst
Verified module: FStar.Relational.Comp (331 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt64.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Mul (17 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: HyE.CCA2 (3294 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module WhileReify WhileReify.fst
Verified module: Memo (38252 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module OTP OTP.fst
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Seq (26 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Ghost.fst
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: HyE.HCCA2 (2174 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/crypto'
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ElGamal ElGamal.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.Int8 (13983 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.HyperStack.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Fin (8211 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int16.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
Verified module: FStar.UInt128 (16441 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdSetProps.fst
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (equiv (>>(f1, f2)) (>>(f2, f1)))))
is_smt_pat called with ((ensures (equiv (>>(f, f)) f)))
is_smt_pat called with ((ensures (/\(equiv (cond c c1 c2) c1, equiv (cond c c1 c2) c2))))
is_smt_pat called with ((ensures (equiv (>>(c1, c2)) c2)))
is_smt_pat called with ((ensures (let  ((), h_1) = reify (f1 ()) h_0 in let  ((), h'_1) = reify (f2 ()) h_1 in let  ((), h_2) = reify (f2 ()) h_0 in let  ((), h'_2) = reify (f1 ()) h_2 in heap_eq h_0 h'_1 h'_2)))
is_smt_pat called with ((ensures (let  (_, h1) = reify (f ()) h0 in let  (_, h2) = reify (f ()) h1 in heap_eq h0 h1 h2)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.UInt16 (16159 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Util.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.Ghost (1321 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.StrongExcludedMiddle.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: While (6404 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.IO.fsti
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
Verified module: FStar.UInt8 (15214 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.String.fsti
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
Verified module: ProgramOptimizations (16668 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Squash.fsti
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.StrongExcludedMiddle (125 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Option.fsti
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified i'face (or impl+i'face): FStar.String (466 milliseconds)
All verification conditions discharged successfully
Verified module: OTP (2398 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Matrix2.fsti
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Universe.fsti
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified i'face (or impl+i'face): FStar.IO (151 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Float.fsti
Verified i'face (or impl+i'face): FStar.Squash (28 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.BaseTypes.fsti
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Swap (8978 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Char.fsti
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: ElGamal (2696 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperHeap.fst hyperheap/FStar.ST.fst FStar.Util.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
Verified i'face (or impl+i'face): FStar.Option (22 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperStack.fst hyperstack/FStar.ST.fst hyperstack/FStar.All.fst FStar.Monotonic.RRef.fst FStar.Monotonic.Seq.fst
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.Int128 (15121 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperStack.fst hyperstack/FStar.ST.fst FStar.Buffer.fst FStar.Buffer.Quantifiers.fst
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(union s1 s2, union' s1 s2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified i'face (or impl+i'face): FStar.Char (450 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent/_work/1/s/bin/fstar.exe --trace_error --use_hints hyperstack/FStar.ST.fst hyperstack/FStar.All.fst FStar.Struct.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.Int63 (14450 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.OrdSetProps (1518 milliseconds)
All verification conditions discharged successfully
Verified i'face (or impl+i'face): FStar.Universe (22 milliseconds)
All verification conditions discharged successfully
Verified i'face (or impl+i'face): FStar.Float (23 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.Util (58 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: UnionFind.Forest (2468 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (let  (r_1, _) = reify (find uf i_1 h) h in let  (r_2, _) = reify (find uf i_2 h) h in let  (_, d_1, s_1) = sel h (index uf r_1) in let  (_, d_2, s_2) = sel h (index uf r_2) in let  (_, h1) = reify (merge uf i_1 i_2) h in ==>(<>(r_1, r_2), (/\(/\(==(sel h1 (index uf r_1), ((Prims.Mktuple3 r_2 d_1 s_1))), (==(sel h1 (index uf r_2), ((Prims.Mktuple3 r_2 d_2 elift2 union s_1 s_2))))), (forall j:id n.{:pattern } ==>((/\(<>(j, r_1), <>(j, r_2))), ==(sel h (index uf j), sel h1 (index uf j))))))))))
is_smt_pat called with ((ensures (let  (r_1, _) = reify (find uf i_1 h) h in let  (r_2, _) = reify (find uf i_2 h) h in let  (_, d_1, s_1) = sel h (index uf r_1) in let  (_, d_2, s_2) = sel h (index uf r_2) in let  (_, h1) = reify (merge_opt uf i_1 i_2) h in ==>((/\(<>(r_1, r_2), >=(d_1, d_2))), (/\(/\(==(sel h1 (index uf r_2), ((Prims.Mktuple3 r_1 d_2 s_2))), (let  d_1 = if =(d_1, d_2) then +(d_1, 1) else d_1 in ==(sel h1 (index uf r_1), ((Prims.Mktuple3 r_1 d_1 elift2 union s_1 s_2))))), (forall j:id n.{:pattern } ==>((/\(<>(j, r_1), <>(j, r_2))), ==(sel h (index uf j), sel h1 (index uf j))))))))))
is_smt_pat called with ((ensures (let  (_, h'_1) = reify (merge uf i_1 i_2) h_1 in let  (_, h'_2) = reify (merge uf i_1 i_2) h_2 in (forall j:id n.{:pattern } /\(/\(/\(=(parent uf j h'_1, parent uf j h'_2), ==(subtree uf j h'_1, subtree uf j h'_2)), =(height uf j h'_1, height uf j h_1)), =(height uf j h'_2, height uf j h_2))))))
is_smt_pat called with ((ensures (let  (_, h1) = reify (merge uf i_1 i_2) h in let  (_, h2) = reify (merge_opt uf i_1 i_2) h in <==>((=(fst (reify (find uf j_1 h1) h1), fst (reify (find uf j_2 h1) h1))), (=(fst (reify (find uf j_1 h2) h2), fst (reify (find uf j_2 h2) h2)))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified i'face (or impl+i'face): FStar.Matrix2 (3065 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.Int16 (12089 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.Seq.Properties (44560 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Int.Cast (33472 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: WhileReify (5751 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: FStar.Math.Lemmas (39953 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.HyperStack (16749 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.UInt64 (12034 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified i'face (or impl+i'face): FStar.BaseTypes (22 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
Verified module: FStar.Map (5218 milliseconds)
Verified module: FStar.HyperHeap (17714 milliseconds)
Verified module: FStar.ST (1134 milliseconds)
Verified module: FStar.Util (31 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
Verified module: UnionFind (34803 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
Verified module: ReifyLong (66568 milliseconds)
All verification conditions discharged successfully
unknown(0,0-0,0) :  : (Warning) FStar.Struct: Unexpected output from Z3: (error "line 138346 column 43: unknown constant @x26")

Verified module: FStar.Map (4947 milliseconds)
Verified module: FStar.HyperStack (13918 milliseconds)
Verified module: FStar.ST (10893 milliseconds)
Verified module: FStar.All (46 milliseconds)
Verified module: FStar.Monotonic.RRef (1302 milliseconds)
Verified module: FStar.Monotonic.Seq (14292 milliseconds)
All verification conditions discharged successfully
Verified module: UnionFind.Functions (57644 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/rel'
Verified module: FStar.UInt (94704 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.ST (11700 milliseconds)
Verified module: FStar.All (53 milliseconds)
Verified module: FStar.Struct (56246 milliseconds)
All verification conditions discharged successfully
Verified module: StackMachine (370602 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples/metatheory'
make[2]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/examples'
is_smt_pat called with ((ensures (/\(/\(/\(/\(live h0 b, live h0 b'), live h1 b'), (forall i:nat.{:pattern (get h1 b' (+(v bi', i)))} ==>(<(i, v len), ==(get h1 b' (+(v bi', i)), get h0 b (+(v bi, i)))))), (forall i:nat.{:pattern (get h1 b' i)} ==>((\/((/\(>=(i, +(v bi', v len)), <(i, length b'))), <(i, v bi'))), ==(get h1 b' i, get h0 b' i)))))))
Verified module: FStar.Map (5404 milliseconds)
Verified module: FStar.HyperStack (16688 milliseconds)
Verified module: FStar.ST (12736 milliseconds)
Verified module: FStar.Buffer (169189 milliseconds)
Verified module: FStar.Buffer.Quantifiers (5074 milliseconds)
All verification conditions discharged successfully
make[2]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/ulib'
make[1]: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
make: Leaving directory '/cygdrive/c/Build/Agent/_work/1/s/src'
