This is /home/everbld/everest-ci/ci
Working directory: /cygdrive/c/Build/Agent2/_work/1/s
About to run: make -C src utest -j 24 -k
BUILD_SOURCEBRANCHNAME: cpitclaudel_refactored_errors
BUILD_DEFINITIONNAME: FStar-CI-Windows
make: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make all
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make[1]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
VS/.nuget/NuGet.exe restore VS/FStar.sln
Installing 'FsLexYacc 6.1.0'.
Installing 'FsLexYacc.Runtime 6.1.0'.
Successfully installed 'FsLexYacc.Runtime 6.1.0'.
Successfully installed 'FsLexYacc 6.1.0'.
make -C VS install-packages
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/VS'
[ -d packages ] || make update-nuget
.nuget/NuGet.exe restore FStar.sln
All packages listed in packages.config are already installed.
find packages -name '*.exe' -exec chmod +x '{}' ';'
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/VS'
"C:/Program Files (x86)/MSBuild/14.0/bin/amd64/"/MSBuild.exe /verbosity:minimal /p:Configuration=Release VS/FStar.sln
Microsoft (R) Build Engine version 14.0.25420.1
Copyright (C) Microsoft Corporation. All rights reserved.

basic -> C:\Build\Agent2\_work\1\s\bin\basic.dll
Restoring NuGet packages...
To prevent NuGet from downloading packages during build, open the Visual Studio Options dialog, click on the Package Manager node and uncheck 'Allow NuGet to download missing packages'.
All packages listed in packages.config are already installed.
prettyprint -> C:\Build\Agent2\_work\1\s\bin\prettyprint.dll
syntax -> C:\Build\Agent2\_work\1\s\bin\syntax.dll
compiling to dfas (can take a while...)
339 states
writing output
building tables
computing first function...time: 00:00:00.2274026
building kernels...time: 00:00:00.1551397
building kernel table...time: 00:00:00.0188910
computing lookahead relations..............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................time: 00:00:00.5266339
building lookahead table...time: 00:00:00.2719668
building action table...state 406: shift/reduce error on SEMICOLON
state 412: shift/reduce error on BY
state 434: shift/reduce error on BAR
state 437: shift/reduce error on LBRACE
state 438: shift/reduce error on BAR
state 449: shift/reduce error on BAR
state 525: shift/reduce error on COLON_EQUALS
state 561: shift/reduce error on LBRACE
time: 00:00:00.7730016
building goto table...time: 00:00:00.2207294
returning tables.
8 shift/reduce conflicts
715 states
137 nonterminals
138 terminals
386 productions
#rows in action table: 715
parser -> C:\Build\Agent2\_work\1\s\bin\parser.dll
typechecker -> C:\Build\Agent2\_work\1\s\bin\typechecker.dll
format -> C:\Build\Agent2\_work\1\s\bin\format.dll
extraction -> C:\Build\Agent2\_work\1\s\bin\extraction.dll
fsdoc -> C:\Build\Agent2\_work\1\s\bin\fsdoc.dll
smtencoding -> C:\Build\Agent2\_work\1\s\bin\smtencoding.dll
tactics -> C:\Build\Agent2\_work\1\s\src\tactics\bin\Release\tactics.dll
tosyntax -> C:\Build\Agent2\_work\1\s\bin\tosyntax.dll
fstar -> C:\Build\Agent2\_work\1\s\bin\fstar.exe
C:\Build\Agent2\_work\1\s\src\tests\tactics.fs(53,19): warning FS0040: This and other recursive references to the object(s) being defined will be checked for initialization-soundness at runtime through the use of a delayed reference. This is because you are defining one or more recursive objects, rather than recursive functions. This warning may be suppressed by using '#nowarn "40"' or '--nowarn:40'. [C:\Build\Agent2\_work\1\s\src\tests\tests.fsproj]
tests -> C:\Build\Agent2\_work\1\s\bin\tests.exe
chmod a+x ../bin/tests.exe
chmod a+x ../bin/fstar.exe
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make fsharp-regressions #normalizer failures on linux so only run on windows
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make[1]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
../bin/tests.exe
Initializing ...
Goal is (l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0))))))))
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun x -> (l_imp (eq2 x@0 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x@1 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x@1 z@0)))))))), rest=):
TAC>> intros
intros: x
TAC (ngoals=1, maingoal=(l_imp (eq2 x 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0)))))), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 x 0) (l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0)))))), rest=):
TAC>> imp_intro
imp_intro: uu___#170758
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 x y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 x z@0))))), rest=):
TAC>> rewrite
+++Rewrite uu___#170758 : (eq2 x 0)
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_and (l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) (l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))), rest=):
TAC>> split
TAC (ngoals=2, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))):
TAC>> debug
TAC (ngoals=2, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0))))):
TAC>> map
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun y -> (l_imp (eq2 y@0 0) (eq2 0 y@0)))), rest=):
TAC>> intros
intros: y
TAC (ngoals=1, maingoal=(l_imp (eq2 y 0) (eq2 0 y)), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 y 0) (eq2 0 y)), rest=):
TAC>> imp_intro
imp_intro: uu___#170762
TAC (ngoals=1, maingoal=(eq2 0 y), rest=):
TAC>> rewrite
+++Rewrite uu___#170762 : (eq2 y 0)
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying simplify_eq_impl
(eq2 0 0) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying trivial
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting y#170761
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is x |- l_True
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> map
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> or_else: trying simplify_eq_impl
(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(l_Forall (fun z -> (l_imp (eq2 z@0 0) (eq2 0 z@0)))), rest=):
TAC>> intros
intros: z
TAC (ngoals=1, maingoal=(l_imp (eq2 z 0) (eq2 0 z)), rest=):
TAC>> or_else: trying simplify_eq_impl
TAC (ngoals=1, maingoal=(l_imp (eq2 z 0) (eq2 0 z)), rest=):
TAC>> imp_intro
imp_intro: uu___#170766
TAC (ngoals=1, maingoal=(eq2 0 z), rest=):
TAC>> rewrite
+++Rewrite uu___#170766 : (eq2 z 0)
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> clear
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying simplify_eq_impl
(eq2 0 0) is not an equality imp
>>>>>Not an equality implication
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: simplify_eq_impl failed; trying visit_strengthen_else
TAC (ngoals=1, maingoal=(eq2 0 0), rest=):
TAC>> or_else: trying trivial
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting z#170765
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is x |- l_True
TAC (ngoals=2, maingoal=l_True, rest=l_True):
TAC>> merge_sub_goals
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> revert
reverting x#170757
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear_hd
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> clear
TAC (ngoals=1, maingoal=l_True, rest=):
TAC>> inner
After reverting intros, goal is  |- l_True
Goal: l_True
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make -C ocaml-output
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
cp "../extraction/ml/FStar_Extraction_ML_PrintML_4.02.3.ml" ../extraction/ml/FStar_Extraction_ML_PrintML.ml
# TODO : call menhir directly when positions are fixed instead of
# letting OCamlbuild go through ocamlyacc
menhir  --only-preprocess-for-ocamlyacc ../parser/parse.mly > parse.mly
Warning: you are using the standard library and/or the %inline keyword. We
recommend switching on --infer in order to avoid obscure type error messages.
warning: CRLF will be replaced by LF in src/parser/parse.fsi.
The file will have its original line endings in your working directory.
# Save a copy of the dumb parse.mly for whoever doesn't have menhir.
echo 'let dummy () = ();;' > FStar_Version.ml
cp parse.mly ../parser/ml/
echo 'FStar_Options._version := "0.9.4.2";;' >> FStar_Version.ml
echo "%{" > ../parser/parse.fsy
# We are opening the same module twice but we need these modules
echo 'FStar_Options._platform := "Windows_x64";;' >> FStar_Version.ml
echo "#light \"off\"" >> ../parser/parse.fsy
# open for the definition of tokens
echo 'FStar_Options._compiler := "OCaml 4.02.3";;' >> FStar_Version.ml
echo "// (c) Microsoft Corporation. All rights reserved" >> ../parser/parse.fsy
echo "open Prims" > FStar_Parser_Parse.ml
echo 'FStar_Options._date := "2017-04-10T06:33:25-07:00";;' >> FStar_Version.ml
echo "open Prims" >> ../parser/parse.fsy
echo "open FStar_Errors" >> FStar_Parser_Parse.ml
echo 'FStar_Options._commit:= "5bf7683 (dirty)";;' >> FStar_Version.ml
echo "open FStar.Errors" >> ../parser/parse.fsy
echo "open FStar_List" >> FStar_Parser_Parse.ml
echo "open FStar.List" >> ../parser/parse.fsy
echo "open FStar_Util" >> FStar_Parser_Parse.ml
echo "open FStar_Range" >> FStar_Parser_Parse.ml
echo "open FStar.Util" >> ../parser/parse.fsy
echo "open FStar_Options" >> FStar_Parser_Parse.ml
echo "open FStar.Range" >> ../parser/parse.fsy
echo "open FStar_Syntax_Syntax" >> FStar_Parser_Parse.ml
echo "open FStar.Options" >> ../parser/parse.fsy
echo "open FStar_Syntax_Const" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Syntax" >> ../parser/parse.fsy
echo "open FStar_Syntax_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Const" >> ../parser/parse.fsy
echo "open FStar_Parser_AST" >> FStar_Parser_Parse.ml
echo "open FStar.Syntax.Util" >> ../parser/parse.fsy
echo "open FStar_Parser_Util" >> FStar_Parser_Parse.ml
echo "open FStar.Parser.AST" >> ../parser/parse.fsy
echo "open FStar_Const" >> FStar_Parser_Parse.ml
echo "open FStar.Parser.Util" >> ../parser/parse.fsy
echo "open FStar_Ident" >> FStar_Parser_Parse.ml
echo "open FStar.Const" >> ../parser/parse.fsy
echo "open FStar.Ident" >> ../parser/parse.fsy
echo "open FStar_String" >> FStar_Parser_Parse.ml
echo "open FStar.String" >> ../parser/parse.fsy
# TODO: create a proper OCamlbuild rule for this production so that
# TODO : fsyacc seems to complain as soon as there is an arrow -> in a %type declaration...
# OCamlbuild knows how to generate parse.mly first (possibly using
cat parse.mly | sed -e '/%{/d' \
-e '/^open /d' \
-e '/%token/s/[a-zA-Z0-9_]*\.//g' \
-e '/%type/s/[a-zA-Z0-9_]*\.//g' \
-e '/%token.*->.*/d' \
-e '/%type.*->.*/d' \
>> ../parser/parse.fsy
# menhir) and removes the production as needed.
ocamlyacc parse.mly
7 shift/reduce conflicts.
cat parse.ml >> FStar_Parser_Parse.ml
rm parse.ml parse.mli
cd ../../ && ocamlbuild -cflag '-g' -I src/ocaml-output -I src/basic/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -j 24 -build-dir src/ocaml-output/_build -I src/prettyprint/ml -I src/ocaml-output/bootlibs -use-ocamlfind main.native
mkdir 'C:\Build\Agent2\_work\1\s\src/ocaml-output/_build'
mkdir src
mkdir src/fstar
mkdir src/fstar/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/fstar/ml/main.ml > src/fstar/ml/main.ml.depends
mkdir src/ocaml-output
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Main.ml > src/ocaml-output/FStar_Main.ml.depends
mkdir src/ocaml-output/bootlibs
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_All.ml > src/ocaml-output/bootlibs/FStar_All.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Common.ml > src/ocaml-output/FStar_Common.ml.depends
mkdir src/basic
mkdir src/basic/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Util.ml > src/basic/ml/FStar_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_List.ml > src/ocaml-output/bootlibs/FStar_List.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/prims.ml > src/ocaml-output/bootlibs/prims.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/MkPrims.ml > src/ocaml-output/bootlibs/MkPrims.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/MkPrims.cmo src/ocaml-output/bootlibs/MkPrims.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_List.cmo src/ocaml-output/bootlibs/FStar_List.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/prims.cmo src/ocaml-output/bootlibs/prims.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Util.cmo src/basic/ml/FStar_Util.ml
File "src/basic/ml/FStar_Util.ml", line 47, characters 57-65:
Warning 40: st_mtime was selected from type BatUnix.stats.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/basic/ml/FStar_Util.ml", line 659, characters 2-13:
Warning 10: this expression should have type unit.
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Dependencies.ml > src/ocaml-output/FStar_Dependencies.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_All.cmo src/ocaml-output/bootlibs/FStar_All.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Options.ml > src/ocaml-output/FStar_Options.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_BaseTypes.ml > src/ocaml-output/bootlibs/FStar_BaseTypes.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Char.ml > src/ocaml-output/bootlibs/FStar_Char.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Float.ml > src/ocaml-output/bootlibs/FStar_Float.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int16.ml > src/ocaml-output/bootlibs/FStar_Int16.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int32.ml > src/ocaml-output/bootlibs/FStar_Int32.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int64.ml > src/ocaml-output/bootlibs/FStar_Int64.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Int8.ml > src/ocaml-output/bootlibs/FStar_Int8.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_UInt16.ml > src/ocaml-output/bootlibs/FStar_UInt16.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_UInt8.ml > src/ocaml-output/bootlibs/FStar_UInt8.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Char.cmo src/ocaml-output/bootlibs/FStar_Char.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Float.cmo src/ocaml-output/bootlibs/FStar_Float.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int16.cmo src/ocaml-output/bootlibs/FStar_Int16.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int32.cmo src/ocaml-output/bootlibs/FStar_Int32.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int64.cmo src/ocaml-output/bootlibs/FStar_Int64.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int8.cmo src/ocaml-output/bootlibs/FStar_Int8.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt16.cmo src/ocaml-output/bootlibs/FStar_UInt16.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt8.cmo src/ocaml-output/bootlibs/FStar_UInt8.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Getopt.ml > src/basic/ml/FStar_Getopt.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Platform.ml > src/basic/ml/FStar_Platform.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_ST.ml > src/ocaml-output/bootlibs/FStar_ST.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_String.ml > src/ocaml-output/bootlibs/FStar_String.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_BaseTypes.cmo src/ocaml-output/bootlibs/FStar_BaseTypes.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Getopt.cmo src/basic/ml/FStar_Getopt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Platform.cmo src/basic/ml/FStar_Platform.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_ST.cmo src/ocaml-output/bootlibs/FStar_ST.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_String.cmo src/ocaml-output/bootlibs/FStar_String.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Dep.ml > src/ocaml-output/FStar_Parser_Dep.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmo src/ocaml-output/FStar_Common.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Const.ml > src/ocaml-output/FStar_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Ident.ml > src/ocaml-output/FStar_Ident.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Range.ml > src/basic/ml/FStar_Range.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Range.cmo src/basic/ml/FStar_Range.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmo src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Errors.ml > src/ocaml-output/FStar_Errors.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmo src/ocaml-output/FStar_Options.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_AST.ml > src/ocaml-output/FStar_Parser_AST.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmo src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmo src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Const.ml > src/ocaml-output/FStar_Syntax_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Syntax.ml > src/ocaml-output/FStar_Syntax_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Unionfind.ml > src/basic/ml/FStar_Unionfind.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Unionfind.cmo src/basic/ml/FStar_Unionfind.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmo src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Print.ml > src/ocaml-output/FStar_Syntax_Print.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmo src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Subst.ml > src/ocaml-output/FStar_Syntax_Subst.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/bootlibs/FStar_Option.ml > src/ocaml-output/bootlibs/FStar_Option.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Option.cmo src/ocaml-output/bootlibs/FStar_Option.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Util.ml > src/ocaml-output/FStar_Syntax_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_InstFV.ml > src/ocaml-output/FStar_Syntax_InstFV.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmo src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmo src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmo src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmo src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Driver.ml > src/ocaml-output/FStar_Parser_Driver.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmo src/ocaml-output/FStar_Parser_AST.ml
mkdir src/parser
mkdir src/parser/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_ParseIt.ml > src/parser/ml/FStar_Parser_ParseIt.ml.depends
''ocamllex.opt -q src/parser/ml/FStar_Parser_LexFStar.mll
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_LexFStar.ml > src/parser/ml/FStar_Parser_LexFStar.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Parse.ml > src/ocaml-output/FStar_Parser_Parse.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/parser/ml/FStar_Parser_Util.ml > src/parser/ml/FStar_Parser_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_Util.cmo src/parser/ml/FStar_Parser_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmo src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmo src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmo src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmo src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmo src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_Kremlin.ml > src/ocaml-output/FStar_Extraction_Kremlin.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Code.ml > src/ocaml-output/FStar_Extraction_ML_Code.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/basic/ml/FStar_Bytes.ml > src/basic/ml/FStar_Bytes.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Syntax.ml > src/ocaml-output/FStar_Extraction_ML_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Util.ml > src/ocaml-output/FStar_Extraction_ML_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmo src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_UEnv.ml > src/ocaml-output/FStar_Extraction_ML_UEnv.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Env.ml > src/ocaml-output/FStar_TypeChecker_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Free.ml > src/ocaml-output/FStar_Syntax_Free.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Common.ml > src/ocaml-output/FStar_TypeChecker_Common.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmo src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmo src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmo src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmo src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Format.ml > src/ocaml-output/FStar_Format.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Bytes.cmo src/basic/ml/FStar_Bytes.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmo src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmo src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmo src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Modul.ml > src/ocaml-output/FStar_Extraction_ML_Modul.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Term.ml > src/ocaml-output/FStar_Extraction_ML_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Normalize.ml > src/ocaml-output/FStar_TypeChecker_Normalize.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcTerm.ml > src/ocaml-output/FStar_TypeChecker_TcTerm.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Err.ml > src/ocaml-output/FStar_TypeChecker_Err.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmo src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Rel.ml > src/ocaml-output/FStar_TypeChecker_Rel.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmo src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Util.ml > src/ocaml-output/FStar_TypeChecker_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmo src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmo src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmo src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmo src/ocaml-output/FStar_Extraction_ML_Term.ml
mkdir src/extraction
mkdir src/extraction/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/extraction/ml/FStar_Extraction_ML_PrintML.ml > src/extraction/ml/FStar_Extraction_ML_PrintML.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Fsdoc_Generator.ml > src/ocaml-output/FStar_Fsdoc_Generator.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Indent.ml > src/ocaml-output/FStar_Indent.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_ToDocument.ml > src/ocaml-output/FStar_Parser_ToDocument.ml.depends
mkdir src/prettyprint
mkdir src/prettyprint/ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/prettyprint/ml/FStar_Pprint.ml > src/prettyprint/ml/FStar_Pprint.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/prettyprint/ml -I src/ocaml-output -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/prettyprint/ml/FStar_Pprint.cmo src/prettyprint/ml/FStar_Pprint.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmo src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Interactive.ml > src/ocaml-output/FStar_Interactive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmo src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Solver.ml > src/ocaml-output/FStar_SMTEncoding_Solver.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Encode.ml > src/ocaml-output/FStar_SMTEncoding_Encode.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml > src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Term.ml > src/ocaml-output/FStar_SMTEncoding_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Util.ml > src/ocaml-output/FStar_SMTEncoding_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmo src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Z3.ml > src/ocaml-output/FStar_SMTEncoding_Z3.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmo src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmo src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmo src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmo src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_Env.ml > src/ocaml-output/FStar_ToSyntax_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Universal.ml > src/ocaml-output/FStar_Universal.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Interleave.ml > src/ocaml-output/FStar_Parser_Interleave.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmo src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Interpreter.ml > src/ocaml-output/FStar_Tactics_Interpreter.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Basic.ml > src/ocaml-output/FStar_Tactics_Basic.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Embedding.ml > src/ocaml-output/FStar_Tactics_Embedding.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmo src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmo src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmo src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_ToSyntax.ml > src/ocaml-output/FStar_ToSyntax_ToSyntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_MutRecTy.ml > src/ocaml-output/FStar_Syntax_MutRecTy.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmo src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Tc.ml > src/ocaml-output/FStar_TypeChecker_Tc.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_DMFF.ml > src/ocaml-output/FStar_TypeChecker_DMFF.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcInductive.ml > src/ocaml-output/FStar_TypeChecker_TcInductive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmo src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmo src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmo src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmo src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmo src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmo src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmo src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Version.ml > src/ocaml-output/FStar_Version.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmo src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmo src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmo src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmo src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmo src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmo src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmo src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmo src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmo src/fstar/ml/main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/MkPrims.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/FStar_List.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/prims.cmx src/ocaml-output/bootlibs/prims.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Util.ml
File "src/basic/ml/FStar_Util.ml", line 47, characters 57-65:
Warning 40: st_mtime was selected from type BatUnix.stats.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/basic/ml/FStar_Util.ml", line 659, characters 2-13:
Warning 10: this expression should have type unit.
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_All.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Char.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Float.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int16.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int32.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int64.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_Int8.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt16.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_UInt8.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Getopt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Platform.cmx src/basic/ml/FStar_Platform.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_ST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/bootlibs/FStar_String.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Range.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Options.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Unionfind.cmx src/basic/ml/FStar_Unionfind.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output/bootlibs -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/bootlibs/FStar_Option.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmx src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_Util.cmx src/parser/ml/FStar_Parser_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmx src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmx src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/basic/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -o src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Bytes.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmx src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/prettyprint/ml -I src/ocaml-output -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/prettyprint/ml/FStar_Pprint.cmx src/prettyprint/ml/FStar_Pprint.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmx src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmx src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmx src/fstar/ml/main.ml
''ocamlfind ocamlopt -linkpkg -thread -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/prims.cmx src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Platform.cmx src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Unionfind.cmx src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Extraction_ML_Code.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Parser_AST.cmx src/parser/ml/FStar_Parser_Util.cmx src/ocaml-output/FStar_Parser_Parse.cmx src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_ParseIt.cmx src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Fsdoc_Generator.cmx src/prettyprint/ml/FStar_Pprint.cmx src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Main.cmx src/fstar/ml/main.cmx -o src/fstar/ml/main.native
# Parallel statistics: { count(total): 18(200), max: 8, min: 2, average(total): 3.889(1.260) }
cp _build/src/fstar/ml/main.native ../../bin/fstar.exe
cp _build/src/fstar/ml/main.native ../../bin/fstar.ocaml
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
make fstar-ocaml
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make ocaml
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
rm -rf boot_fstis u_boot_fsts u_ocaml-output
mkdir boot_fstis u_boot_fsts u_ocaml-output
make prep
make[3]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
cp basic/string.fsi boot_fstis/FStar.string.fsti
cp basic/list.fsi boot_fstis/FStar.list.fst
sed -i 's/open Prims/module ALL_TEMP = FStar.All/g' boot_fstis/FStar.list.fst
sed -i 's/<.* when .* : equality>//g' boot_fstis/FStar.list.fst
sed -i 's/val/assume val/g' boot_fstis/FStar.list.fst
cp basic/util.fsi boot_fstis/FStar.util.fsti
sed -i 's/open System.IO/module ALL_TMP = FStar.All/g' boot_fstis/FStar.util.fsti
sed -i 's/type time.*/assume new type time/g'  boot_fstis/FStar.util.fsti
sed -i 's/type smap.*/assume new type smap : Type0 -> Type0/g'  boot_fstis/FStar.util.fsti
sed -i 's/type imap.*/assume new type imap : Type0 -> Type0/g'  boot_fstis/FStar.util.fsti
sed -i 's/type out_channel.*/assume new type out_channel/g'  boot_fstis/FStar.util.fsti
sed -i 's/type file_handle.*/assume new type file_handle/g'  boot_fstis/FStar.util.fsti
sed -i 's/type stream_reader.*/assume new type stream_reader/g'  boot_fstis/FStar.util.fsti
sed -i 's/type string_builder.*/assume new type string_builder/g'  boot_fstis/FStar.util.fsti
sed -i 's/type proc.*/assume new type proc/g' boot_fstis/FStar.util.fsti
sed -i 's/type set.*/assume new type set:Type0 -> Type0/g' boot_fstis/FStar.util.fsti
cp basic/platform.fsi boot_fstis/FStar.platform.fsti
cp basic/bytes.fsti boot_fstis/FStar.bytes.fst
cp basic/range.fsi boot_fstis/FStar.range.fsti
cp basic/version.fsi boot_fstis/FStar.version.fsti
cp basic/getopt.fsi boot_fstis/FStar.getopt.fsti
cp basic/unionfind.fsi boot_fstis/FStar.unionfind.fsti
sed -i 's/type pa_t.*/module ALL_TMP = FStar.All/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/and data.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| PArray.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| PDiff.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type puf_t.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type puf.*/assume new type puf : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type p_uvar.*/assume new type p_uvar : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type cell.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/and contents.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| Data.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/.*| Fwd.*//g' boot_fstis/FStar.unionfind.fsti
sed -i 's/type uvar.*/assume new type uvar : Type0 -> Type0/g' boot_fstis/FStar.unionfind.fsti
cp prettyprint/prettyprint.fsi boot_fstis/FStar.Pprint.fsti
echo "#light \"off\"" > boot_fstis/FStar.Parser.Parse.fsti
head -n -12 parser/parse.fsi >> boot_fstis/FStar.Parser.Parse.fsti
sed -i 's/module FStar.Parser.Parse/module FStar.Parser.Parse\nopen FStar.All\nopen FStar.BaseTypes\ntype bytes = array<byte>\nopen FStar.Syntax.Syntax/' boot_fstis/FStar.Parser.Parse.fsti
make rename_as_fst
make[4]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
./tools/rename_all_boot_fsts
[rename_all_boot_fsts]: copying ./basic/FStar.Common.fs to u_boot_fsts/FStar.Common.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Const.fs to u_boot_fsts/FStar.Const.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Errors.fs to u_boot_fsts/FStar.Errors.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Ident.fs to u_boot_fsts/FStar.Ident.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Options.fs to u_boot_fsts/FStar.Options.fst
[rename_all_boot_fsts]: copying ./basic/FStar.Options.fsi to u_boot_fsts/FStar.Options.fsti
./boot_fstis/FStar.bytes.fst is unrecognized
./boot_fstis/FStar.getopt.fsti is unrecognized
./boot_fstis/FStar.list.fst is unrecognized
./boot_fstis/FStar.Parser.Parse.fsti is unrecognized
./boot_fstis/FStar.platform.fsti is unrecognized
./boot_fstis/FStar.Pprint.fsti is unrecognized
./boot_fstis/FStar.range.fsti is unrecognized
./boot_fstis/FStar.string.fsti is unrecognized
./boot_fstis/FStar.unionfind.fsti is unrecognized
./boot_fstis/FStar.util.fsti is unrecognized
./boot_fstis/FStar.version.fsti is unrecognized
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.Kremlin.fs to u_boot_fsts/FStar.Extraction.Kremlin.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Code.fs to u_boot_fsts/FStar.Extraction.ML.Code.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Code.fsi to u_boot_fsts/FStar.Extraction.ML.Code.fsti
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Modul.fs to u_boot_fsts/FStar.Extraction.ML.Modul.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.PrintML.fs to u_boot_fsts/FStar.Extraction.ML.PrintML.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.PrintML.fsi to u_boot_fsts/FStar.Extraction.ML.PrintML.fsti
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Syntax.fs to u_boot_fsts/FStar.Extraction.ML.Syntax.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Term.fs to u_boot_fsts/FStar.Extraction.ML.Term.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.UEnv.fs to u_boot_fsts/FStar.Extraction.ML.UEnv.fst
[rename_all_boot_fsts]: copying ./extraction/FStar.Extraction.ML.Util.fs to u_boot_fsts/FStar.Extraction.ML.Util.fst
[rename_all_boot_fsts]: copying ./format/FStar.Format.fs to u_boot_fsts/FStar.Format.fst
[rename_all_boot_fsts]: copying ./fsdoc/FStar.Fsdoc.Generator.fs to u_boot_fsts/FStar.Fsdoc.Generator.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Dependencies.fs to u_boot_fsts/FStar.Dependencies.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Indent.fs to u_boot_fsts/FStar.Indent.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Interactive.fs to u_boot_fsts/FStar.Interactive.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Main.fs to u_boot_fsts/FStar.Main.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Top.fs to u_boot_fsts/FStar.Top.fst
[rename_all_boot_fsts]: copying ./fstar/FStar.Universal.fs to u_boot_fsts/FStar.Universal.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.AST.fs to u_boot_fsts/FStar.Parser.AST.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Dep.fs to u_boot_fsts/FStar.Parser.Dep.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Dep.fsi to u_boot_fsts/FStar.Parser.Dep.fsti
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Driver.fs to u_boot_fsts/FStar.Parser.Driver.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Interleave.fs to u_boot_fsts/FStar.Parser.Interleave.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.Lexhelp.fs to u_boot_fsts/FStar.Parser.Lexhelp.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.ToDocument.fs to u_boot_fsts/FStar.Parser.ToDocument.fst
[rename_all_boot_fsts]: copying ./parser/FStar.Parser.ToDocument.fsi to u_boot_fsts/FStar.Parser.ToDocument.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Encode.fs to u_boot_fsts/FStar.SMTEncoding.Encode.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Encode.fsi to u_boot_fsts/FStar.SMTEncoding.Encode.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.ErrorReporting.fs to u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.ErrorReporting.fsi to u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Solver.fs to u_boot_fsts/FStar.SMTEncoding.Solver.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Solver.fsi to u_boot_fsts/FStar.SMTEncoding.Solver.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.SplitQueryCases.fs to u_boot_fsts/FStar.SMTEncoding.SplitQueryCases.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Term.fs to u_boot_fsts/FStar.SMTEncoding.Term.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Term.fsi to u_boot_fsts/FStar.SMTEncoding.Term.fsti
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Util.fs to u_boot_fsts/FStar.SMTEncoding.Util.fst
[rename_all_boot_fsts]: copying ./smtencoding/FStar.SMTEncoding.Z3.fs to u_boot_fsts/FStar.SMTEncoding.Z3.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Const.fs to u_boot_fsts/FStar.Syntax.Const.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Free.fs to u_boot_fsts/FStar.Syntax.Free.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Free.fsi to u_boot_fsts/FStar.Syntax.Free.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.InstFV.fs to u_boot_fsts/FStar.Syntax.InstFV.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.InstFV.fsi to u_boot_fsts/FStar.Syntax.InstFV.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.MutRecTy.fs to u_boot_fsts/FStar.Syntax.MutRecTy.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.MutRecTy.fsi to u_boot_fsts/FStar.Syntax.MutRecTy.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Print.fs to u_boot_fsts/FStar.Syntax.Print.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Print.fsi to u_boot_fsts/FStar.Syntax.Print.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Subst.fs to u_boot_fsts/FStar.Syntax.Subst.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Subst.fsi to u_boot_fsts/FStar.Syntax.Subst.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Syntax.fs to u_boot_fsts/FStar.Syntax.Syntax.fst
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Syntax.fsi to u_boot_fsts/FStar.Syntax.Syntax.fsti
[rename_all_boot_fsts]: copying ./syntax/FStar.Syntax.Util.fs to u_boot_fsts/FStar.Syntax.Util.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Basic.fs to u_boot_fsts/FStar.Tactics.Basic.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Embedding.fs to u_boot_fsts/FStar.Tactics.Embedding.fst
[rename_all_boot_fsts]: copying ./tactics/FStar.Tactics.Interpreter.fs to u_boot_fsts/FStar.Tactics.Interpreter.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.Env.fs to u_boot_fsts/FStar.ToSyntax.Env.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.Env.fsi to u_boot_fsts/FStar.ToSyntax.Env.fsti
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.ToSyntax.fs to u_boot_fsts/FStar.ToSyntax.ToSyntax.fst
[rename_all_boot_fsts]: copying ./tosyntax/FStar.ToSyntax.ToSyntax.fsi to u_boot_fsts/FStar.ToSyntax.ToSyntax.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Common.fs to u_boot_fsts/FStar.TypeChecker.Common.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.DMFF.fs to u_boot_fsts/FStar.TypeChecker.DMFF.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.DMFF.fsi to u_boot_fsts/FStar.TypeChecker.DMFF.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Env.fs to u_boot_fsts/FStar.TypeChecker.Env.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Env.fsi to u_boot_fsts/FStar.TypeChecker.Env.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Err.fs to u_boot_fsts/FStar.TypeChecker.Err.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Normalize.fs to u_boot_fsts/FStar.TypeChecker.Normalize.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Normalize.fsi to u_boot_fsts/FStar.TypeChecker.Normalize.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Rel.fs to u_boot_fsts/FStar.TypeChecker.Rel.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Rel.fsi to u_boot_fsts/FStar.TypeChecker.Rel.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Tc.fs to u_boot_fsts/FStar.TypeChecker.Tc.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Tc.fsi to u_boot_fsts/FStar.TypeChecker.Tc.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcInductive.fs to u_boot_fsts/FStar.TypeChecker.TcInductive.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcInductive.fsi to u_boot_fsts/FStar.TypeChecker.TcInductive.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcTerm.fs to u_boot_fsts/FStar.TypeChecker.TcTerm.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.TcTerm.fsi to u_boot_fsts/FStar.TypeChecker.TcTerm.fsti
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Util.fs to u_boot_fsts/FStar.TypeChecker.Util.fst
[rename_all_boot_fsts]: copying ./typechecker/FStar.TypeChecker.Util.fsi to u_boot_fsts/FStar.TypeChecker.Util.fsti
cp parser/parseit.fsi u_boot_fsts/FStar.Parser.Parseit.fsti
make[4]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
#fix up a use of polymorphic recursion in F#, which has a different syntax than F*
sed -i 's/^and unembed_tactic_0.*//g' u_boot_fsts/FStar.Tactics.Interpreter.fst
sed -i 's/^\/\/F\* version: and unembed_tactic_0/and unembed_tactic_0/g' u_boot_fsts/FStar.Tactics.Interpreter.fst
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make u_extract_all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Common.fst u_boot_fsts/FStar.Options.fst u_boot_fsts/FStar.Ident.fst u_boot_fsts/FStar.Errors.fst u_boot_fsts/FStar.Const.fst u_boot_fsts/FStar.Format.fst --extract_module FStar.Common --extract_module FStar.Options --extract_module FStar.Ident --extract_module FStar.Errors --extract_module FStar.Const --extract_module FStar.Format
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Syntax.Syntax.fst u_boot_fsts/FStar.Syntax.Const.fst u_boot_fsts/FStar.Syntax.Subst.fst u_boot_fsts/FStar.Syntax.Free.fst u_boot_fsts/FStar.Syntax.InstFV.fst u_boot_fsts/FStar.Syntax.Util.fst u_boot_fsts/FStar.Syntax.Print.fst u_boot_fsts/FStar.Syntax.MutRecTy.fst u_boot_fsts/FStar.Fsdoc.Generator.fst --extract_namespace FStar.Syntax --extract_namespace FStar.Fsdoc
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Parser.AST.fst u_boot_fsts/FStar.Parser.Interleave.fst u_boot_fsts/FStar.Parser.Lexhelp.fst u_boot_fsts/FStar.Parser.Parseit.fsti u_boot_fsts/FStar.Parser.Driver.fst u_boot_fsts/FStar.Parser.Dep.fst u_boot_fsts/FStar.Parser.ToDocument.fst --extract_namespace FStar.Parser
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Common.fst u_boot_fsts/FStar.TypeChecker.Env.fst u_boot_fsts/FStar.TypeChecker.Normalize.fst u_boot_fsts/FStar.TypeChecker.Err.fst --extract_namespace FStar.TypeChecker
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Rel.fst --extract_module FStar.TypeChecker.Rel
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Util.fst --extract_module FStar.TypeChecker.Util
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.DMFF.fst --extract_module FStar.TypeChecker.DMFF
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.TcTerm.fst --extract_module FStar.TypeChecker.TcTerm
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.TcInductive.fst --extract_module FStar.TypeChecker.TcInductive
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.TypeChecker.Tc.fst --extract_module FStar.TypeChecker.Tc
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.ToSyntax.Env.fst u_boot_fsts/FStar.ToSyntax.ToSyntax.fst --extract_namespace FStar.ToSyntax
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Term.fst u_boot_fsts/FStar.SMTEncoding.Util.fst u_boot_fsts/FStar.SMTEncoding.Z3.fst u_boot_fsts/FStar.SMTEncoding.SplitQueryCases.fst u_boot_fsts/FStar.SMTEncoding.ErrorReporting.fst --extract_namespace FStar.SMTEncoding
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Encode.fst --extract_module FStar.SMTEncoding.Encode
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.SMTEncoding.Solver.fst --extract_module FStar.SMTEncoding.Solver
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Extraction.ML.Syntax.fst u_boot_fsts/FStar.Extraction.ML.UEnv.fst u_boot_fsts/FStar.Extraction.ML.Util.fst u_boot_fsts/FStar.Extraction.ML.Code.fst u_boot_fsts/FStar.Extraction.ML.Term.fst u_boot_fsts/FStar.Extraction.ML.Modul.fst u_boot_fsts/FStar.Extraction.Kremlin.fst --extract_namespace FStar.Extraction
# cp tactics/FStar.Tactics.Basic.fs u_boot_fsts/FStar.Tactics.Basic.fst
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Dependencies.fst u_boot_fsts/FStar.Interactive.fst u_boot_fsts/FStar.Universal.fst u_boot_fsts/FStar.Indent.fst u_boot_fsts/FStar.Main.fst --extract_module FStar.Dependencies --extract_module FStar.Interactive --extract_module FStar.Universal --extract_module FStar.Indent --extract_module FStar.Main
# cp tactics/FStar.Tactics.Embedding.fs u_boot_fsts/FStar.Tactics.Embedding.fst
# cp tactics/FStar.Tactics.Interpreter.fs u_boot_fsts/FStar.Tactics.Interpreter.fst
../bin/fstar.exe --trace_error --eager_inference --lax --MLish --no_location_info --odir u_ocaml-output --codegen OCaml --include ../ulib --include u_boot_fsts --include boot_fstis u_boot_fsts/FStar.Tactics.Basic.fst u_boot_fsts/FStar.Tactics.Embedding.fst u_boot_fsts/FStar.Tactics.Interpreter.fst --extract_namespace FStar.Tactics
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with (decreases n)
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Extracted module Common
Extracted module Ident
Extracted module Const
.\u_boot_fsts\FStar.Syntax.Syntax.fst(395,0-395,33): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(445,0-445,48): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(446,0-446,76): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.Syntax.Syntax.fst(497,0-499,38): (Warning) Annotation from val declaration overrides inline type annotation
Extracted module Options
Extracted module Errors
Extracted module Format
All verification conditions discharged successfully
.\u_boot_fsts\FStar.TypeChecker.Env.fst(280,0-284,35): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.TypeChecker.Env.fst(718,0-720,39): (Warning) Annotation from val declaration overrides inline type annotation
.\u_boot_fsts\FStar.TypeChecker.Util.fst(70,0-72,32): (Warning) Annotation from val declaration overrides inline type annotation
Extracted module Basic
Extracted module Embedding
Extracted module Interpreter
All verification conditions discharged successfully
Extracted module TcInductive
All verification conditions discharged successfully
Extracted module Syntax
Extracted module Const
Extracted module Subst
Extracted module InstFV
Extracted module Util
Extracted module Print
C:\Build\Agent2\_work\1\s\src\boot_fstis\FStar.Pprint.fsti(33,0-33,13) (Warning): Adding an implicit 'assume new' qualifier on document
Extracted module Generator
Extracted module Free
Extracted module MutRecTy
All verification conditions discharged successfully
Extracted module Term
Extracted module Z3
Extracted module AST
Extracted module Util
Extracted module Driver
Extracted module ErrorReporting
Extracted module SplitQueryCases
All verification conditions discharged successfully
Extracted module Dep
Extracted module Interleave
Extracted module Lexhelp
Extracted module Common
Extracted module ToDocument
All verification conditions discharged successfully
Extracted module Util
All verification conditions discharged successfully
Extracted module Env
Extracted module Normalize
Extracted module Err
All verification conditions discharged successfully
C:\Build\Agent2\_work\1\s\src\boot_fstis\FStar.Pprint.fsti(33,0-33,13) (Warning): Adding an implicit 'assume new' qualifier on document
Extracted module Syntax
Extracted module UEnv
Extracted module Util
Extracted module Solver
All verification conditions discharged successfully
Extracted module Code
Extracted module DMFF
All verification conditions discharged successfully
Extracted module Kremlin
Extracted module Term
Extracted module Modul
All verification conditions discharged successfully
Extracted module Tc
All verification conditions discharged successfully
Extracted module Dependencies
Extracted module Indent
Extracted module Env
Extracted module Universal
Extracted module Interactive
Extracted module ToSyntax
Extracted module Main
All verification conditions discharged successfully
All verification conditions discharged successfully
Extracted module TcTerm
All verification conditions discharged successfully
Extracted module Rel
Extracted module Encode
All verification conditions discharged successfully
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
cp u_ocaml-output/*.ml ocaml-output/
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make boot-ocaml
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make -C ocaml-output all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
cp "../extraction/ml/FStar_Extraction_ML_PrintML_4.02.3.ml" ../extraction/ml/FStar_Extraction_ML_PrintML.ml
warning: CRLF will be replaced by LF in src/parser/ml/parse.mly.
The file will have its original line endings in your working directory.
warning: CRLF will be replaced by LF in src/parser/parse.fsi.
The file will have its original line endings in your working directory.
echo 'let dummy () = ();;' > FStar_Version.ml
echo 'FStar_Options._version := "0.9.4.2";;' >> FStar_Version.ml
echo 'FStar_Options._platform := "Windows_x64";;' >> FStar_Version.ml
echo 'FStar_Options._compiler := "OCaml 4.02.3";;' >> FStar_Version.ml
echo 'FStar_Options._date := "2017-04-10T06:36:42-07:00";;' >> FStar_Version.ml
echo 'FStar_Options._commit:= "5bf7683 (dirty)";;' >> FStar_Version.ml
cd ../../ && ocamlbuild -cflag '-g' -I src/ocaml-output -I src/basic/ml -I src/parser/ml -I src/fstar/ml -I src/extraction/ml -j 24 -build-dir src/ocaml-output/_build -I src/prettyprint/ml -I src/ocaml-output/bootlibs -use-ocamlfind main.native
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Main.ml > src/ocaml-output/FStar_Main.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Common.ml > src/ocaml-output/FStar_Common.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Dependencies.ml > src/ocaml-output/FStar_Dependencies.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Options.ml > src/ocaml-output/FStar_Options.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Dep.ml > src/ocaml-output/FStar_Parser_Dep.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmo src/ocaml-output/FStar_Common.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Const.ml > src/ocaml-output/FStar_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Ident.ml > src/ocaml-output/FStar_Ident.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmo src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Errors.ml > src/ocaml-output/FStar_Errors.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmo src/ocaml-output/FStar_Options.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_AST.ml > src/ocaml-output/FStar_Parser_AST.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmo src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmo src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Const.ml > src/ocaml-output/FStar_Syntax_Const.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Syntax.ml > src/ocaml-output/FStar_Syntax_Syntax.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmo src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Print.ml > src/ocaml-output/FStar_Syntax_Print.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmo src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Subst.ml > src/ocaml-output/FStar_Syntax_Subst.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Util.ml > src/ocaml-output/FStar_Syntax_Util.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_InstFV.ml > src/ocaml-output/FStar_Syntax_InstFV.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmo src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmo src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmo src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmo src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Driver.ml > src/ocaml-output/FStar_Parser_Driver.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmo src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmo src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmo src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmo src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmo src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmo src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_Kremlin.ml > src/ocaml-output/FStar_Extraction_Kremlin.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Code.ml > src/ocaml-output/FStar_Extraction_ML_Code.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Syntax.ml > src/ocaml-output/FStar_Extraction_ML_Syntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Util.ml > src/ocaml-output/FStar_Extraction_ML_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmo src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_UEnv.ml > src/ocaml-output/FStar_Extraction_ML_UEnv.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Env.ml > src/ocaml-output/FStar_TypeChecker_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_Free.ml > src/ocaml-output/FStar_Syntax_Free.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Common.ml > src/ocaml-output/FStar_TypeChecker_Common.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmo src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmo src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmo src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmo src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Format.ml > src/ocaml-output/FStar_Format.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmo src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmo src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmo src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Modul.ml > src/ocaml-output/FStar_Extraction_ML_Modul.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Extraction_ML_Term.ml > src/ocaml-output/FStar_Extraction_ML_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Normalize.ml > src/ocaml-output/FStar_TypeChecker_Normalize.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcTerm.ml > src/ocaml-output/FStar_TypeChecker_TcTerm.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Err.ml > src/ocaml-output/FStar_TypeChecker_Err.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmo src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Rel.ml > src/ocaml-output/FStar_TypeChecker_Rel.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmo src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Util.ml > src/ocaml-output/FStar_TypeChecker_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmo src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmo src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmo src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmo src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Fsdoc_Generator.ml > src/ocaml-output/FStar_Fsdoc_Generator.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Indent.ml > src/ocaml-output/FStar_Indent.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_ToDocument.ml > src/ocaml-output/FStar_Parser_ToDocument.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmo src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Interactive.ml > src/ocaml-output/FStar_Interactive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmo src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Solver.ml > src/ocaml-output/FStar_SMTEncoding_Solver.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Encode.ml > src/ocaml-output/FStar_SMTEncoding_Encode.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml > src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Term.ml > src/ocaml-output/FStar_SMTEncoding_Term.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Util.ml > src/ocaml-output/FStar_SMTEncoding_Util.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmo src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_SMTEncoding_Z3.ml > src/ocaml-output/FStar_SMTEncoding_Z3.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmo src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmo src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmo src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmo src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_Env.ml > src/ocaml-output/FStar_ToSyntax_Env.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Universal.ml > src/ocaml-output/FStar_Universal.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Parser_Interleave.ml > src/ocaml-output/FStar_Parser_Interleave.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmo src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Interpreter.ml > src/ocaml-output/FStar_Tactics_Interpreter.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Basic.ml > src/ocaml-output/FStar_Tactics_Basic.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Tactics_Embedding.ml > src/ocaml-output/FStar_Tactics_Embedding.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmo src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmo src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmo src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_ToSyntax_ToSyntax.ml > src/ocaml-output/FStar_ToSyntax_ToSyntax.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Syntax_MutRecTy.ml > src/ocaml-output/FStar_Syntax_MutRecTy.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmo src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_Tc.ml > src/ocaml-output/FStar_TypeChecker_Tc.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_DMFF.ml > src/ocaml-output/FStar_TypeChecker_DMFF.ml.depends
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_TypeChecker_TcInductive.ml > src/ocaml-output/FStar_TypeChecker_TcInductive.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmo src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmo src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmo src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmo src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmo src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmo src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmo src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamldep -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -modules src/ocaml-output/FStar_Version.ml > src/ocaml-output/FStar_Version.ml.depends
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmo src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmo src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmo src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmo src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmo src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmo src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmo src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmo src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlc -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmo src/fstar/ml/main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Ident.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Options.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Errors.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Syntax_Const.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Subst.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_InstFV.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_Syntax_Print.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_AST.cmx src/ocaml-output/FStar_Parser_AST.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Parse.cmx src/ocaml-output/FStar_Parser_Parse.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_LexFStar.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/parser/ml -I src/ocaml-output -I src/prettyprint/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/parser/ml/FStar_Parser_ParseIt.cmx src/parser/ml/FStar_Parser_ParseIt.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Driver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Parser_Dep.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_Free.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Common.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_TypeChecker_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Extraction_ML_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Format.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Code.cmx src/ocaml-output/FStar_Extraction_ML_Code.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Normalize.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Err.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Rel.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Parser_ToDocument.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Dependencies.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Term.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Util.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_Z3.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Encode.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_SMTEncoding_Solver.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Basic.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Embedding.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_Env.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Syntax_MutRecTy.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_DMFF.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_Parser_Interleave.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_Tactics_Interpreter.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_TypeChecker_Tc.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Universal.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_Extraction_Kremlin.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Extraction_ML_Modul.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/extraction/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/basic/ml -o src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Fsdoc_Generator.cmx src/ocaml-output/FStar_Fsdoc_Generator.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Indent.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Interactive.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Version.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/fstar/ml -I src/extraction/ml -I src/basic/ml -o src/ocaml-output/FStar_Main.cmx src/ocaml-output/FStar_Main.ml
''ocamlfind ocamlopt -c -g -annot -bin-annot -thread -w -8-11-21-26-28 -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common -I src/fstar/ml -I src/ocaml-output -I src/prettyprint/ml -I src/parser/ml -I src/ocaml-output/bootlibs -I src/extraction/ml -I src/basic/ml -o src/fstar/ml/main.cmx src/fstar/ml/main.ml
''ocamlfind ocamlopt -linkpkg -thread -package batteries -package zarith -package yojson -package pprint -package compiler-libs -package compiler-libs.common src/ocaml-output/bootlibs/FStar_List.cmx src/ocaml-output/bootlibs/MkPrims.cmx src/ocaml-output/bootlibs/prims.cmx src/basic/ml/FStar_Util.cmx src/basic/ml/FStar_Bytes.cmx src/basic/ml/FStar_Getopt.cmx src/basic/ml/FStar_Platform.cmx src/ocaml-output/bootlibs/FStar_Char.cmx src/ocaml-output/bootlibs/FStar_Float.cmx src/ocaml-output/bootlibs/FStar_Int16.cmx src/ocaml-output/bootlibs/FStar_Int32.cmx src/ocaml-output/bootlibs/FStar_Int64.cmx src/ocaml-output/bootlibs/FStar_Int8.cmx src/ocaml-output/bootlibs/FStar_UInt16.cmx src/ocaml-output/bootlibs/FStar_UInt8.cmx src/ocaml-output/bootlibs/FStar_BaseTypes.cmx src/basic/ml/FStar_Range.cmx src/basic/ml/FStar_Unionfind.cmx src/ocaml-output/bootlibs/FStar_All.cmx src/ocaml-output/bootlibs/FStar_ST.cmx src/ocaml-output/bootlibs/FStar_String.cmx src/ocaml-output/FStar_Ident.cmx src/ocaml-output/FStar_Const.cmx src/ocaml-output/FStar_Options.cmx src/ocaml-output/FStar_Errors.cmx src/ocaml-output/FStar_Syntax_Syntax.cmx src/ocaml-output/FStar_Syntax_Const.cmx src/ocaml-output/FStar_Extraction_ML_Syntax.cmx src/ocaml-output/bootlibs/FStar_Option.cmx src/ocaml-output/FStar_Syntax_Subst.cmx src/ocaml-output/FStar_Syntax_Free.cmx src/ocaml-output/FStar_Syntax_InstFV.cmx src/ocaml-output/FStar_Syntax_Util.cmx src/ocaml-output/FStar_Syntax_Print.cmx src/ocaml-output/FStar_TypeChecker_Common.cmx src/ocaml-output/FStar_TypeChecker_Env.cmx src/ocaml-output/FStar_Extraction_ML_UEnv.cmx src/ocaml-output/FStar_Extraction_ML_Util.cmx src/ocaml-output/FStar_Format.cmx src/ocaml-output/FStar_Extraction_ML_Code.cmx src/extraction/ml/FStar_Extraction_ML_PrintML.cmx src/ocaml-output/FStar_Common.cmx src/ocaml-output/FStar_Parser_AST.cmx src/parser/ml/FStar_Parser_Util.cmx src/ocaml-output/FStar_Parser_Parse.cmx src/parser/ml/FStar_Parser_LexFStar.cmx src/parser/ml/FStar_Parser_ParseIt.cmx src/ocaml-output/FStar_Parser_Driver.cmx src/ocaml-output/FStar_Parser_Dep.cmx src/ocaml-output/FStar_Dependencies.cmx src/ocaml-output/FStar_Extraction_Kremlin.cmx src/ocaml-output/FStar_TypeChecker_Normalize.cmx src/ocaml-output/FStar_TypeChecker_Err.cmx src/ocaml-output/FStar_TypeChecker_Rel.cmx src/ocaml-output/FStar_TypeChecker_Util.cmx src/ocaml-output/FStar_TypeChecker_TcTerm.cmx src/ocaml-output/FStar_Extraction_ML_Term.cmx src/ocaml-output/FStar_Extraction_ML_Modul.cmx src/ocaml-output/FStar_Fsdoc_Generator.cmx src/prettyprint/ml/FStar_Pprint.cmx src/ocaml-output/FStar_Parser_ToDocument.cmx src/ocaml-output/FStar_Indent.cmx src/ocaml-output/FStar_Parser_Interleave.cmx src/ocaml-output/FStar_SMTEncoding_Term.cmx src/ocaml-output/FStar_SMTEncoding_Util.cmx src/ocaml-output/FStar_SMTEncoding_Z3.cmx src/ocaml-output/FStar_SMTEncoding_ErrorReporting.cmx src/ocaml-output/FStar_SMTEncoding_Encode.cmx src/ocaml-output/FStar_SMTEncoding_Solver.cmx src/ocaml-output/FStar_Syntax_MutRecTy.cmx src/ocaml-output/FStar_Tactics_Basic.cmx src/ocaml-output/FStar_Tactics_Embedding.cmx src/ocaml-output/FStar_Tactics_Interpreter.cmx src/ocaml-output/FStar_ToSyntax_Env.cmx src/ocaml-output/FStar_ToSyntax_ToSyntax.cmx src/ocaml-output/FStar_TypeChecker_DMFF.cmx src/ocaml-output/FStar_TypeChecker_TcInductive.cmx src/ocaml-output/FStar_TypeChecker_Tc.cmx src/ocaml-output/FStar_Universal.cmx src/ocaml-output/FStar_Interactive.cmx src/ocaml-output/FStar_Version.cmx src/ocaml-output/FStar_Main.cmx src/fstar/ml/main.cmx -o src/fstar/ml/main.native
# Parallel statistics: { count(total): 12(226), max: 7, min: 2, average(total): 3.167(1.115) }
cp _build/src/fstar/ml/main.native ../../bin/fstar.exe
cp _build/src/fstar/ml/main.native ../../bin/fstar.ocaml
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/ocaml-output'
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make uregressions interactive-test
make[1]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make -C ../ulib
make -C ../examples all
make -C tests/interactive
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib'
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/src/tests/interactive'
for a in transcript-good*; do echo "Checking $a"; cat $a | ../../../bin/fstar-any.sh --in test.fst | tail -n 1 | grep done-ok || exit 1; done
make[2]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples'
make -C bug-reports all
make -C hello all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int.fst
make -C data_structures all
Checking transcript-good-1
make -C algorithms all
make -C crypto all
make -C termination all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bug-reports'
make[3]: Nothing to be done for 'all'.
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bug-reports'
make -C software_foundations all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/hello'
../../bin/fstar.exe --verify_module hello hello.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.ST.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/data_structures'
make -C ../doc/tutorial/code/exercises all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/algorithms'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/crypto'
make -C ../doc/tutorial/code/solutions all
make -C rel all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/termination'
make -C maths all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/software_foundations'
make -C paradoxes all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinaryTrees BinaryTrees.fst
make -C printf all
make -C metatheory all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/exercises'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.TwoLevelHeap.fst
make -C verifythis all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/solutions'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearch BinarySearch.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/rel'
make -C preorders all
make -C dm4free all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 AES.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/maths'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/paradoxes'
make -C incl all
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Simple CPS.Simple.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfBasic SfBasic.fst
make -C struct all
make -C micro-benchmarks all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/metatheory'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/printf'
make -C bytes all
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/verifythis'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/preorders'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/incl'
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/struct'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex01a.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Bijection Bijection.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/dm4free'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Gcd Gcd.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/micro-benchmarks'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex01a.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints PropositionalExtensionalityInconsistent.fst
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bytes'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ParSubst ParSubst.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SimplePrintf SimplePrintf.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints 2015/Problem01.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ImmutableST ImmutableST.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include open.pos --odir open.pos Test.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include point-with-nesting.pos --odir point-with-nesting.pos Test.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.MonadLaws.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Basic Unit1.Basic.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Platform.Bytes Platform.Bytes.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(t1, t2))))
.\hello.fst(5,0-5,37) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Hello (24 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/hello'
make -C tactics all
Verified module: FStar.ST (65 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
make[3]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/tactics'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Tcp.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MetaCoq MetaCoq.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall p1:Type.{:pattern } forall p2:Type.{:pattern } <==>((<==>(p1, p2)), ==(p1, p2)))))
is_smt_pat called with ((ensures (<==>(peq #a p1 p2, ==(p1, p2)))))
is_smt_pat called with ((ensures (==(p1 0, p2 0))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
#done-ok
Checking transcript-good-2
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (bijection f)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Test (22 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include private.pos --odir private.pos Test.fst
Verified module: Bijection (180 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Equivalence Equivalence.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: PropositionalExtensionalityInconsistent (839 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --__no_positivity propImpredicativeAndNonStrictlyPositiveinductives.fst
Verified module: FStar.DM4F.MonadLaws (907 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints Effects.Def.fst
.\Ex01a.fst(68,0-68,48) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
Verified module: Ex01a (509 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex02a.fst
.\Ex01a.fst(58,0-58,48) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
Verified module: Ex01a (667 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex02a.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: ImmutableST (1291 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module AllocST AllocST.fst
Verified module: ParSubst (2338 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcCbvDbPntSubstNoLists StlcCbvDbPntSubstNoLists.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: CPS.Simple (124 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Double CPS.Double.fst
Verified module: Test (23 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.TwoLevelHeap (2069 milliseconds)
All verification conditions discharged successfully
#done-ok
Checking transcript-good-3
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include shadow.pos --odir shadow.pos Test.fst
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Integers.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
Verified module: SimplePrintf (2834 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
Verified module: FStar.Int (4344 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/printf'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcStrongDbParSubst StlcStrongDbParSubst.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcComposeReify IfcComposeReify.fst
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
Verified module: Problem01 (1062 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/verifythis'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include jsonparser.pos --odir jsonparser.pos Test.fst
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures /\(/\((forall a:Type f:m a.{:pattern } ==(bind a a f (return a), f)), (forall a:Type b:Type x:a f:Unidentified product: [a] (Tot (m b)).{:pattern } ==(bind a b (return a x) f, f x))), (forall a:Type b:Type c:Type f:m a g:(Unidentified product: [a] (Tot (m b))) h:(Unidentified product: [b] (Tot (m c))).{:pattern } ==(bind a c f ((fun x -> bind b c (g x) h)), bind b c (bind a b f g) h)))))
is_smt_pat called with ((ensures /\((forall a:Type x:a.{:pattern } ==(lift a (return_m a x), return_n a x)), (forall a:Type b:Type f:m a g:Unidentified product: [a] (Tot (m b)).{:pattern } ==(lift b (bind_m a b f g), bind_n a b (lift a f) ((fun x -> lift b (g x))))))))
is_smt_pat called with ((ensures (let  p = splitTwo s i in =(^(fst p, snd p), s))))
is_smt_pat called with ((ensures =(substringT s i2 n2, substringT (substringT s i n) (-(i2, i)) n2)))
is_smt_pat called with ((ensures <==>(=(String.compare a b, 0), =(a, b))))
is_smt_pat called with ((ensures (/\(=(s1, t1), =(s2, t2)))))
is_smt_pat called with ((ensures <==>(bytes_eq a b, =(a, b))))
is_smt_pat called with ((ensures (/\(=(s1, t1), =(s2, t2)))))
is_smt_pat called with ((ensures (==(x0, x0'))))
is_smt_pat called with ((ensures (==(p, p'))))
is_smt_pat called with ((ensures (~((p0 x0)))))
is_smt_pat called with ((ensures (p0 x0)))
.\Platform.Bytes.fst(15,32-18,29) :  : (Warning) Pattern misses at least one bound variable: uu___#1090
Verified module: Ex02a (160 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex02a (196 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03a.fst
Verified module: Gcd (486 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/maths'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03a.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module IntSort IntSort.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: MetaCoq (1916 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/tactics'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Encrypt_SymEnc.fst
Verified module: PropImpredicativeAndNonStrictlyPositiveInductives (1000 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/paradoxes'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Encrypt_Sample.fst
Verified module: SfBasic (5331 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfLists SfLists.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Effects.Def (1727 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntST.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Test (20 milliseconds)
All verification conditions discharged successfully
Verified module: CPS.Double (100 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include trans.pos --odir trans.pos Test.fst
is_smt_pat called with ((ensures (==>(p, q ()))))
unknown(0,0-0,0) :  : (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: AllocST (1039 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.DoubleLambdaLifting2 CPS.DoubleLambdaLifting2.fst
unknown(0,0-0,0) :  : (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==>(_ (bsearch t a), /\(/\((>=(_ (bsearch t a), 0)), (<(_ (bsearch t a), (length t)))), (=(index t (_ (bsearch t a)), a)))))))
is_smt_pat called with ((ensures (forall x.{:pattern } (==>((/\(/\((<=(x, y)), (<(y, a))), (=(x, a)))), False)))))
is_smt_pat called with ((ensures (forall p.{:pattern } (==>((/\(/\(/\((<=(0, p)), (<(p, length t))), (=(index t p, a))), (<=(p, mid)))), False)))))
is_smt_pat called with ((ensures (forall x.{:pattern } (==>((/\(/\((<=(y, x)), (<(a, y))), (=(x, a)))), False)))))
is_smt_pat called with ((ensures (forall p.{:pattern } (==>((/\(/\(/\((<=(0, p)), (<(p, length t))), (=(index t p, a))), (<=(mid, p)))), False)))))
is_smt_pat called with ((ensures (==>((_ (bsearch t a)), (forall p.{:pattern } ==>(<=(0, p), ==>(<(p, length t), <>(index t p, a))))))))
#done-ok
for a in transcript-bad*; do echo "Checking $a"; cat $a | ../../../bin/fstar-any.sh --in test.fst | tail -n 1 | grep done-nok || exit 1; done
Checking transcript-bad-1
is_smt_pat called with ((ensures (==(reify (if e () then e1 () else e2 ()) h0, reify (e1 ()) h0))))
is_smt_pat called with ((ensures (==(reify (if e () then e1 () else e2 ()) h0, reify (e1 ()) h0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex03a (169 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03b.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: Equivalence (668 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module NatHeap NatHeap.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDeclassify IfcDeclassify.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
Verified module: Ex03a (171 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03b.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: AES (421 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.DoubleDefun CPS.DoubleDefun.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: CPS.DoubleLambdaLifting2 (108 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03c.fst
Verified module: Test (17 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include plain.pos --odir plain.pos Test.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
unknown(0,0-0,0) :  : (Error) Expected expression of type "int"; got expression ""hello"" of type "string"(Also see: <input>(2,14-2,15))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
#done-nok
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src/tests/interactive'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDelimitedRelease IfcDelimitedRelease.fst
Verified module: Ex03b (105 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.Expr CPS.Expr.fst
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex03b (101 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex03c.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: BinarySearch (3882 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module InsertionSort InsertionSort.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: IntSort (1582 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (let  sl = snd (reify (f ()) (_ s)) in let  sr = snd (reify (f ()) (_ s)) in (\/(\/(sl.release, sr.release), low_equiv ((R sl sr)))))))
is_smt_pat called with ((ensures (<>(j, root))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MergeSort MergeSort.fst
Verified module: StlcCbvDbPntSubstNoLists (5317 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StlcCbvDbParSubst StlcCbvDbParSubst.fst
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
WARNING: (6712,66): pattern does not contain any variable.
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex03c (118 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04a.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Test (23 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include noshadow.pos --odir noshadow.pos Test.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.Tcp (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt63.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: CPS.DoubleDefun (1177 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.SimpleDefun CPS.SimpleDefun.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
WARNING: (67353,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.DM4F.IntST (3772 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Exceptions.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
Verified module: CPS.Expr (677 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module CPS.SimpleLambdaLifting CPS.SimpleLambdaLifting.fst
WARNING: (6968,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r lo hi (_ h)) (p1_r lo hi (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p2_r lo hi (_ h)) (p2_r lo hi (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p3_r lo1 lo2 hi (_ h)) (p3_r lo1 lo2 hi (_ h)))))))
Verified module: IfcDeclassify (2980 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcDelimitedReleaseReify IfcDelimitedReleaseReify.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Ex03c (305 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04a.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Encrypt_Sample (49 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 SHA1.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
Verified module: NatHeap (5962 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ImmutableSTwHeaps ImmutableSTwHeaps.fst
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex04a (288 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04b.fst
Verified module: Test (24 milliseconds)
All verification conditions discharged successfully
Verified module: SfLists (7744 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include field.pos --odir field.pos Test.fst
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SfPoly SfPoly.fst
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: IfcComposeReify (2998 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExample IfcExample.fst
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
WARNING: (6635,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
.\Encrypt_SymEnc.fst(29,0-29,18) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: StlcStrongDbParSubst (10815 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints LambdaOmega.fst --max_fuel 1 --max_ifuel 1 --initial_fuel 1
Verified module: InsertionSort (1180 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module QuickSort.List QuickSort.List.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
Verified module: Ex04a (418 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04b.fst
is_smt_pat called with ((ensures (=(length (append l1 l2), +(length l1, length l2)))))
Verified module: Encrypt_SymEnc (3201 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 MAC.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex04b (363 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04c.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
.\Platform.Bytes.fst(257,22-260,30) :  : (Warning) Pattern misses at least one bound variable: i#40244
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
Verified module: FStar.DM4F.Exceptions (4004 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.ExnSt.fst
.\Platform.Bytes.fst(261,8-261,24) :  : (Warning) Pattern misses at least one bound variable: i#42374 (see also .\Platform.Bytes.fst(257,156-260,30))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
WARNING: (6972,66): pattern does not contain any variable.
Verified module: Test (56 milliseconds)
All verification conditions discharged successfully
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include plain.neg --odir plain.neg Test.fst > plain.neg/error.log 2>&1
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: BinaryTrees (21197 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTree BinarySearchTree.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: ImmutableSTwHeaps (960 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AVar r)) (env r))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ReifyTest ReifyTest.fst
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
Verified module: CPS.SimpleDefun (881 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Eval.DB Eval.DB.fst
Verified module: CPS.SimpleLambdaLifting (161 milliseconds)
All verification conditions discharged successfully
Verified module: MergeSort (3217 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module mcCarthy91 mcCarthy91.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module QuickSort.Seq QuickSort.Seq.fst
is_smt_pat called with ((ensures (=(esubst s1 e, esubst s2 e))))
is_smt_pat called with ((ensures (=(esubst s ((ELam t e)), (ELam t (esubst (esub_lam s) e))))))
is_smt_pat called with ((ensures (=(tsubst s1 t, tsubst s2 t))))
is_smt_pat called with (decreases (Prims.LexCons is_tvar t (Prims.LexCons is_trenaming s1 (Prims.LexCons is_trenaming s2 (Prims.LexCons t (Prims.LexTop ))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with (decreases t1)
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with (decreases s)
is_smt_pat called with ((ensures (=((tsub_comp (tsub_beta_gen x s1) (tsub_beta_gen y s2)) v, (tsub_comp (tsub_beta_gen y (tsubst_beta_gen x s1 s2)) (tsub_beta_gen (+(x, 1)) (tshift_up_above y s1))) v))))
is_smt_pat called with ((ensures (=(ts x s (ts y t2 t1), ts y (ts x s t2) (ts (+(x, 1)) (tsh y s) t1)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(length (append l1 l2), +(length l1, length l2)))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex04b (513 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04c.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
Verified module: Ex04c (513 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04e.fst
Verified module: IfcExample (2428 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify0 IfcExampleReify0.fst
is_smt_pat called with ((ensures (==(x1, x2))))
plain.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include shadow.neg --odir shadow.neg Test.fst > shadow.neg/error.log 2>&1
Verified module: IfcDelimitedRelease (8683 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify1 IfcExampleReify1.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: McCarthy91 (494 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module termination termination.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: BinarySearchTree (2263 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTree0 BinarySearchTree0.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: StlcCbvDbParSubst (11826 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module StackMachine StackMachine.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: SHA1 (812 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Sig.fst
Verified module: Eval.DB (3665 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Cert.ACLs.fst
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: Ex04e (607 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04f.fst
is_smt_pat called with ((ensures (==(p1, p2))))
shadow.neg failed as expected
Verified module: Ex04c (1099 milliseconds)
All verification conditions discharged successfully
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include open.neg --odir open.neg Test.fst > open.neg/error.log 2>&1
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04e.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
Verified module: BinarySearchTree0 (1161 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTreeBasic BinarySearchTreeBasic.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\MAC.fst(45,0-45,35) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.DM4F.ExnSt (5072 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.StExn.fst
is_smt_pat called with ((ensures (==(p1, p2))))
WARNING: (4215,6): pattern does not contain all quantified variables.
Verified module: ReifyTest (4670 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module AllocSTwHeaps AllocSTwHeaps.fst
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
Verified module: Termination (3633 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/termination'
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.ST.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: MAC (2171 milliseconds)
All verification conditions discharged successfully
WARNING: (67353,66): pattern does not contain any variable.
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Cap.fst
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
open.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include private.neg --odir private.neg Test.fst > private.neg/error.log 2>&1
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex04f (369 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04g.fst
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex04e (898 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04f.fst
is_smt_pat called with (decreases t)
WARNING: (67353,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: QuickSort.Seq (2881 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module GC GC.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Cert.ACLs (671 milliseconds)
All verification conditions discharged successfully
Verified module: SfPoly (12954 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 Formatting.fst
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/software_foundations'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04g.fst
Verified module: QuickSort.List (10728 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unification Unification.fst
Verified module: AllocSTwHeaps (1583 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Preorder Preorder.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Unit1.Basic (24545 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Projectors2 Unit1.Projectors2.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\Ex04g.fst(5,4-5,6): Warning: Admitting tl without a definition
.\Ex04g.fst(4,4-4,6): Warning: Admitting hd without a definition
Verified module: Ex04g (24 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04h.fst
private.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include trans.neg --odir trans.neg Test.fst > trans.neg/error.log 2>&1
Verified module: Ex04f (1322 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex04h.fst
Verified module: FStar.DM4F.ST (2662 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.DM4F.StExn (4991 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.ST.fst
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex04h (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05a.fst
is_smt_pat called with ((ensures (==((ifc_c_r (_ h) x), (ifc_c_r (_ h) x)))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r (_ h) x) x, sel (ifc_c_r (_ h) x) x))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r (_ h) x) x, sel (ifc_c_r (_ h) x) x))))
is_smt_pat called with ((ensures (=(sel (ifc_c_r h x) x, 0))))
Verified module: Sig (1744 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 RPC.fst
Verified module: Ex04h (361 milliseconds)
All verification conditions discharged successfully
Verified module: Ex04g (241 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05a.fst
WARNING: (67353,66): pattern does not contain any variable.
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.StExnC.fst
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Preorder (62 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --record_hints --verify_module MRefHeap MRefHeap.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
trans.neg failed as expected
! /cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include noshadow.neg --odir noshadow.neg Test.fst > noshadow.neg/error.log 2>&1
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: IfcExampleReify0 (2068 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(Seq.length s_tail, Seq.length s))))
is_smt_pat called with ((ensures (~((Seq.mem double_quote contents)))))
is_smt_pat called with ((ensures (<(Seq.length s', Seq.length s))))
is_smt_pat called with ((ensures (<(Seq.length tail, Seq.length parsee))))
is_smt_pat called with ((ensures (==(gparse_object j gparse l data0 l' (Seq.append (gprint_object j gprint l data l') tail), (Some ((Prims.Mktuple2 data tail)))))))
is_smt_pat called with ((ensures (==(gparse_object j gparse l data0 l' (Seq.append (gprint_object j gprint l data l') tail), (Some ((Prims.Mktuple2 data tail)))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (OrdSet.subset (vars (subst_term s t')) (OrdSet.remove (fst s) (OrdSet.union (vars (snd s)) (vars t'))))))
is_smt_pat called with ((ensures (OrdSet.subset (evars (lsubst_eqns (Prims.Cons (Prims.Mktuple2 x t) (Prims.Nil )) e)) (OrdSet.remove x (evars ((Prims.Cons ((Prims.Mktuple2 (V x) t)) e)))))))
is_smt_pat called with ((ensures (=(lsubst_term (extend_lsubst l l') e, lsubst_term l (lsubst_term l' e)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(subst_term ((Prims.Mktuple2 x z)) y, y))))
is_smt_pat called with ((ensures (=(lsubst_term (Prims.Cons s (Prims.Nil )) (lsubst_term l (subst_term s e)), lsubst_term (Prims.Cons s (Prims.Nil )) (lsubst_term l e)))))
is_smt_pat called with ((ensures (=(lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns l (lsubst_eqns (Prims.Cons s (Prims.Nil )) e)), lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns l e)))))
is_smt_pat called with ((ensures (solved (lsubst_eqns l'' ((Prims.Cons ((Prims.Mktuple2 (V x) y)) tl))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(subst_term s (subst_term s t), subst_term s t))))
is_smt_pat called with ((ensures (=(lsubst_eqns (Prims.Cons s (Prims.Nil )) (lsubst_eqns (Prims.Cons s (Prims.Nil )) e), lsubst_eqns (Prims.Cons s (Prims.Nil )) e))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (not_solveable ((Prims.Mktuple2 (V x) t)))))
is_smt_pat called with ((ensures (=(lsubst_term l (subst_term ((Prims.Mktuple2 x t)) t'), lsubst_term l t'))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(lsubst_eqns l (lsubst_eqns (Prims.Cons (Prims.Mktuple2 x t) (Prims.Nil )) e), lsubst_eqns l e))))
is_smt_pat called with ((ensures (not_solveable_eqns ((Prims.Cons ((Prims.Mktuple2 (V x) t)) tl)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (if _ (unify_eqns e) then not_solveable_eqns e else solved (lsubst_eqns (_ (unify_eqns e)) e))))
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with (decreases l2)
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
.\Ex05a.fst(28,4-28,13): Warning: Admitting rev_is_ok without a definition
Verified module: IfcDelimitedReleaseReify (15789 milliseconds)
All verification conditions discharged successfully
Verified module: Ex05a (769 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05b.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.UInt63 (14939 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 CntFormat.fst
Verified module: Ex05a (1328 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex05b.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
noshadow.neg failed as expected
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/incl'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify2 IfcExampleReify2.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 CntProtocol.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module BinarySearchTreeFirst BinarySearchTreeFirst.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: BinarySearchTreeBasic (13155 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module RBTree RBTree.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(s0, s1))))
Verified module: GC (10455 milliseconds)
All verification conditions discharged successfully
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Huffman Huffman.fst
Verified module: FStar.DM4F.Heap (6373 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IFC.fst
Verified module: Cap (492 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.Plain.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: MRefHeap (5304 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module SnapshotST SnapshotST.fst
Verified module: Ex05b (506 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06a.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
Verified module: Formatting (3608 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
Verified module: IfcExampleReify1 (5453 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.MAC.fst
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcExampleReify3 IfcExampleReify3.fst
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
WARNING: (67353,66): pattern does not contain any variable.
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.DM4F.StExnC (6870 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Continuations.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.DM4F.Heap.ST (7211 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints delimcc.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: Ex05b (1950 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06a.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
WARNING: (67353,66): pattern does not contain any variable.
WARNING: (70852,6): pattern does not contain all quantified variables.
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\Ex06a.fst(5,4-5,13): Warning: Admitting partition without a definition
Verified module: Ex06a (25 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06b.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with (decreases t)
is_smt_pat called with (decreases t)
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
.\Platform.Bytes.fst(15,40-18,29) :  : (Warning) Pattern misses at least one bound variable: uu___#79854
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
.\Platform.Bytes.fst(261,8-261,24) :  : (Warning) Pattern misses at least one bound variable: i#89301 (see also .\Platform.Bytes.fst(257,156-260,30))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Platform.Bytes (52529 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/bytes'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ReifyTestTSST ReifyTestTSST.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\RPC.fst(9,0-9,53) :  : (Warning) Top-level let-bindings must be total; this term may have effects
.\RPC.fst(23,0-23,39) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
Verified module: Ex06a (189 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(decode t (@(bs, bs')), (match decode t bs' with (Some ss)  -> (Some ((Prims.Cons s ss))) | None  -> None)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==>(>(List.Tot.length sws, 1), (let  t = huffman sws in (match encode t ss with (Some e)  -> (match decode t e with (Some d)  -> =(d, ss) | None  -> False) | None  -> True))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06b.fst
.\RPC.fst(48,0-49,16) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: BinarySearchTreeFirst (3245 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --explicit_deps ArrayRealized.fst Vector.fst
is_smt_pat called with ((ensures (==(x1, x2))))
.\RPC.fst(116,0-116,17) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: RPC (1733 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.CPA.fst
Verified module: DelimCC (1468 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStore.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: SnapshotST (3403 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module MRefST MRefST.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.DM4F.IFC (6718 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreFixedReader.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Unit1.Projectors2 (24 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.WPsAndTriples Unit1.WPsAndTriples.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.DM4F.Continuations (4567 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreFixed.fst
Verified module: FStar.Integers (36413 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.Base.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
Verified module: ReifyTestTSST (1384 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Parser Unit1.Parser.fst
is_smt_pat called with ((ensures contains (append s1 s2) x))
.\CntProtocol.fst(14,0-14,53) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Test (28734 milliseconds)
All verification conditions discharged successfully
.\CntProtocol.fst(29,0-29,26) :  : (Warning) Top-level let-bindings must be total; this term may have effects
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Reader.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
.\CntProtocol.fst(32,0-32,54) :  : (Warning) Top-level let-bindings must be total; this term may have effects
.\CntProtocol.fst(35,0-35,54) :  : (Warning) Top-level let-bindings must be total; this term may have effects
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 EtM.AE.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: CntFormat (3561 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.RSA.fst
Verified module: Unit1.WPsAndTriples (343 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (disjoint j k)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.RefinementInference Unit1.RefinementInference.fst
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
Verified module: Ex06b (6746 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06e.fst
.\CntProtocol.fst(99,0-99,39) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Unification (21072 milliseconds)
All verification conditions discharged successfully
Verified module: RBTree (14066 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/data_structures'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.PlainPKE.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07a.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\CntProtocol.fst(126,0-126,18) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Unit1.Parser (1454 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.WPsAndTriples_ST Unit1.WPsAndTriples_ST.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: EtM.Plain (27 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.Plain.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
Verified module: Ex06b (6000 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (let  h' = p1_r x y hi h in /\(/\((=(sel h' y, sel h y)), (=(sel h' x, +(sel h x, sel h y)))), (=(sel h' hi, sel h hi))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r x y hi (_ h)) (p1_r x y hi (_ h)))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06c.fst
.\CntProtocol.fst(158,0-174,5) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
Verified module: FStar.Reader (850 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
Verified module: CntProtocol (6113 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Bytes.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.AE.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Unit1.RefinementInference (123 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.Projectors1 Unit1.Projectors1.fst
.\Ex06e.fst(18,4-18,8): Warning: Admitting sort without a definition
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex06e (410 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07b.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ni_com env ((Seq c_2 c_3)) Low))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (/\(_ (typing empty v), ==(typing g (subst x v e), typing (extend g x (_ (typing empty v))) e)))))
is_smt_pat called with ((ensures (/\(_ (step e), ==(typing empty (_ (step e)), typing empty e)))))
.\Ex07a.fst(228,4-228,14): Warning: Admitting typed_step without a definition
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: IfcExampleReify3 (2771 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRecursiveHeapReify IfcRecursiveHeapReify.fst
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures _ (fst (reify (read r) store))))
is_smt_pat called with ((ensures _ (fst (reify (write r x) store))))
is_smt_pat called with ((ensures (/\(in_ r store, ==(normalize_term (fst (reify (let  () = write_tot r x in read_tot r) store)), (Some x))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Unit1.WPsAndTriples_ST (295 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.UnificationTests Unit1.UnificationTests.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
Verified module: Huffman (14521 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/algorithms'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit1.RecursiveTypeFunctions Unit1.RecursiveTypeFunctions.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: MRefST (9628 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/preorders'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.CCA2.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.List.Tot.Base (7356 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include disjoint.pos --odir disjoint.pos Test.fst
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.DM4F.IntStoreFixedReader (1742 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.IntStoreExcFixed.fst
Verified module: EtM.MAC (3178 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib/hyperstack \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
--z3rlimit 20 HyE.HCCA2.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Unit1.UnificationTests (27 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Unit2 Unit2.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: IfcExampleReify2 (5842 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRecursiveReify IfcRecursiveReify.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.DM4F.IntStoreFixed (2996 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.DM4F.IntStore (5190 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Heap.Random.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcReificationRegressionTest IfcReificationRegressionTest.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (=(length l_1, length l_2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
Verified module: Ex06c (7905 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06d.fst
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: Unit1.RecursiveTypeFunctions (2467 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Classical.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Test (9473 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include array.pos --odir array.pos Test.fst
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex07a (10754 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07c.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Unit2 (1869 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestSet TestSet.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x (append l m), (+(count x l, count x m))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(mem x (append l m), (||(mem x l, mem x m))))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures ((/\(/\(/\(/\(=(+(length (fst (partition f l)), length (snd (partition f l))), length l), (forall x.{:pattern } ==>(mem x (fst (partition f l)), f x))), (forall x.{:pattern } ==>(mem x (snd (partition f l)), not (f x)))), (forall x.{:pattern } =(mem x l, (||(mem x (fst (partition f l)), mem x (snd (partition f l))))))), (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l)))))))))))
is_smt_pat called with ((ensures (sorted f (append l1 ((Prims.Cons pivot l2))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.Bytes (572 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Constructive.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures hasEq rid))
Verified module: EtM.CPA (3199 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_location_info --lax \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
RPC.fst \
--codegen-lib Platform --codegen-lib CoreCrypto --codegen-lib Seq --codegen OCaml
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (low_equiv env ((R (p1_r lo hi n (_ h)) (p1_r lo hi n (_ h)))))))
is_smt_pat called with ((ensures (low_equiv env ((R (p2_r lo hi n (_ h)) (p2_r lo hi n (_ h)))))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (low_equiv env ((R (p3_r lo1 lo2 hi n (_ h)) (p3_r lo1 lo2 hi n (_ h)))))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: TestSet (385 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestHeap TestHeap.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: HyE.AE (3226 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_location_info --lax \
--include ../../ucontrib/Platform/fst --include ../../ucontrib/CoreCrypto/fst	       \
CntProtocol.fst \
--codegen-lib Platform --codegen-lib CoreCrypto --codegen-lib Seq --codegen OCaml
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
Verified module: IfcReificationRegressionTest (1896 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRules IfcRules.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: IfcRecursiveReify (3225 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcRulesReify IfcRulesReify.fst
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Ex06d (6943 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex06e.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: HyE.Plain (19 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module ShortCircuit ShortCircuit.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(s0, s1))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.Classical (4819 milliseconds)
All verification conditions discharged successfully
Extracted module StrongExcludedMiddle
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst
Extracted module Classical
Extracted module Base
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Extracted module Properties
Extracted module Tot
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
Extracted module Base
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
Extracted module Properties
Extracted module Seq
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Extracted module Bytes
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Heap
Extracted module ST
Extracted module CoreCrypto
Extracted module All
Extracted module Formatting
Extracted module SHA1
Extracted module MAC
Extracted module RPC
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module FirstProofs FirstProofs.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.Constructive (2975 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DependentMap.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
Verified module: Ex06e (1280 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07a.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: TestHeap (1643 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestMRef TestMRef.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: EtM.AE (7122 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07d.fst
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (/\(_ (typing empty v), ==(typing g (subst x v e), typing (extend g x (_ (typing empty v))) e)))))
is_smt_pat called with ((ensures (/\(_ (step e), ==(typing empty (_ (step e)), typing empty e)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AVar r)) (env r))))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex07b (22787 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10a.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.DM4F.Heap.Random (2023 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.DM4F.Random.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FirstProofs (1440 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestTwoLevelHeap TestTwoLevelHeap.fst
Verified module: ShortCircuit (2028 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Mac Mac.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.DependentMap (4078 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.FunctionalExtensionality.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
.\Ex07d.fst(225,4-225,8): Warning: Admitting eval without a definition
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: HyE.RSA (480 milliseconds)
All verification conditions discharged successfully
.\TestMRef.fst(8,0-8,20) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10b.fst
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: TestMRef (1241 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module TestGhost TestGhost.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: Unit1.Projectors1 (2610 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Normalization Normalization.fst
Verified module: FStar.DM4F.IntStoreExcFixed (6641 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07b.fst
Verified module: TestTwoLevelHeap (542 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module IfcTypechecker IfcTypechecker.fst
Extracted module StrongExcludedMiddle
Extracted module Classical
Extracted module Base
Extracted module Properties
Extracted module Tot
Extracted module Base
Verified module: LambdaOmega (81540 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12a.Cap.fst
Extracted module Properties
Extracted module Seq
Extracted module Bytes
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Heap
Extracted module ST
Extracted module All
Extracted module CntFormat
is_smt_pat called with ((ensures (==(x1, x2))))
.\Ex10a.fst(27,0-27,19) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Extracted module CoreCrypto
Extracted module SHA1
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
Verified module: FStar.Map (6277 milliseconds)
All verification conditions discharged successfully
Extracted module MAC
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
Extracted module Set
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.MarkovsPrinciple.fst
Extracted module CntProtocol
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Ex10a (1643 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12d.Pad.fst
Verified module: IfcRules (8131 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../ulib --include ../../ulib/hyperstack --include point.pos --odir point.pos Test.fst
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
Verified module: IfcRecursiveHeapReify (12675 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.FunctionalExtensionality (271 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Loops Loops.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Array.fst
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
Verified module: TestGhost (534 milliseconds)
All verification conditions discharged successfully
Verified module: Ex07c (18275 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --verify_module Positivity Positivity.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12e.Pad.fst
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: HyE.PlainPKE (252 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints NegativeTests.BST.fst NegativeTests.Heap.fst NegativeTests.ShortCircuiting.fst NegativeTests.Bug260.fst NegativeTests.Neg.fst NegativeTests.Termination.fst NegativeTests.False.fst NegativeTests.Set.fst NegativeTests.ImplicitFalse.fst NegativeTests.Positivity.fst 2>&1 | tee fstar_log
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex07a (11909 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07c.fst
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex10b (1747 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12f.TMAC.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.MarkovsPrinciple (21 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.SquashEffect.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Positivity (1418 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Memo Memo.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.SquashEffect (398 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.BitVector.fst
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
Verified module: FStar.DM4F.Random (6637 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/dm4free'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12g.TMAC2.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
.\Ex12a.Cap.fst(21,0-21,26) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Ex12a.Cap (260 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex07d.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
Verified module: Normalization (2866 milliseconds)
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10a.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
Verified module: Test (9611 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex10b.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: HyE.HCCA2 (2128 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12a.Cap.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
Verified module: HyE.CCA2 (3442 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex07d (17316 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/crypto'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ulib/hyperheap Ex11a.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12b.RPC.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: Ex12e.Pad (1540 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.PropositionalExtensionality.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
.\Ex12f.TMAC.fst(26,4-26,10): Warning: Admitting verify without a definition
.\Ex12f.TMAC.fst(25,4-25,7): Warning: Admitting mac without a definition
.\Ex12f.TMAC.fst(24,4-24,10): Warning: Admitting keygen without a definition
Verified module: Ex12f.TMAC (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12d.Pad.fst
is_smt_pat called with ((ensures (\/(is_value e, (_ (step e))))))
is_smt_pat called with ((ensures (==>(appears_free_in x e, _ (g x)))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(typing g e, typing g' e))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Loops (7886 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: FStar.List (5413 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module NetKat NetKat.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12e.Pad.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
.\Ex10a.fst(27,0-27,19) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (match List.assoc x l with (Some y)  -> p ((Prims.Mktuple2 x y)) | _  -> True)))
is_smt_pat called with ((ensures (p ((Prims.Mktuple2 x y)))))
is_smt_pat called with ((ensures (valid_memo ((Prims.Cons ((Prims.Mktuple2 x y)) h)) f)))
is_smt_pat called with ((ensures (/\(valid_memo h0 f, (let  h1 = memo_heap_to_valid_memo (valid_memo_to_memo_heap f h0) in ==(h0, h1))))))
is_smt_pat called with ((ensures (let  (y, h1) = reify (memo_extr f x) h0 in /\(valid_memo h1 f, ==(y, f x)))))
is_smt_pat called with ((ensures (==>(p x, (let  (y, h1) = reify (memo_extr_p p f x) h0 in /\(==(y, g x), valid_memo h1 g))))))
is_smt_pat called with ((ensures (computes (memo_extr_p p f) g)))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(p x, (let  (y, h1) = reify (memo_extr_p p f x) h0 in /\(==(y, g x), valid_memo h1 g))))))
is_smt_pat called with ((ensures (==(y, fixp f x))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==(fixp f x, g x))))
is_smt_pat called with ((ensures (res (cont1 (fixfib x1)))))
is_smt_pat called with ((ensures (res (cont2 (fixfib x2)))))
is_smt_pat called with ((ensures (computes f g1)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Ex10a (2759 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12f.TMAC.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
Verified module: FStar.PropositionalExtensionality (25 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Set.fst
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (forall b.{:pattern } let  (Cons hd tl) = bs in ==>(mem b tl, disjoint (_ b) (_ hd)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\Mac.fst(70,0-70,35) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
Verified module: Ex07c (14541 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ucontrib/Platform/fst --include ../../../..//ucontrib/CoreCrypto/fst Ex12g.TMAC2.fst
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
Verified module: MAC (2053 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --include ../../../..//ulib/hyperheap Ex11a.fst
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Ex10b (3589 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module OneTimePad OneTimePad.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
.\Ex12g.TMAC2.fst(30,4-30,10): Warning: Admitting verify without a definition
.\Ex12g.TMAC2.fst(29,4-29,7): Warning: Admitting mac without a definition
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Ex12g.TMAC2 (914 milliseconds)
All verification conditions discharged successfully
mkdir -p out
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.Properties.fst
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Array (5640 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt32.fst
is_smt_pat called with ((ensures (==(s0, s1))))
.\Ex12b.RPC.fst(8,0-8,53) :  : (Warning) Top-level let-bindings must be total; this term may have effects
.\Ex12b.RPC.fst(21,0-21,39) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
.\Ex12b.RPC.fst(53,0-54,16) :  : (Warning) Top-level let-bindings must be total; this term may have effects
Verified module: Ex12d.Pad (1105 milliseconds)
All verification conditions discharged successfully
make -C ../../../..//ulib/ml
make[4]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
make -C .. mgen
make[5]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
make[5]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
mkdir -p ml/extracted
is_smt_pat called with ((ensures (is_in x.id m.h)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --lax --codegen OCaml --odir ml/extracted FStar.Set.fst FStar.TSet.fst FStar.Map.fst FStar.HyperHeap.fst FStar.HyperStack.fst
is_smt_pat called with ((ensures (<=(l, meet l1 l2))))
is_smt_pat called with ((ensures (ni_exp env e l2)))
is_smt_pat called with ((ensures (ni_exp env ((AInt i)) Low)))
is_smt_pat called with ((ensures (ni_exp env ((AOp op e1 e2)) l)))
is_smt_pat called with ((ensures (ni_com env c l2)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (ni_com env ((Assign r e)) (env r))))
is_smt_pat called with ((ensures (inv_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((Seq c1 c2)) l h0)))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (ni_com env ((Seq c1 c2)) l)))
is_smt_pat called with ((ensures (inv_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com' env ((If e ct cf)) l h0)))
is_smt_pat called with ((ensures (ni_com env ((If e ct cf)) l)))
is_smt_pat called with ((ensures (ni_com env ((While e c v)) l)))
.\Ex12b.RPC.fst(123,0-123,17) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
Verified module: Ex12b.RPC (1609 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Squash.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.Set (3117 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Heap.fst
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (bijection f)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (let  ((enc_0, dec_0), _) = reify (one_time_pad ()) ((Prims.Mktuple2 0 tape_0)) in let  ((enc_1, dec_1), _) = reify (one_time_pad ()) ((Prims.Mktuple2 0 tape_1)) in /\(/\(=(dec_0 (enc_0 x_0), x_0), =(dec_1 (enc_1 x_1), x_1)), =(enc_0 x_0, enc_1 x_1)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: FStar.BitVector (10704 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdSet.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(Seq.equal s1 t1, Seq.equal s2 t2))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
Verified module: IfcTypechecker (2253 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Point Point.fst
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: NetKat (3755 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ProgramEquivalence ProgramEquivalence.fst
Verified module: Ex12d.Pad (1340 milliseconds)
All verification conditions discharged successfully
.\Ex12a.Cap.fst(19,0-19,26) :  : (Warning) Top-level let-bindings must be total; this term may have effects
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ProgramOptimizations ProgramOptimizations.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: Ex12a.Cap (576 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Crypto.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified i'face (or impl+i'face): FStar.Squash (49 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.TSet.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.Heap (949 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.IndefiniteDescription.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified module: Ex12e.Pad (3079 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.ErasedLogic.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (forall b.{:pattern } let  (Cons hd tl) = bs in ==>(mem b tl, disjoint (_ b) (_ hd)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: Ex12f.TMAC (591 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int64.fst
Verified module: Ex07d (17602 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.SquashProperties.fst
Verified module: Ex07b (33306 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.Base.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: Ex11a (15493 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/exercises'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.HyperHeap.fst
Extracted module Classical
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Heap
Extracted module Set
Extracted module Base
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Extracted module Properties
Extracted module Tot
Extracted module Map
Extracted module HyperHeap
Extracted module HyperStack
All verification conditions discharged successfully
make[5]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib'
make prims.o FStar_Mul.o FStar_Float.o FStar_Char.o FStar_Int8.o FStar_UInt8.o FStar_Int16.o FStar_UInt16.o FStar_Int32.o FStar_UInt32.o FStar_Int64.o FStar_UInt64.o FStar_UInt128.o FStar_Int_Cast.o FStar_BaseTypes.o FStar_IO.o FStar_Heap.o FStar_List_Tot_Base.o FStar_List.o FStar_Option.o FStar_String.o FStar_Set.o FStar_Buffer.o FStar_CommonST.o FStar_ST.o FStar_All.o
make[5]: Entering directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
make[5]: warning: jobserver unavailable: using -j1.  Add '+' to parent make rule.
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg prims.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Mul.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Float.ml
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Char.ml
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int8.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt8.ml
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int16.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt16.ml
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int32.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt32.ml
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int64.ml
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt64.ml
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_UInt128.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Int_Cast.ml
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_BaseTypes.ml
Verified module: FStar.ErasedLogic (49 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.List.Tot.fst
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_IO.ml
Verified module: FStar.TSet (1793 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.MRef.fst
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Heap.ml
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_List_Tot_Base.ml
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_List.ml
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Option.ml
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_String.ml
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
Verified module: FStar.IndefiniteDescription (1723 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int32.fst
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Set.ml
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_Buffer.ml
is_smt_pat called with ((ensures (==(p1, p2))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_CommonST.ml
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_ST.ml
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
ocamlfind opt -thread -package batteries,zarith,stdint -linkpkg -g   -c -I  ./extracted -linkpkg FStar_All.ml
make[5]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
ocamlopt -a prims.cmx FStar_Mul.cmx FStar_Float.cmx FStar_Char.cmx FStar_Int8.cmx FStar_UInt8.cmx FStar_Int16.cmx FStar_UInt16.cmx FStar_Int32.cmx FStar_UInt32.cmx FStar_Int64.cmx FStar_UInt64.cmx FStar_UInt128.cmx FStar_Int_Cast.cmx FStar_BaseTypes.cmx FStar_IO.cmx FStar_Heap.cmx FStar_List_Tot_Base.cmx FStar_List.cmx FStar_Option.cmx FStar_String.cmx FStar_Set.cmx FStar_Buffer.cmx FStar_CommonST.cmx FStar_ST.cmx FStar_All.cmx -o fstarlib.cmxa
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
Verified module: FStar.SquashProperties (2800 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.PredicateExtensionality.fst
make[4]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib/ml'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints --no_extract FStar.All --no_extract FStar.BaseTypes --no_extract FStar.Char --no_extract FStar.Float --no_extract FStar.Heap --no_extract FStar.Int8 --no_extract FStar.Int16 --no_extract FStar.Int32 --no_extract FStar.Int64 --no_extract FStar.UInt8 --no_extract FStar.UInt16 --no_extract FStar.UInt32 --no_extract FStar.UInt64 --no_extract FStar.Int_Cast --no_extract FStar.IO --no_extract FStar.List --no_extract FStar.List.Tot.Base --no_extract FStar.Option --no_extract FStar.Set --no_extract FStar.ST --no_extract FStar.String --no_extract FStar.HyperHeap --no_extract FStar.HyperStack --no_extract FStar.HST --no_extract FStar.Buffer --no_extract FStar.Mul --odir out --codegen OCaml Ex01a.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com11) h_left in let  (_, h_right') = reify (com_denotation com12) h_right in rel_exp_denotation rel12 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com21) h_left in let  (_, h_right') = reify (com_denotation com22) h_right in rel_exp_denotation rel22 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com31) h_left in let  (_, h_right') = reify (com_denotation com32) h_right in rel_exp_denotation rel32 h_left' h_right')))
is_smt_pat called with ((ensures (let  (_, h_left') = reify (com_denotation com41) h_left in let  (_, h_right') = reify (com_denotation com42) h_right in rel_exp_denotation rel4 h_left' h_right')))
is_smt_pat called with ((ensures (rhl ((If CTrue c c')) d phi phi')))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
Verified module: FStar.MRef (727 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdMap.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
Verified module: Ex12g.TMAC2 (1262 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module RandomTapes RandomTapes.fst
.\Ex01a.fst(58,0-58,48) :  : (Warning) Top-level let-bindings must be total; this term may have effects
is_smt_pat called with ((ensures (==(p1, p2))))
Extracted module FunctionalExtensionality
Extracted module PropositionalExtensionality
Extracted module PredicateExtensionality
Extracted module TSet
Extracted module Ex01a
Verified module: Ex01a (930 milliseconds)
All verification conditions discharged successfully
ocamlfind opt -package batteries,stdint,zarith -linkpkg -g ../../../..//ulib/ml/fstarlib.cmxa -I ../../../..//ulib/ml out/Ex01a.ml -o Ex01a.exe 2>&1
Verified module: FStar.PredicateExtensionality (155 milliseconds)
All verification conditions discharged successfully
File "out/Ex01a.ml", line 23, characters 8-10:
Warning 26: unused variable v1.
File "out/Ex01a.ml", line 23, characters 29-31:
Warning 26: unused variable v2.
File "out/Ex01a.ml", line 39, characters 8-10:
Warning 26: unused variable v1.
File "out/Ex01a.ml", line 40, characters 8-10:
Warning 26: unused variable v2.
File "out/Ex01a.ml", line 41, characters 8-10:
Warning 26: unused variable v3.
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int.Cast.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.List.Tot (26 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.All.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Point (4184 milliseconds)
All verification conditions discharged successfully
Verified module: ProgramEquivalence (7062 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Recursive Recursive.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt128.fst
Verified module: Test (22720 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Math.Lib.fst
is_smt_pat called with ((ensures (bijection f)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
./Ex01a.exe 2>&1
Dummy read of file demo/tempfile
Dummy read of file demo/README
Dummy write of string hello! to file demo/tempfile
Dummy read of file demo/tempfile
Dummy read of file demo/README
Fatal error: exception Ex01a.InvalidRead
Raised at file "prims.ml", line 103, characters 20-21
make[3]: [Makefile:66: Ex01a-ocaml] Error 2 (ignored)
Called from file "out/Ex01a.ml", line 41, characters 13-31
Called from file "out/Ex01a.ml", line 43, characters 42-60
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ReifyLong ReifyLong.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: RandomTapes (1032 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.Crypto (1603 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Rel Rel.fst
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt16.fst
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.List.Tot.Properties (20476 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.WellFounded.fst
Verified module: FStar.UInt32 (13996 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int8.fst
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: Ex11a (17832 milliseconds)
All verification conditions discharged successfully
Verified module: OneTimePad (24542 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/doc/tutorial/code/solutions'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.Properties.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module StRel StRel.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: IfcRulesReify (41645 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module Swap Swap.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
Verified module: FStar.All (109 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind.Forest UnionFind.Forest.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (>=(fac n, fac m))))
is_smt_pat called with ((ensures (>=(fac_sum n m, fac_sum n' m'))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.OrdSet (19801 milliseconds)
All verification conditions discharged successfully
Verified module: Memo (34242 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Relational.Relational.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind UnionFind.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: Recursive (832 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module UnionFind.Functions UnionFind.Functions.fst
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==>((=(dom #k #v #f m, OrdSet.empty)), (==(m, empty #k #v #f))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: Rel (2139 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module While While.fst
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.WellFounded (783 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdMapProps.fst
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
Verified module: FStar.Math.Lib (6690 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt8.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
.\NegativeTests.BST.fst(21,38-21,42) :  : (Error) Subtyping check failed; expected type (right#61:(option (tree 2)){(l_and (l_and (l_and (b2t (op_LessThanOrEqual 0 1)) (b2t (op_LessThanOrEqual 1 2))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality 1 2)))) (l_iff (b2t (uu___is_None (None ))) (b2t (op_Equality 1 0))))}); got type (option (tree 2)) (see also .\NegativeTests.BST.fst(13,36-13,57))
.\NegativeTests.BST.fst(22,61-22,65) :  : (Error) Subtyping check failed; expected type (right#61:(option (tree (op_Addition l 1))){(l_and (l_and (l_and (b2t (op_LessThanOrEqual l l)) (b2t (op_LessThanOrEqual l (op_Addition l 1)))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality l (op_Addition l 1))))) (l_iff (b2t (uu___is_None (Some t))) (b2t (op_Equality l l))))}); got type (option (tree (op_Addition l 1))) (see also .\NegativeTests.BST.fst(13,36-13,57))
.\NegativeTests.BST.fst(23,78-23,87) :  : (Error) Subtyping check failed; expected type (right#61:(option (tree (op_Addition l 1))){(l_and (l_and (l_and (b2t (op_LessThanOrEqual l (op_Addition l 1))) (b2t (op_LessThanOrEqual (op_Addition l 1) (op_Addition l 1)))) (l_iff (b2t (uu___is_None right@0)) (b2t (op_Equality (op_Addition l 1) (op_Addition l 1))))) (l_iff (b2t (uu___is_None (Some t1))) (b2t (op_Equality (op_Addition l 1) l))))}); got type (option (tree (op_Addition l 1))) (see also .\NegativeTests.BST.fst(12,36-12,58))
.\NegativeTests.Bug260.fst(9,12-9,19) :  : (Error) Subtyping check failed; expected type (validity (S (S t))); got type (validity (S t)) (see also .\NegativeTests.Bug260.fst(8,37-9,9))
.\NegativeTests.False.fst(3,31-3,42) :  : (Error) assertion failed
.\NegativeTests.False.fst(13,18-13,35) :  : (Error) Expected type "(l_or l_True l_True)"; but "(Left T)" has type "(c_or (?37015 uu___) l_True)"
.\NegativeTests.False.fst(13,36-13,54) :  : (Error) Expected type "(l_or l_True l_True)"; but "(Right T)" has type "(c_or l_True (?37028 uu___))"
.\NegativeTests.Heap.fst(10,0-10,54) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Heap.fst(11,0-15,14) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.ImplicitFalse.fst(4,0-4,33) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(175,22-175,33))
.\NegativeTests.ImplicitFalse.fst(4,26-4,27) :  : (Error) Failed to resolve implicit argument of type 'l_False' introduced in (?37540 uu___) because user-provided implicit term
.\NegativeTests.Neg.fst(6,8-6,10) :  : (Error) Subtyping check failed; expected type nat; got type int (see also C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Neg.fst(8,8-8,10) :  : (Error) Subtyping check failed; expected type nat; got type int (see also C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Neg.fst(10,0-10,35) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Neg.fst(12,28-13,15) :  : (Error) Patterns are incomplete
.\NegativeTests.Neg.fst(19,32-19,42) :  : (Error) assertion failed (see also .\NegativeTests.Neg.fst(15,44-15,57))
.\NegativeTests.Neg.fst(21,83-21,88) :  : (Error) could not prove post-condition
.\NegativeTests.Neg.fst(25,30-25,31) :  : (Error) Subtyping check failed; expected type (uu___#8234:(option 'a){(b2t (uu___is_Some uu___@0))}); got type (option 'a) (see also C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(252,4-252,8))
.\NegativeTests.Neg.fst(28,41-28,43) :  : (Error) Subtyping check failed; expected type (uu___#9393:(result int){(b2t (uu___is_V uu___@0))}); got type (result int) (see also C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(259,4-259,5))
.\NegativeTests.Neg.fst(32,25-32,26) :  : (Error) Subtyping check failed; expected type nat; got type int (see also C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(642,17-642,23))
.\NegativeTests.Positivity.fst(6,5-7,26) :  : (Error) Inductive type NegativeTests.Positivity.t1 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(20,5-21,26) :  : (Error) Inductive type NegativeTests.Positivity.t5 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(30,5-31,24) :  : (Error) Inductive type NegativeTests.Positivity.t7 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(34,5-35,24) :  : (Error) Inductive type NegativeTests.Positivity.t8 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(41,5-42,23) :  : (Error) Inductive type NegativeTests.Positivity.t10 does not satisfy the positivity condition
.\NegativeTests.Positivity.fst(45,5-46,30) :  : (Error) Inductive type NegativeTests.Positivity.t11 does not satisfy the positivity condition
.\NegativeTests.Set.fst(11,0-12,30) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Set.fst(15,0-16,67) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.Set.fst(19,0-20,52) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(633,4-633,11))
.\NegativeTests.ShortCircuiting.fst(5,16-5,33) :  : (Error) Subtyping check failed; expected type (b#22:bool{(bad_p b@0)}); got type bool (see also .\NegativeTests.ShortCircuiting.fst(4,31-4,38))
.\NegativeTests.ShortCircuiting.fst(8,0-8,36) :  : (Error) assertion failed(Also see: C:\Build\Agent2\_work\1\s\bin\..\ulib\prims.fst(175,22-175,33))
.\NegativeTests.Termination.fst(7,27-7,28) :  : (Error) Subtyping check failed; expected type (z#130:int{(precedes (LexCons m (LexCons z@0 LexTop)) m)}); got type int (see also .\NegativeTests.Termination.fst(5,0-7,29))
.\NegativeTests.Termination.fst(13,26-13,35) :  : (Error) Subtyping check failed; expected type (uu___#616:int{(precedes (LexCons n (LexCons uu___@0 LexTop)) (LexCons n (LexCons count LexTop)))}); got type int (see also .\NegativeTests.Termination.fst(10,0-13,35))
.\NegativeTests.Termination.fst(20,29-20,54) :  : (Error) Subtyping check failed; expected type (n#1073:int{(precedes (LexCons (op_Subtraction m 1) (LexCons n@0 LexTop)) (LexCons m (LexCons n LexTop)))}); got type int (see also .\NegativeTests.Termination.fst(17,0-20,54))
.\NegativeTests.Termination.fst(25,28-25,29) :  : (Error) Subtyping check failed; expected type (uu___#1993:(list 'a){(precedes uu___@0 l)}); got type (list 'a) (see also .\NegativeTests.Termination.fst(23,0-25,29))
.\NegativeTests.Termination.fst(37,15-37,29) :  : (Error) Subtyping check failed; expected type (x:(x#2581:nat{(b2t (op_LessThanOrEqual x@0 v))}) -> Tot nat); got type (uu___:(uu___#3405:nat{(precedes uu___@0 v)}) -> Tot nat) (see also .\NegativeTests.Termination.fst(34,0-37,29))
.\NegativeTests.Termination.fst(48,19-48,29) :  : (Error) Subtyping check failed; expected type (uu___#4199:snat{(precedes uu___@0 n)}); got type snat (see also .\NegativeTests.Termination.fst(44,0-48,29))
.\NegativeTests.Termination.fst(55,34-55,35) :  : (Error) Subtyping check failed; expected type (uu___#4752:snat{(precedes (LexCons (S (S n')) (LexCons uu___@0 LexTop)) (LexCons n (LexCons m LexTop)))}); got type snat (see also .\NegativeTests.Termination.fst(51,0-55,35))
.\NegativeTests.Termination.fst(59,2-61,14) :  : (Error) Patterns are incomplete
.\NegativeTests.Termination.fst(67,29-67,31) :  : (Error) Subtyping check failed; expected type (uu___#5798:NegativeTests.Termination.snat{(Prims.precedes<?43218, ?43219> (Prims.LexCons<?43223, (max ?43231, ?43239)> (NegativeTests.Termination.S n'#6308) (Prims.LexCons<?43231, ?43239> uu___@0 Prims.LexTop<?43239>)) (Prims.LexCons<?43245, (max ?43253, ?43261)> n#5785 (Prims.LexCons<?43253, ?43261> m#5786 Prims.LexTop<?43261>)))}); got type (?43509 n#5785 m#5786) (see also .\NegativeTests.Termination.fst(64,0-67,31))
.\NegativeTests.Termination.fst(73,20-73,26) :  : (Error) Subtyping check failed; expected type (uu___#6885:NegativeTests.Termination.snat{(Prims.precedes<?43617, ?43618> uu___@0 n#6881)}); got type NegativeTests.Termination.snat (see also .\NegativeTests.Termination.fst(70,0-73,26))
Verified module: NegativeTests.BST (6483 milliseconds)
Verified module: NegativeTests.Bug260 (2786 milliseconds)
Verified module: NegativeTests.False (2869 milliseconds)
Verified module: NegativeTests.Heap (3944 milliseconds)
Verified module: NegativeTests.ImplicitFalse (1374 milliseconds)
Verified module: NegativeTests.Neg (11692 milliseconds)
Verified module: NegativeTests.Positivity (1871 milliseconds)
Verified module: NegativeTests.Set (3640 milliseconds)
Verified module: NegativeTests.ShortCircuiting (3503 milliseconds)
Verified module: NegativeTests.Termination (15265 milliseconds)
41 errors were reported (see above)
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: ProgramOptimizations (15566 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module WhileReify WhileReify.fst
Success: 41 failures were expected
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/micro-benchmarks'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Fin.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: StRel (744 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module OTP OTP.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.Relational.Relational (3159 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Axiomatic.Array.fst
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.Seq.Base (21139 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Universe.fst
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==>((=(dom #k #v #f m, OrdSet.empty)), (==(m, empty #k #v #f))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
Verified i'face (or impl+i'face): FStar.Universe (23 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int128.fst
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
Verified module: FStar.Axiomatic.Array (485 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.OrdMapProps (368 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Math.Lemmas.fst
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int63.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (equiv (>>(f1, f2)) (>>(f2, f1)))))
is_smt_pat called with ((ensures (equiv (>>(f, f)) f)))
is_smt_pat called with ((ensures (/\(equiv (cond c c1 c2) c1, equiv (cond c c1 c2) c2))))
is_smt_pat called with ((ensures (equiv (>>(c1, c2)) c2)))
is_smt_pat called with ((ensures (let  ((), h_1) = reify (f1 ()) h_0 in let  ((), h'_1) = reify (f2 ()) h_1 in let  ((), h_2) = reify (f2 ()) h_0 in let  ((), h'_2) = reify (f1 ()) h_2 in heap_eq h_0 h'_1 h'_2)))
is_smt_pat called with ((ensures (let  (_, h1) = reify (f ()) h0 in let  (_, h2) = reify (f ()) h1 in heap_eq h0 h1 h2)))
Verified module: FStar.Int32 (13665 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Relational.Comp.fst
Verified module: FStar.HyperHeap (24583 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Seq.fst
Verified module: While (5838 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error   --include ../dm4free --use_hints --verify_module ElGamal ElGamal.fst
is_smt_pat called with ((ensures (let  (r_1, _) = reify (find uf i_1 h) h in let  (r_2, _) = reify (find uf i_2 h) h in let  (_, d_1, s_1) = sel h (index uf r_1) in let  (_, d_2, s_2) = sel h (index uf r_2) in let  (_, h1) = reify (merge uf i_1 i_2) h in ==>(<>(r_1, r_2), (/\(/\(==(sel h1 (index uf r_1), ((Prims.Mktuple3 r_2 d_1 s_1))), (==(sel h1 (index uf r_2), ((Prims.Mktuple3 r_2 d_2 elift2 union s_1 s_2))))), (forall j:id n.{:pattern } ==>((/\(<>(j, r_1), <>(j, r_2))), ==(sel h (index uf j), sel h1 (index uf j))))))))))
is_smt_pat called with ((ensures (let  (r_1, _) = reify (find uf i_1 h) h in let  (r_2, _) = reify (find uf i_2 h) h in let  (_, d_1, s_1) = sel h (index uf r_1) in let  (_, d_2, s_2) = sel h (index uf r_2) in let  (_, h1) = reify (merge_opt uf i_1 i_2) h in ==>((/\(<>(r_1, r_2), >=(d_1, d_2))), (/\(/\(==(sel h1 (index uf r_2), ((Prims.Mktuple3 r_1 d_2 s_2))), (let  d_1 = if =(d_1, d_2) then +(d_1, 1) else d_1 in ==(sel h1 (index uf r_1), ((Prims.Mktuple3 r_1 d_1 elift2 union s_1 s_2))))), (forall j:id n.{:pattern } ==>((/\(<>(j, r_1), <>(j, r_2))), ==(sel h (index uf j), sel h1 (index uf j))))))))))
is_smt_pat called with ((ensures (let  (_, h'_1) = reify (merge uf i_1 i_2) h_1 in let  (_, h'_2) = reify (merge uf i_1 i_2) h_2 in (forall j:id n.{:pattern } /\(/\(/\(=(parent uf j h'_1, parent uf j h'_2), ==(subtree uf j h'_1, subtree uf j h'_2)), =(height uf j h'_1, height uf j h_1)), =(height uf j h'_2, height uf j h_2))))))
is_smt_pat called with ((ensures (let  (_, h1) = reify (merge uf i_1 i_2) h in let  (_, h2) = reify (merge_opt uf i_1 i_2) h in <==>((=(fst (reify (find uf j_1 h1) h1), fst (reify (find uf j_2 h1) h1))), (=(fst (reify (find uf j_1 h2) h2), fst (reify (find uf j_2 h2) h2)))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.Int64 (13993 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Mul.fst
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: UnionFind.Forest (2479 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt64.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: Test (20462 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/struct'
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.UInt.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: OTP (2625 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Ghost.fst
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Mul (41 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.HyperStack.fst
Verified module: FStar.OrdMap (20775 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Int16.fst
Verified module: FStar.Relational.Comp (569 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.OrdSetProps.fst
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified module: FStar.Fin (8250 milliseconds)
All verification conditions discharged successfully
Verified module: Swap (9545 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Util.fst
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.StrongExcludedMiddle.fst
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Ghost (1209 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.IO.fsti
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Int8 (14311 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.StrongExcludedMiddle (115 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.String.fsti
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Squash.fsti
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (forall x.{:pattern } ==>(mem #a #f x (_ s), (/\(f (_ s) x, =!=(_ s, x)))))))
is_smt_pat called with ((ensures (not (mem #a #f (_ s) (_ s)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures (not (mem #a #f x s))))
is_smt_pat called with ((ensures (=(mem #a #f y (insert' #a #f x s), (||(=(x, y), mem #a #f y s))))))
is_smt_pat called with ((ensures (==>(subset #a #f s1 s2, (forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2))))))
is_smt_pat called with ((ensures (==>((forall x.{:pattern } ==>(mem #a #f x s1, mem #a #f x s2)), subset #a #f s1 s2))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (=(union s1 s2, union' s1 s2))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: FStar.Util (30 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Option.fsti
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: FStar.OrdSetProps (1282 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Matrix2.fsti
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
Verified i'face (or impl+i'face): FStar.IO (213 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Universe.fsti
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<=(sum f, sum g))))
is_smt_pat called with ((ensures (==(sum f, sum g))))
is_smt_pat called with ((ensures (<=(mass c1 p1, mass c2 p2))))
is_smt_pat called with ((ensures (==(mass c1 p1, mass c2 p2))))
Verified i'face (or impl+i'face): FStar.Squash (58 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Float.fsti
Verified module: FStar.Seq (52 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.BaseTypes.fsti
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified i'face (or impl+i'face): FStar.String (499 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Char.fsti
Verified module: FStar.UInt128 (16534 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperHeap.fst hyperheap/FStar.ST.fst FStar.Util.fst
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified i'face (or impl+i'face): FStar.Universe (21 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperStack.fst hyperstack/FStar.ST.fst hyperstack/FStar.All.fst FStar.Monotonic.RRef.fst FStar.Monotonic.Seq.fst
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (==(p1, p2))))
Verified i'face (or impl+i'face): FStar.Float (45 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints FStar.Map.fst FStar.HyperStack.fst hyperstack/FStar.ST.fst FStar.Buffer.fst FStar.Buffer.Quantifiers.fst
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified i'face (or impl+i'face): FStar.Option (33 milliseconds)
All verification conditions discharged successfully
/cygdrive/c/Build/Agent2/_work/1/s/bin/fstar.exe --trace_error --use_hints hyperstack/FStar.ST.fst hyperstack/FStar.All.fst FStar.Struct.fst
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
Verified module: WhileReify (7934 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
Verified module: FStar.UInt16 (17196 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified i'face (or impl+i'face): FStar.Char (330 milliseconds)
All verification conditions discharged successfully
Verified module: ElGamal (2832 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
Verified i'face (or impl+i'face): FStar.Matrix2 (3586 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (==(p1, p2))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Int.Cast (32394 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (exists x:a.{:pattern } p x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (q x)))
is_smt_pat called with ((ensures (==>(p, q ()))))
is_smt_pat called with ((ensures (\/(p, ~(p)))))
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
Verified module: FStar.UInt64 (14888 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures (==(x1, x2))))
Verified module: FStar.UInt8 (16005 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
Verified i'face (or impl+i'face): FStar.BaseTypes (29 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (f x)))
is_smt_pat called with ((ensures (=(+(length (fst (partition f l)), length (snd (partition f l))), length l))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (=(length (rev_acc l acc), +(length l, length acc)))))
is_smt_pat called with ((ensures (=(length (rev l), length l))))
is_smt_pat called with ((ensures (<==>(mem x (rev_acc l acc), (\/(mem x l, mem x acc))))))
is_smt_pat called with ((ensures (<==>(mem x (rev l), mem x l))))
is_smt_pat called with ((ensures (==(@((Prims.Nil ), l), l))))
is_smt_pat called with ((ensures (==((@(((Prims.Cons hd tl)), l)), ((Prims.Cons hd (@(tl, l))))))))
is_smt_pat called with ((ensures (==((@(l, ((Prims.Cons hd tl)))), (@((@(l, (Prims.Cons hd (Prims.Nil )))), tl))))))
is_smt_pat called with ((ensures (==((@(l1, (@(l2, l3)))), (@((@(l1, l2)), l3))))))
is_smt_pat called with ((ensures (=(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(mem a (@(l1, l2)), (||(mem a l1, mem a l2))))))
is_smt_pat called with ((ensures (=(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (forall a.{:pattern } =(count a (@(l1, l2)), (+(count a l1, count a l2))))))
is_smt_pat called with ((ensures (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Nil ))))))
is_smt_pat called with ((ensures (\/((/\(==(l1, (Prims.Cons x (Prims.Nil ))), ==(l2, (Prims.Nil )))), (/\(==(l1, (Prims.Nil )), ==(l2, (Prims.Cons x (Prims.Nil )))))))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==((rev_acc l acc), (@((rev' l), acc))))))
is_smt_pat called with ((ensures (==((rev l), (rev' l)))))
is_smt_pat called with ((ensures (==((rev' (@(l1, l2))), (@((rev' l2), (rev' l1)))))))
is_smt_pat called with ((ensures (==((rev (@(l1, l2))), (@((rev l2), (rev l1)))))))
is_smt_pat called with ((ensures (==(rev' (rev' l), l))))
is_smt_pat called with ((ensures (==(rev (rev l), l))))
is_smt_pat called with ((ensures (p (rev' l))))
is_smt_pat called with ((ensures (p l)))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in =(mem x l, (||(mem x l1, mem x l2))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition f l in (forall x.{:pattern } =(mem x l, (||(mem x l1, mem x l2)))))))
is_smt_pat called with ((ensures (let  (l1, l2) = partition p l in /\((forall x.{:pattern } ==>(mem x l1, p x)), (forall x.{:pattern } ==>(mem x l2, not (p x)))))))
is_smt_pat called with ((ensures (=(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures (forall x.{:pattern } =(count x l, (+(count x (fst (partition f l)), count x (snd (partition f l))))))))
is_smt_pat called with ((ensures False))
is_smt_pat called with ((ensures (noRepeats #a ((Prims.Cons h tl)))))
is_smt_pat called with ((ensures (==(assoc x' ((Prims.Cons ((Prims.Mktuple2 x y)) q)), assoc x' q))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==>(p x, p (fold_left f x l))))
is_smt_pat called with ((ensures forall x:a.{:pattern } ==(fold_left f_aba x l, fold_left f_aca x (map f_bc l))))
is_smt_pat called with ((ensures forall x.{:pattern } ==((fold_left opA x l), (opA x (fold_left opA zeroA l)))))
is_smt_pat called with ((ensures ==(fold_left f z (@(l1, l2)), f (fold_left f z l1) (fold_left f z l2))))
is_smt_pat called with ((ensures (==(l1, l2))))
is_smt_pat called with ((ensures (==>((/\(mem m l1, strict_prefix_of l1 l2)), mem m l2))))
is_smt_pat called with ((ensures (/\(<<(x, l), <<(y, l)))))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
Verified module: FStar.HyperStack (19604 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
Verified module: FStar.Int63 (12797 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (==(p1, p2))))
Verified module: FStar.Int128 (13338 milliseconds)
All verification conditions discharged successfully
Verified module: UnionFind (38254 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (modifies (union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.Int16 (11690 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
Verified module: FStar.Math.Lemmas (41384 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures hasEq rid))
is_smt_pat called with ((ensures (disjoint j k)))
is_smt_pat called with ((ensures (modifies_just (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (modifies (Set.union s1 s2) m1 m3)))
is_smt_pat called with ((ensures (Set.subset (mod_set (Set.singleton i)) (mod_set (Set.singleton j)))))
is_smt_pat called with ((ensures (modifies (Set.singleton j) m1 m2)))
is_smt_pat called with ((ensures (modifies s2 m1 m2)))
is_smt_pat called with ((ensures (<>(j, root))))
Verified module: FStar.Seq.Properties (50759 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (~((is_in r m.h)))))
is_smt_pat called with ((ensures (\/(is_eternal_region r, Map.contains m.h r))))
is_smt_pat called with ((ensures (is_in x.id m.h)))
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
is_smt_pat called with ((ensures (forall i:nat.{:pattern } ==>((/\(<(i, m), >=(i, n))), (=(Seq.index (logxor_vec x y) (-(-(m, 1), i)), false))))))
is_smt_pat called with ((ensures (<(*(c, a), *(c, b)))))
is_smt_pat called with ((ensures (=(a, /(c, b)))))
is_smt_pat called with ((ensures (=(div_non_eucl a b, 0))))
is_smt_pat called with ((ensures (<(+(a, *(q, b)), *(q, (+(b, 1)))))))
is_smt_pat called with ((ensures (<=(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (<(*(a, b), *(a, c)))))
is_smt_pat called with ((ensures (<=(*(b, a), *(c, a)))))
is_smt_pat called with ((ensures (=(*((-(a, b)), c), -(*(a, c), *(b, c))))))
is_smt_pat called with ((ensures (/\(<(*(a, c), *(b, d)), >(*(a, c), -((*(b, d))))))))
is_smt_pat called with (decreases n)
is_smt_pat called with ((ensures (=(%(a, b), a))))
is_smt_pat called with ((ensures (<(/(a, pow2 m), pow2 (-(n, m))))))
is_smt_pat called with ((ensures (=(x, z))))
is_smt_pat called with ((ensures (=(a, b))))
is_smt_pat called with ((ensures (=(a, *(p, (/(a, p)))))))
is_smt_pat called with ((ensures (=(a, *((/(a, p)), p)))))
is_smt_pat called with ((ensures (let  r = %((+(a, b)), p) in /\(/\((<=(r, +(a, b))), (<=(r, +(a, c)))), (let  qb = /((-((+(a, b)), r)), p) in let  qc = /((-((+(a, c)), r)), p) in =(+(a, b), +((+(a, c)), -(*(p, qb), *(p, qc)))))))))
is_smt_pat called with ((ensures (=(b, c))))
is_smt_pat called with ((ensures (=(%(a, p), %(b, p)))))
is_smt_pat called with ((ensures =(%(a, b), a)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures =(/(a, b), 0)))
is_smt_pat called with ((ensures <(a, b)))
is_smt_pat called with ((ensures (False)))
is_smt_pat called with ((ensures (<=(/(a, d), /(b, d)))))
is_smt_pat called with ((ensures (/\(>=(a, *(n, b)), =(/((-(a, *(n, b))), b), -(/(a, b), n))))))
is_smt_pat called with ((ensures (=(%((-(a, *(n, b))), b), %(a, b)))))
is_smt_pat called with ((ensures (==(%(a, p), 0))))
is_smt_pat called with ((ensures (==(%((/(a, 2)), pow2 (-(m, 1))), 0))))
Verified module: FStar.Map (5861 milliseconds)
Verified module: FStar.HyperHeap (20191 milliseconds)
Verified module: FStar.ST (1126 milliseconds)
Verified module: FStar.Util (29 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures equal (to_vec a) (to_vec b)))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures =(from_vec a, from_vec b)))
is_smt_pat called with ((ensures equal a b))
is_smt_pat called with ((ensures =(+(+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(n, s2))), *((from_vec #(-(s1, s2)) (slice a s2 s1)), pow2 (-(n, s1)))), (from_vec #(-(n, s1)) (slice a s1 n))), +(*((+(*((from_vec #s2 (slice a 0 s2)), pow2 (-(s1, s2))), (from_vec #(-(s1, s2)) (slice a s2 s1)))), pow2 (-(n, s1))), (from_vec #(-(n, s1)) (slice a s1 n))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a 0 s), /((from_vec #n a), (pow2 (-(n, s)))))))
is_smt_pat called with ((ensures =(from_vec #s (slice a (-(n, s)) n), %((from_vec #n a), (pow2 s)))))
is_smt_pat called with ((ensures =(a, b)))
is_smt_pat called with ((ensures (=(logand #n a b, logand #n b a))))
is_smt_pat called with ((ensures (=(logand #n (logand #n a b) c, logand #n a (logand #n b c)))))
is_smt_pat called with ((ensures (=(logand #n a a, a))))
is_smt_pat called with ((ensures (=(logand #n a (zero n), zero n))))
is_smt_pat called with ((ensures (=(logand #n a (ones n), a))))
is_smt_pat called with ((ensures (=(logxor #n a b, logxor #n b a))))
is_smt_pat called with ((ensures (=(logxor #n (logxor #n a b) c, logxor #n a (logxor #n b c)))))
is_smt_pat called with ((ensures (=(logxor #n a a, zero n))))
is_smt_pat called with ((ensures (=(logxor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logxor #n a (ones n), lognot #n a))))
is_smt_pat called with ((ensures (=(logor #n a b, logor #n b a))))
is_smt_pat called with ((ensures (=(logor #n (logor #n a b) c, logor #n a (logor #n b c)))))
is_smt_pat called with ((ensures (=(logor #n a a, a))))
is_smt_pat called with ((ensures (=(logor #n a (zero n), a))))
is_smt_pat called with ((ensures (=(logor #n a (ones n), ones n))))
is_smt_pat called with ((ensures (=(lognot #n (lognot #n a), a))))
is_smt_pat called with ((ensures (=(lognot #n (zero n), ones n))))
is_smt_pat called with ((ensures (==(logor #n a b, +(a, b)))))
is_smt_pat called with ((ensures (=(shift_left #n (logand #n a b) s, logand #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logand #n a b) s, logand #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logxor #n a b) s, logxor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logxor #n a b) s, logxor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures (=(shift_left #n (logor #n a b) s, logor #n (shift_left #n a s) (shift_left #n b s)))))
is_smt_pat called with ((ensures (=(shift_right #n (logor #n a b) s, logor #n (shift_right #n a s) (shift_right #n b s)))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a 0, %((*(a, pow2 0)), pow2 n))))
is_smt_pat called with ((ensures =(shift_left #n a s, %((*(a, pow2 s)), pow2 n))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures =(shift_right #n a 0, /(a, pow2 0))))
is_smt_pat called with ((ensures =(shift_right #n a s, /(a, pow2 s))))
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
is_smt_pat called with ((ensures (equal m1 m2)))
is_smt_pat called with ((ensures (==(m1, m2))))
is_smt_pat called with ((ensures (==(sel (restrict p m) k, sel m k))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inl k1)), sel m1 k1))))
is_smt_pat called with ((ensures (==(sel (concat m1 m2) ((Inr k2)), sel m2 k2))))
is_smt_pat called with ((ensures (path_disjoint p2 p1)))
is_smt_pat called with ((ensures (/\(==(as_buffer_type p1, as_buffer_type p2), ==(as_buffer p1, as_buffer p2)))))
is_smt_pat called with ((ensures (/\(==(as_buffer_type (gfield p fd), as_buffer_type p), ==(as_buffer (gfield p fd), as_buffer p)))))
is_smt_pat called with ((ensures (disjoint p1 p2)))
is_smt_pat called with ((ensures (disjoint p1' p2')))
is_smt_pat called with ((ensures (disjoint p2 p1)))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (/\(Buffer.modifies_0 h0 h1, modifies_ptr_0 h0.HS.tip h0 h1))))
is_smt_pat called with ((ensures (/\(Buffer.modifies_1 (as_buffer b) h0 h1, modifies_ptr_1 (frameOf b) b h0 h1))))
Verified module: UnionFind.Functions (61622 milliseconds)
All verification conditions discharged successfully
is_smt_pat called with ((ensures (/\(equal s1 t1, equal s2 t2))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (length s1))
is_smt_pat called with ((ensures (equal (append s1 s2) (cons (head s1) (append (tail s1) s2)))))
is_smt_pat called with ((ensures (=(count x (append lo hi), (+(count x lo, count x hi))))))
is_smt_pat called with ((ensures (=(count x s, count x (swap s i j)))))
is_smt_pat called with ((ensures (permutation a (cons (head s) tl) s)))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s i (+(j, 1))), f y pv)))))
is_smt_pat called with ((ensures ((forall y.{:pattern } ==>(mem y (slice s back len), f pv y)))))
is_smt_pat called with ((ensures (/\((==(slice s1 m n, slice s2 m n)), (==(index s1 m, index s2 m))))))
is_smt_pat called with ((ensures (/\((==(slice s1 i j, slice s2 i j)), (==(index s1 j, index s2 j))))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s2 i s1 k))))
is_smt_pat called with ((ensures (==(s1, splice s3 i s1 j))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s2 i k) (slice s1 i k))))
is_smt_pat called with ((ensures (permutation a (slice s1 i j) (slice s3 i j))))
is_smt_pat called with ((ensures (Seq.equal (cons hd (snoc s tl)) (snoc (cons hd s) tl))))
is_smt_pat called with ((ensures (/\(==(v1, v2), equal s1 s2))))
is_smt_pat called with (decreases (Seq.length s))
is_smt_pat called with ((ensures contains (append s1 s2) x))
Verified module: ReifyLong (74673 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/rel'
is_smt_pat called with ((ensures (==(x1, x2))))
is_smt_pat called with ((ensures (TSet.subset (arefs s1) (arefs s2))))
is_smt_pat called with ((ensures (disjoint_from_bufs b (only b'))))
is_smt_pat called with ((ensures (modifies_0 h0 h1)))
is_smt_pat called with ((ensures (modifies_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2_1 b h0 h1)))
is_smt_pat called with ((ensures (modifies_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_3 b b' b'' h0 h1)))
is_smt_pat called with ((ensures (modifies_3_2 b b' h0 h1)))
is_smt_pat called with ((ensures (modifies_region rid bufs h0 h1)))
is_smt_pat called with ((ensures (/\(/\(modifies_one h0.tip h0 h1, modifies_buf_0 h0.tip h0 h1), =(h0.tip, h1.tip)))))
is_smt_pat called with ((ensures (let  rid = frameOf b in /\(modifies_one rid h0 h1, modifies_buf_1 rid b h0 h1))))
is_smt_pat called with ((ensures (let  rid = frameOf b in (\/((/\(/\(=(rid, h0.tip), modifies_buf_1 rid b h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, h0.tip), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/((/\(/\(=(rid, rid'), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(<>(rid, rid'), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in let  rid'' = frameOf b'' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', rid'')), modifies_buf_3 rid b b' b'' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', rid'')), modifies_buf_2 rid b b' h0 h1), modifies_buf_1 rid'' b'' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', rid'')), modifies_buf_2 rid' b' b'' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid'')) h0.h h1.h))), (/\(/\(/\(/\(=(rid, rid''), <>(rid', rid'')), modifies_buf_2 rid b b'' h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton rid')) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', rid'')), <>(rid, rid'')), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton rid'')) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid'' b'' h0 h1)))))))
is_smt_pat called with ((ensures (let  rid = frameOf b in let  rid' = frameOf b' in (\/(\/(\/(\/((/\(/\(/\(=(rid, rid'), =(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_one rid h0 h1)), (/\(/\(/\(/\(=(rid, rid'), <>(rid', h0.tip)), modifies_buf_2 rid b b' h0 h1), modifies_buf_0 h0.tip h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid, h0.tip)), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), HH.modifies_just (Set.union (Set.singleton rid') (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(<>(rid, rid'), =(rid', h0.tip)), modifies_buf_1 rid' b' h0 h1), modifies_buf_1 rid b h0 h1), HH.modifies_just (Set.union (Set.singleton rid) (Set.singleton h0.tip)) h0.h h1.h))), (/\(/\(/\(/\(/\(/\(<>(rid, rid'), <>(rid', h0.tip)), <>(rid, h0.tip)), HH.modifies_just (Set.union (Set.union (Set.singleton rid) (Set.singleton rid')) (Set.singleton h0.tip)) h0.h h1.h), modifies_buf_1 rid b h0 h1), modifies_buf_1 rid' b' h0 h1), modifies_buf_0 h0.tip h0 h1)))))))
is_smt_pat called with ((ensures (/\(modifies_one rid h0 h1, modifies_bufs rid bufs h0 h1))))
is_smt_pat called with ((ensures (==(Map.domain h.h, Map.domain (upd h x v).h))))
is_smt_pat called with ((ensures (==(h2, h0))))
is_smt_pat called with ((ensures (==(h3, h0))))
is_smt_pat called with ((ensures (equal_domains h2 h3)))
unknown(0,0-0,0) :  : (Warning) FStar.Struct: Unexpected output from Z3: (error "line 138346 column 43: unknown constant @x26")

Verified module: FStar.Map (5396 milliseconds)
Verified module: FStar.HyperStack (15431 milliseconds)
Verified module: FStar.ST (10581 milliseconds)
Verified module: FStar.All (45 milliseconds)
Verified module: FStar.Monotonic.RRef (1196 milliseconds)
Verified module: FStar.Monotonic.Seq (14278 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.UInt (87391 milliseconds)
All verification conditions discharged successfully
Verified module: FStar.ST (13274 milliseconds)
Verified module: FStar.All (53 milliseconds)
Verified module: FStar.Struct (54087 milliseconds)
All verification conditions discharged successfully
Verified module: StackMachine (338450 milliseconds)
All verification conditions discharged successfully
make[3]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples/metatheory'
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/examples'
is_smt_pat called with ((ensures (/\(/\(/\(/\(live h0 b, live h0 b'), live h1 b'), (forall i:nat.{:pattern (get h1 b' (+(v bi', i)))} ==>(<(i, v len), ==(get h1 b' (+(v bi', i)), get h0 b (+(v bi, i)))))), (forall i:nat.{:pattern (get h1 b' i)} ==>((\/((/\(>=(i, +(v bi', v len)), <(i, length b'))), <(i, v bi'))), ==(get h1 b' i, get h0 b' i)))))))
Verified module: FStar.Map (5657 milliseconds)
Verified module: FStar.HyperStack (15832 milliseconds)
Verified module: FStar.ST (12150 milliseconds)
Verified module: FStar.Buffer (162916 milliseconds)
Verified module: FStar.Buffer.Quantifiers (5191 milliseconds)
All verification conditions discharged successfully
make[2]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/ulib'
make[1]: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
make: Leaving directory '/cygdrive/c/Build/Agent2/_work/1/s/src'
